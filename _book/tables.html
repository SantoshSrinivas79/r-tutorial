<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="  Quick R Tutorial" />
<meta property="og:type" content="book" />


<meta property="og:description" content="This book covers the essentials of using R." />


<meta name="author" content="Frank Erickson" />

<meta name="date" content="2017-04-06" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<meta name="description" content="This book covers the essentials of using R.">

<title>  Quick R Tutorial</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link rel="stylesheet" href="style.css" type="text/css" />

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
</style>
</head>

<body>

<div class="container-fluid main-container">


<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li class="has-sub"><a href="index.html#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="index.html#getting-started-with-r"><span class="toc-section-number">1.1</span> Getting started with R</a></li>
<li><a href="index.html#reading-this-book"><span class="toc-section-number">1.2</span> Reading this book</a></li>
<li><a href="index.html#about-this-book"><span class="toc-section-number">1.3</span> About this book</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#basics"><span class="toc-section-number">2</span> Basics</a><ul>
<li class="has-sub"><a href="basics.html#vectors"><span class="toc-section-number">2.1</span> Vectors</a><ul>
<li><a href="basics.html#documentation"><span class="toc-section-number">2.1.1</span> Documentation</a></li>
<li><a href="basics.html#classes"><span class="toc-section-number">2.1.2</span> Classes</a></li>
<li><a href="basics.html#making-comparisons"><span class="toc-section-number">2.1.3</span> Making comparisons</a></li>
<li><a href="basics.html#str"><span class="toc-section-number">2.1.4</span> Inspecting objects</a></li>
<li><a href="basics.html#names"><span class="toc-section-number">2.1.5</span> Named elements</a></li>
<li><a href="basics.html#na"><span class="toc-section-number">2.1.6</span> Missing values</a></li>
<li><a href="basics.html#slicing"><span class="toc-section-number">2.1.7</span> Slicing to a subvector</a></li>
<li><a href="basics.html#extract-list"><span class="toc-section-number">2.1.8</span> Extracting from a list</a></li>
<li><a href="basics.html#subassigning"><span class="toc-section-number">2.1.9</span> Assigning to a subvector</a></li>
<li><a href="basics.html#assigning-to-a-list-element"><span class="toc-section-number">2.1.10</span> Assigning to a list element</a></li>
<li><a href="basics.html#initializing"><span class="toc-section-number">2.1.11</span> Initializing</a></li>
<li><a href="basics.html#factors"><span class="toc-section-number">2.1.12</span> Factors</a></li>
<li><a href="basics.html#sort-rank-order"><span class="toc-section-number">2.1.13</span> Sorting, rank, order</a></li>
<li><a href="basics.html#exercises"><span class="toc-section-number">2.1.14</span> Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#matrix-array"><span class="toc-section-number">2.2</span> Matrices and arrays</a><ul>
<li><a href="basics.html#building-matrices"><span class="toc-section-number">2.2.1</span> Building matrices</a></li>
<li><a href="basics.html#named-rows-and-columns"><span class="toc-section-number">2.2.2</span> Named rows and columns</a></li>
<li><a href="basics.html#slicing-matrix"><span class="toc-section-number">2.2.3</span> Slicing to a submatrix</a></li>
<li><a href="basics.html#matrix-extract"><span class="toc-section-number">2.2.4</span> Extracting from matrices</a></li>
<li><a href="basics.html#subassigning-to-matrices"><span class="toc-section-number">2.2.5</span> Subassigning to matrices</a></li>
<li><a href="basics.html#arrays"><span class="toc-section-number">2.2.6</span> Arrays</a></li>
<li><a href="basics.html#matrix-misc"><span class="toc-section-number">2.2.7</span> Computing with matrices</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#syntax"><span class="toc-section-number">2.3</span> Syntax</a><ul>
<li><a href="basics.html#assigning-to-attributes"><span class="toc-section-number">2.3.1</span> Assigning to attributes</a></li>
<li><a href="basics.html#arithmetic"><span class="toc-section-number">2.3.2</span> Arithmetic</a></li>
<li><a href="basics.html#logical-operators"><span class="toc-section-number">2.3.3</span> Logical operators</a></li>
<li><a href="basics.html#vectorization"><span class="toc-section-number">2.3.4</span> Elementwise operations</a></li>
<li><a href="basics.html#matrix-algebra"><span class="toc-section-number">2.3.5</span> Matrix algebra</a></li>
<li><a href="basics.html#order-ops"><span class="toc-section-number">2.3.6</span> Order of operations</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#functions"><span class="toc-section-number">2.4</span> Functions</a><ul>
<li><a href="basics.html#community-made-functions"><span class="toc-section-number">2.4.1</span> Community-made functions</a></li>
<li><a href="basics.html#passing-arguments"><span class="toc-section-number">2.4.2</span> Passing arguments</a></li>
<li><a href="basics.html#lapply"><span class="toc-section-number">2.4.3</span> Iterating over a list</a></li>
<li><a href="basics.html#function-writing"><span class="toc-section-number">2.4.4</span> Writing functions</a></li>
<li><a href="basics.html#scoping"><span class="toc-section-number">2.4.5</span> Scoping</a></li>
<li><a href="basics.html#lazy"><span class="toc-section-number">2.4.6</span> Lazy evaluation</a></li>
<li><a href="basics.html#function-environment"><span class="toc-section-number">2.4.7</span> Environment</a></li>
<li><a href="basics.html#default-args"><span class="toc-section-number">2.4.8</span> Default arguments</a></li>
<li><a href="basics.html#finding-a-function-by-name"><span class="toc-section-number">2.4.9</span> Finding a function by name</a></li>
<li><a href="basics.html#inspect-fns"><span class="toc-section-number">2.4.10</span> Inspecting function source code</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#loops"><span class="toc-section-number">2.5</span> Loops and control flow</a><ul>
<li><a href="basics.html#for-loops"><span class="toc-section-number">2.5.1</span> Thinking about <code>for</code> loops</a></li>
<li><a href="basics.html#ifelse"><span class="toc-section-number">2.5.2</span> <code>if</code>/<code>else</code> elementwise</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#data-frames"><span class="toc-section-number">2.6</span> Data frames</a><ul>
<li><a href="basics.html#lapply-df"><span class="toc-section-number">2.6.1</span> Iterating over columns</a></li>
<li><a href="basics.html#view"><span class="toc-section-number">2.6.2</span> Inspection</a></li>
</ul></li>
<li><a href="basics.html#built-ins"><span class="toc-section-number">2.7</span> Built-in constants</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#tables"><span class="toc-section-number">3</span> Tables</a><ul>
<li class="has-sub"><a href="tables.html#essential-packages"><span class="toc-section-number">3.1</span> Essential packages</a><ul>
<li><a href="tables.html#magrittr"><span class="toc-section-number">3.1.1</span> The magrittr package</a></li>
<li><a href="tables.html#data-table"><span class="toc-section-number">3.1.2</span> The data.table package</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-class"><span class="toc-section-number">3.2</span> The data.table class</a><ul>
<li><a href="tables.html#dt-inspect"><span class="toc-section-number">3.2.1</span> Inspecting</a></li>
<li><a href="tables.html#dt-slicing"><span class="toc-section-number">3.2.2</span> Slicing</a></li>
<li><a href="tables.html#extracting-columns"><span class="toc-section-number">3.2.3</span> Extracting columns</a></li>
<li><a href="tables.html#extensions-to-the-data.frame-class"><span class="toc-section-number">3.2.4</span> Extensions to the data.frame class</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-agg"><span class="toc-section-number">3.3</span> Aggregation</a><ul>
<li><a href="tables.html#dt-lapply"><span class="toc-section-number">3.3.1</span> Iterating over columns</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-subassign"><span class="toc-section-number">3.4</span> Modifying data</a><ul>
<li><a href="tables.html#dt-col-create"><span class="toc-section-number">3.4.1</span> Creating columns</a></li>
<li><a href="tables.html#removing-columns"><span class="toc-section-number">3.4.2</span> Removing columns</a></li>
<li><a href="tables.html#dt-replace-all"><span class="toc-section-number">3.4.3</span> Replacing entire columns</a></li>
<li><a href="tables.html#dt-ifelse"><span class="toc-section-number">3.4.4</span> Replacing columns conditionally</a></li>
<li><a href="tables.html#other-in-place-modifications"><span class="toc-section-number">3.4.5</span> Other in-place modifications</a></li>
<li><a href="tables.html#avoiding-in-place-modification"><span class="toc-section-number">3.4.6</span> Avoiding in-place modification</a></li>
<li><a href="tables.html#using-in-place-modification-in-functions"><span class="toc-section-number">3.4.7</span> Using in-place modification in functions</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-joins"><span class="toc-section-number">3.5</span> Joins</a><ul>
<li><a href="tables.html#equi-joins"><span class="toc-section-number">3.5.1</span> Equi joins</a></li>
<li><a href="tables.html#subset-lookup"><span class="toc-section-number">3.5.2</span> Subset lookup</a></li>
<li><a href="tables.html#aggregating-in-a-join"><span class="toc-section-number">3.5.3</span> Aggregating in a join</a></li>
<li><a href="tables.html#joins-update"><span class="toc-section-number">3.5.4</span> Updating in a join</a></li>
<li><a href="tables.html#self-join-to-fill-in-missing-levels"><span class="toc-section-number">3.5.5</span> Self join to fill in missing levels</a></li>
<li><a href="tables.html#join-matches"><span class="toc-section-number">3.5.6</span> Handling matches</a></li>
<li><a href="tables.html#joins-nonequi"><span class="toc-section-number">3.5.7</span> Non-equi joins</a></li>
<li><a href="tables.html#shortcuts-and-tricks"><span class="toc-section-number">3.5.8</span> Shortcuts and tricks</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#input-output"><span class="toc-section-number">3.6</span> Input and output</a><ul>
<li><a href="tables.html#file-paths"><span class="toc-section-number">3.6.1</span> File paths</a></li>
<li><a href="tables.html#fread"><span class="toc-section-number">3.6.2</span> <code>fread</code> to read delimited files</a></li>
<li><a href="tables.html#rbindlist-read"><span class="toc-section-number">3.6.3</span> <code>rbindlist</code> to combine tables</a></li>
<li><a href="tables.html#dates-times"><span class="toc-section-number">3.6.4</span> Date and time columns</a></li>
<li><a href="tables.html#char-input"><span class="toc-section-number">3.6.5</span> Character columns</a></li>
<li><a href="tables.html#dt-recode"><span class="toc-section-number">3.6.6</span> Categorical columns</a></li>
<li><a href="tables.html#list-columns"><span class="toc-section-number">3.6.7</span> List columns</a></li>
<li><a href="tables.html#fwrite"><span class="toc-section-number">3.6.8</span> <code>fwrite</code> to write delimited files</a></li>
<li><a href="tables.html#dt-saveload"><span class="toc-section-number">3.6.9</span> Saving and loading R objects</a></li>
<li><a href="tables.html#reading-and-writing-other-formats"><span class="toc-section-number">3.6.10</span> Reading and writing other formats</a></li>
<li><a href="tables.html#format-cols"><span class="toc-section-number">3.6.11</span> Formatting the display of columns</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#exploring-data"><span class="toc-section-number">3.7</span> Exploring data</a><ul>
<li><a href="tables.html#browse-env"><span class="toc-section-number">3.7.1</span> Browsing loaded objects</a></li>
<li><a href="tables.html#dt-subset"><span class="toc-section-number">3.7.2</span> Subsetting</a></li>
<li><a href="tables.html#sorting"><span class="toc-section-number">3.7.3</span> Sorting</a></li>
<li><a href="tables.html#explore-onevar"><span class="toc-section-number">3.7.4</span> Examining each variable</a></li>
<li><a href="tables.html#explore-vars"><span class="toc-section-number">3.7.5</span> Examining variables jointly</a></li>
<li><a href="tables.html#dcast-browse"><span class="toc-section-number">3.7.6</span> Reshaping to wide</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#structuring-data"><span class="toc-section-number">3.8</span> Organizing relational tables</a><ul>
<li><a href="tables.html#redundant"><span class="toc-section-number">3.8.1</span> Removing redundant data</a></li>
<li><a href="tables.html#melt"><span class="toc-section-number">3.8.2</span> Reshaping to long</a></li>
<li><a href="tables.html#relational-updatejoin"><span class="toc-section-number">3.8.3</span> Preparing data with update joins</a></li>
<li><a href="tables.html#program-tables"><span class="toc-section-number">3.8.4</span> Programming with tables</a></li>
</ul></li>
</ul></li>
<li class="has-sub"><a href="work.html#work"><span class="toc-section-number">4</span> Getting work done</a><ul>
<li class="has-sub"><a href="work.html#sets"><span class="toc-section-number">4.1</span> Sets</a><ul>
<li><a href="work.html#unary-operators"><span class="toc-section-number">4.1.1</span> Unary operators</a></li>
<li><a href="work.html#testing-membership"><span class="toc-section-number">4.1.2</span> Testing membership</a></li>
<li><a href="work.html#other-binary-operators"><span class="toc-section-number">4.1.3</span> Other binary operators</a></li>
<li><a href="work.html#operators-on-lists-of-sets"><span class="toc-section-number">4.1.4</span> Operators on lists of sets</a></li>
</ul></li>
<li><a href="work.html#combos"><span class="toc-section-number">4.2</span> Combinations</a></li>
<li class="has-sub"><a href="work.html#randomization"><span class="toc-section-number">4.3</span> Randomization</a><ul>
<li><a href="work.html#distribution-draws"><span class="toc-section-number">4.3.1</span> Distribution draws</a></li>
<li><a href="work.html#urn-draws"><span class="toc-section-number">4.3.2</span> Urn draws</a></li>
<li><a href="work.html#permutations"><span class="toc-section-number">4.3.3</span> Permutations</a></li>
<li><a href="work.html#simulations"><span class="toc-section-number">4.3.4</span> Simulations</a></li>
</ul></li>
<li class="has-sub"><a href="work.html#sequences"><span class="toc-section-number">4.4</span> Working with sequences</a><ul>
<li><a href="work.html#lag"><span class="toc-section-number">4.4.1</span> Lag operators</a></li>
<li><a href="work.html#taking-differences"><span class="toc-section-number">4.4.2</span> Taking differences</a></li>
<li><a href="work.html#rolling"><span class="toc-section-number">4.4.3</span> Rolling computations</a></li>
<li><a href="work.html#run-length-encoding"><span class="toc-section-number">4.4.4</span> Run-length encoding</a></li>
<li><a href="work.html#gids"><span class="toc-section-number">4.4.5</span> Grouping on runs</a></li>
</ul></li>
<li><a href="work.html#combining-table-columns"><span class="toc-section-number">4.5</span> Combining table columns</a></li>
<li class="has-sub"><a href="work.html#reg"><span class="toc-section-number">4.6</span> Regression</a><ul>
<li><a href="work.html#extracting-results"><span class="toc-section-number">4.6.1</span> Extracting results</a></li>
<li><a href="work.html#formulas"><span class="toc-section-number">4.6.2</span> Formulas</a></li>
<li><a href="work.html#custom-regression"><span class="toc-section-number">4.6.3</span> Custom regression</a></li>
</ul></li>
<li class="has-sub"><a href="work.html#numerical-tasks"><span class="toc-section-number">4.7</span> Numerical tasks</a><ul>
<li><a href="work.html#optimization"><span class="toc-section-number">4.7.1</span> Optimization</a></li>
<li><a href="work.html#integration"><span class="toc-section-number">4.7.2</span> Integration</a></li>
</ul></li>
<li><a href="work.html#strings"><span class="toc-section-number">4.8</span> String operations</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="tables" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Tables</h1>
<p>This chapter covers navigating tabular data with R. The core syntax is (<a href="tables.html#dt-syntax">3.2.4.3</a>):</p>
<pre><code>DT[where, select|update|do, by] # SQL verbs
DT[i, j, by]                    # R function arguments</code></pre>
<p>It reads as:</p>
<ol style="list-style-type: decimal">
<li>Subset using <code>i</code>, then</li>
<li>Group using <code>by</code>, then</li>
<li>Do <code>j</code></li>
</ol>
<div id="essential-packages" class="section level2">
<h2><span class="header-section-number">3.1</span> Essential packages</h2>
<p>This section covers packages that help me work more efficiently, to the point where I regard them as essential. They’ll be used throughout the rest of this document. They don’t have any dependencies on other packages, and I expect they’ll be available as long as R is. It will be assumed in subsequent sections that these libraries have been attached:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)
<span class="kw">library</span>(data.table)</code></pre></div>
<div id="magrittr" class="section level3">
<h3><span class="header-section-number">3.1.1</span> The magrittr package</h3>
<p><a href="https://cran.r-project.org/package=magrittr">Magrittr</a> introduces syntax with “pipes,” improving readability by unnesting function calls:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># we can do</span>
x %&gt;%<span class="st"> </span>f %&gt;%<span class="st"> </span>g %&gt;%<span class="st"> </span>h
<span class="co"># instead of </span>
<span class="kw">h</span>(<span class="kw">g</span>(<span class="kw">f</span>(x)))</code></pre></div>
<p>In addition, it allows more compact function definitions (<a href="basics.html#function-writing">2.4.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fun =<span class="st"> </span>. %&gt;%<span class="st"> </span>.^<span class="dv">2</span> %&gt;%<span class="st"> </span>sum %&gt;%<span class="st"> </span>sqrt
<span class="kw">fun</span>(<span class="dv">1</span>:<span class="dv">3</span>)</code></pre></div>
<pre><code># [1] 3.741657</code></pre>
<p>Despite these advantages, magrittr can slow down code, so avoid using it anywhere where speed might be an issue.</p>
<p>To install, just use CRAN:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&#39;magrittr&#39;</span>)</code></pre></div>
<p>The name is a pun on <a href="https://en.wikipedia.org/wiki/The_Treachery_of_Images">René Magritte’s pipe painting</a>. To get a handle on the package, I would start with the package <a href="https://CRAN.R-project.org/package=magrittr/vignettes/magrittr.html">vignette</a>.</p>
</div>
<div id="data-table" class="section level3">
<h3><span class="header-section-number">3.1.2</span> The data.table package</h3>
<p><a href="http://r-datatable.com">Data.table</a> offers a variant of the <code>data.frame</code> class for data frames (seen in <a href="basics.html#data-frames">2.6</a>), optimized for fast sorted and grouped operations and enhanced with cleaner syntax. Section <a href="tables.html#dt-class">3.2</a> introduces this <code>data.table</code> class.</p>
<p>The package also bundles in a variety of other functionality:</p>
<ul>
<li>ITime and IDate date and time classes</li>
<li><code>fread</code> and <code>fwrite</code> for fast reading and writing of delimited files</li>
<li><code>dcast</code> and <code>melt</code> for reshaping tables</li>
</ul>
<p>Because these disparate features are bundled together in data.table, we don’t have to load more packages and worry about their complicated dependencies or namespace conflicts (<a href="basics.html#namespaces">2.4.1.3</a>).</p>
<div id="installation" class="section level4">
<h4><span class="header-section-number">3.1.2.1</span> Installation</h4>
<p>Again, CRAN can be used:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&#39;data.table&#39;</span>)</code></pre></div>
<p>However, the package is under active development, with new features available only in the development version. To install it, follow <a href="https://github.com/Rdatatable/data.table/wiki/Installation">the instructions from the package wiki</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">remove.packages</span>(<span class="st">&quot;data.table&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;data.table&quot;</span>, <span class="dt">type =</span> <span class="st">&quot;source&quot;</span>,
  <span class="dt">repos =</span> <span class="st">&quot;http://Rdatatable.github.io/data.table&quot;</span>)</code></pre></div>
<p>If using Windows, you’ll need to first install <a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a> (requiring administrator privileges), as explained in the last link.</p>
</div>
<div id="getting-started" class="section level4">
<h4><span class="header-section-number">3.1.2.2</span> Getting started</h4>
<p>The official vignettes for the package are a great way to start with the package. See them on the <a href="http://r-datatable.com/Getting-started">wiki</a> or with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">browseVignettes</span>(<span class="dt">package=</span><span class="st">&quot;data.table&quot;</span>)</code></pre></div>
<p>(Beware that as of March 2017, the website vignettes are somewhat out-of-date.) The website also includes links to other useful materials (an online course, presentation materials, blog posts). Before using the package, I started by reading some slides and the FAQ in full.</p>
</div>
</div>
</div>
<div id="dt-class" class="section level2">
<h2><span class="header-section-number">3.2</span> The data.table class</h2>
<p>Data.tables extend the data frame class introduced in <a href="basics.html#data-frames">2.6</a>.</p>
<p>This section reviews basic operations seen in the last chapter (inspecting, slicing, extracting), before discussing how <code>data.table</code> extends <code>data.frame</code>.</p>
<div id="dt-inspect" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Inspecting</h3>
<p>Consider the <code>quakes</code> data set (with more info in <code>?quakes</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT =<span class="st"> </span><span class="kw">data.table</span>(quakes)</code></pre></div>
<pre><code>#          lat   long depth mag stations
#    1: -20.42 181.62   562 4.8       41
#    2: -20.62 181.03   650 4.2       15
#    3: -26.00 184.10    42 5.4       43
#    4: -17.97 181.66   626 4.1       19
#    5: -20.42 181.96   649 4.0       11
#   ---                                 
#  996: -25.93 179.54   470 4.4       22
#  997: -12.28 167.06   248 4.7       35
#  998: -20.13 184.20   244 4.5       34
#  999: -17.40 187.80    40 4.5       14
# 1000: -21.59 170.56   165 6.0      119</code></pre>
<p>By default, data.tables with over 100 rows will print in the compressed form seen above, showing just the first and last five rows. To globally change how many rows are needed, use <code>options(datatable.print.nrows = n)</code>. To override it a single time, use <code>print</code> with <code>nrows=</code>. I usually set <code>nrows=Inf</code> to print all rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT %&gt;%<span class="st"> </span><span class="kw">print</span>(<span class="dt">nrow =</span> <span class="ot">Inf</span>)</code></pre></div>
<p>To browse a table in a new window, <code>View</code> for data frames (<a href="basics.html#view">2.6.2</a>) again works:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT %&gt;%<span class="st"> </span>View
<span class="co"># or if using RStudio</span>
quakeDT %&gt;%<span class="st"> </span>utils::<span class="kw">View</span>()</code></pre></div>
<p>To inspect the structure of a data.table, we can again use <code>str</code> (<a href="basics.html#str">2.1.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT %&gt;%<span class="st"> </span>str</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    1000 obs. of  5 variables:
#  $ lat     : num  -20.4 -20.6 -26 -18 -20.4 ...
#  $ long    : num  182 181 184 182 182 ...
#  $ depth   : int  562 650 42 626 649 195 82 194 211 622 ...
#  $ mag     : num  4.8 4.2 5.4 4.1 4 4 4.8 4.4 4.7 4.3 ...
#  $ stations: int  41 15 43 19 11 12 43 15 35 19 ...
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Here, we see the class of each column along with the first few values. In addition, there is an obscure <code>&quot;.internal.selfref&quot;</code> attribute, which we can ignore except when saving or loading the table from disk (<a href="tables.html#dt-saveload">3.6.9</a>). Other attributes will sometimes also show up here, related to optimizing the performance of ordered or grouped queries on the table (<a href="tables.html#keys-indices">3.5.8.1</a>).</p>
<p>In the code above, we could use syntax like <code>View(quakeDT)</code> instead of <code>quakeDT %&gt;% View</code>, but I often find the latter handier, since it’s easy to insert intermediate steps, like <code>quakeDT %&gt;% head(10) %&gt;% View</code>. Also, while <code>%&gt;%</code> is slow, it’s not going to matter for tasks like browsing data.</p>
</div>
<div id="dt-slicing" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Slicing</h3>
<p>A slice of a data.table is a smaller data.table formed by subsetting rows, columns, or both, analogous to vector and matrix slices seen in <a href="basics.html#slicing">2.1.7</a> and <a href="basics.html#slicing-matrix">2.2.3</a>. The remaining columns will retain attributes from the full table (class, levels for factors, etc.).</p>
<p>The syntax is familiar from vectors and matrices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[<span class="dv">1</span>:<span class="dv">2</span>, ]</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, <span class="st">&quot;z&quot;</span>]</code></pre></div>
<pre><code>#        z
# 1: FALSE
# 2: FALSE
# 3: FALSE
# 4:  TRUE
# 5:  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[-<span class="dv">3</span>, <span class="kw">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)]</code></pre></div>
<pre><code>#    y     z
# 1: 1 FALSE
# 2: 2 FALSE
# 3: 4  TRUE
# 4: 5  TRUE</code></pre>
<p>One difference with matrices is that when only slicing rows, we can skip the comma:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[<span class="dv">1</span>:<span class="dv">2</span>]</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE</code></pre>
<p>Other differences come into play when subsetting columns programmatically, where we need either a <code>..</code> prefix…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">keep_cols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)
DT[, keep_cols]                  <span class="co"># error</span></code></pre></div>
<pre><code># Error in `[.data.table`(DT, , keep_cols): j (the 2nd argument inside [...]) is a single symbol but column name &#39;keep_cols&#39; is not found. Perhaps you intended DT[,..keep_cols] or DT[,keep_cols,with=FALSE]. This difference to data.frame is deliberate and explained in FAQ 1.1.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, ..keep_cols]                <span class="co"># use this instead</span></code></pre></div>
<pre><code>#    y     z
# 1: 1 FALSE
# 2: 2 FALSE
# 3: 3 FALSE
# 4: 4  TRUE
# 5: 5  TRUE</code></pre>
<p>… or we need <code>with=FALSE</code> if programming inline:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, letters[<span class="dv">25</span>:<span class="dv">26</span>]]             <span class="co"># no error, but doesn&#39;t print what we want</span></code></pre></div>
<pre><code># [1] &quot;y&quot; &quot;z&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, letters[<span class="dv">25</span>:<span class="dv">26</span>], with=<span class="ot">FALSE</span>] <span class="co"># use this instead</span></code></pre></div>
<pre><code>#    y     z
# 1: 1 FALSE
# 2: 2 FALSE
# 3: 3 FALSE
# 4: 4  TRUE
# 5: 5  TRUE</code></pre>
<p>These requirements are a quirk of the more flexible <code>DT[...]</code> syntax that supports far more than taking slices, as discussed in <a href="tables.html#dt-syntax">3.2.4.3</a>.</p>

<div class="rmd-caution">
<strong>Use column names, not numbers.</strong> Subsetting by hard-coded column number, like <code>DT[, 2:3]</code> or <code>cols = 2:3; DT[, ..cols]</code> works but is discouraged. Column numbers can easily change in the course of writing or updating a script, invalidating column number references in a way that will be annoying to debug. See the first answer in <code>vignette(&quot;datatable-faq&quot;)</code> for a deeper discussion.
</div>
<p></p>

<div class="rmd-details">
<strong>How data frame slicing works.</strong> This is really getting in the weeds, since I suggest not using data frames at all, but you’ll see two major differences if you do. First, <code>DT[, &quot;z&quot;]</code> will extract the <code>z</code> column instead of taking a slice thanks to data frames’ <code>drop=TRUE</code> default (which also came up regarding matrices in the last chapter). Second, <code>DT[1:2]</code> will slice the first two <em>columns</em> instead of the first two rows, thanks to the fact that data frames (and data.tables) are lists and the no-comma usage of <code>[</code> triggers list slicing.
</div>
<p></p>
<p><code>head</code>, <code>tail</code> and the special empty and missing-data slices (all seen in the last chapter) work by row:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(DT, -<span class="dv">3</span>)    <span class="co"># top, removing last 3</span></code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(DT, <span class="dv">2</span>)     <span class="co"># bottom 2</span></code></pre></div>
<pre><code>#    x y    z
# 1: d 4 TRUE
# 2: e 5 TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[0L]          <span class="co"># empty </span></code></pre></div>
<pre><code># Empty data.table (0 rows) of 3 cols: x,y,z</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[<span class="ot">NA_integer_</span>] <span class="co"># missing</span></code></pre></div>
<pre><code>#     x  y  z
# 1: NA NA NA</code></pre>
<p>The package also offers <code>first</code> and <code>last</code>, which are simply special cases of <code>head</code> and <code>tail</code>.</p>
<p>Fancier slicing methods, like <code>DT[x &gt; &quot;b&quot;, .(y, z)]</code>, will be introduced with the rest of the <code>DT[...]</code> syntax in <a href="tables.html#dt-syntax">3.2.4.3</a>.</p>
<p>There are some syntactical shortcuts for slicing to a set of columns in <code>j</code>; see <a href="tables.html#program-cols">3.8.4.3</a>.</p>
</div>
<div id="extracting-columns" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Extracting columns</h3>
<p>Since data.tables (and data frames) are lists, we can extract columns like <code>DT$z</code> or <code>DT[[&quot;z&quot;]]</code>.</p>
<p>With the full <code>DT[...]</code> syntax (<a href="tables.html#dt-syntax">3.2.4.3</a>), it is easy to extract a column for a limited set of rows, like <code>DT[x &gt; &quot;b&quot;, z]</code>.</p>
</div>
<div id="extensions-to-the-data.frame-class" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Extensions to the data.frame class</h3>
<p>The first thing to note is that data.tables <em>are</em> data frames, so any function that works on a data frame will work fine with data.tables, too (even if the data.table package is not installed or attached).</p>
<div id="modification-in-place" class="section level4">
<h4><span class="header-section-number">3.2.4.1</span> Modification in-place</h4>
<p>In contrast with the rest of R, data.tables are primarily modified “in-place” (or “by reference”), which can be much more efficient. As a first example, we can switch the class of a data frame to data.table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DF =<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DF)</code></pre></div>
<pre><code># &#39;data.frame&#39;: 5 obs. of  3 variables:
#  $ x: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
#  $ y: num  1 2 3 4 5
#  $ z: logi  FALSE FALSE FALSE TRUE TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setDT</span>(DF)
<span class="kw">str</span>(DF)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    5 obs. of  3 variables:
#  $ x: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
#  $ y: num  1 2 3 4 5
#  $ z: logi  FALSE FALSE FALSE TRUE TRUE
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>We did not use <code>=</code> or <code>&lt;-</code> to assign the result of <code>setDT</code>; the function simply altered <code>DF</code> in-place. All of data.table’s functions named like <code>set*</code> do this.</p>

<div class="rmd-details">
<strong>R’s copy-on-modify.</strong> Understanding the contrast between modification in-place and base R’s modification rules (often called “copy-on-modify”) probably requires some familiarity with C (see threads on <a href="http://stackoverflow.com/questions/15759117/what-exactly-is-copy-on-modify-semantics-in-r-and-where-is-the-canonical-source">stackoverflow</a> or <a href="http://r.789695.n4.nabble.com/Confused-about-NAMED-td4103326.html">the mailing list</a> if interested). I wouldn’t worry about it except to note that many base R operations make copies, which is costly in terms of RAM and computing time; while those operations’ data.table counterparts do not have this problem.
</div>
<p></p>
</div>
<div id="dt-factorvchar" class="section level4">
<h4><span class="header-section-number">3.2.4.2</span> Factor vs character columns</h4>
<p>Another difference is that <code>data.frame(...)</code> reads string input as a <code>factor</code> categorical variable (<a href="basics.html#factors">2.1.12</a>), as seen in the <code>str</code> output above; while <code>data.table(...)</code> reads it as character:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)
<span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    5 obs. of  3 variables:
#  $ x: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
#  $ y: num  1 2 3 4 5
#  $ z: logi  FALSE FALSE FALSE TRUE TRUE
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Data frames’ preference for factors may still bite when reading files in with <code>read.table</code> from base R instead of <code>fread</code> from data.table (<a href="tables.html#fread">3.6.2</a>).</p>
</div>
<div id="dt-syntax" class="section level4">
<h4><span class="header-section-number">3.2.4.3</span> Extended syntax for <code>DT[...]</code> </h4>
<p>The third major difference is the extension of the <code>DT[...]</code> syntax to support more than simple slices (like <code>DF[i,j]</code>, where <code>i</code> and <code>j</code> as indices, covered in <a href="tables.html#dt-slicing">3.2.2</a>). It offers SQL-style syntax that is cleaner, particularly for by-group operations:</p>
<pre><code># (pseudocode)
DT[where, select|update|do, by] # SQL verbs
DT[i, j, by]                    # R function arguments</code></pre>
<p>This should be read as a command to take a sequence of steps:</p>
<ol style="list-style-type: decimal">
<li>Subset using <code>i</code></li>
<li>Group using <code>by</code></li>
<li>Do <code>j</code></li>
</ol>
<p>We can use column names as barewords, and even form expressions in terms of columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[x &gt;<span class="st"> &quot;b&quot;</span>, <span class="kw">sum</span>(y), by=z]</code></pre></div>
<pre><code>#        z V1
# 1: FALSE  3
# 2:  TRUE  9</code></pre>
<p>Typically, the <code>i</code> and <code>j</code> arguments are called by position, as seen here; while <code>by=</code> is called by name.</p>
<p>Whenever <code>j</code> evaluates to a list, the output will be a new data.table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[x &gt;<span class="st"> &quot;b&quot;</span>, .(<span class="dt">n_bigy =</span> <span class="kw">sum</span>(y &gt;<span class="st"> </span><span class="dv">2</span>), <span class="dt">n_smally =</span> <span class="kw">sum</span>(y &lt;=<span class="st"> </span><span class="dv">2</span>)), by=z]</code></pre></div>
<pre><code>#        z n_bigy n_smally
# 1: FALSE      1        0
# 2:  TRUE      2        0</code></pre>

<div class="rmd-caution">
<strong>The <code>.()</code> convenience function.</strong> Inside many arguments of <code>DT[...]</code>, we can use the shorthand <code>.()</code>, which stands for <code>list()</code>.
</div>
<p></p>
<p>The use of <code>by=</code> is very similar to a <code>for</code> loop (<a href="basics.html#for-loops">2.5.1</a>) over subsets, but it is better in a few important ways:</p>
<ul>
<li>We don’t have to manually construct and keep track of some “split-up data” list to iterate over.</li>
<li>Fast by-group functions are used when available (see <code>?GForce</code>)</li>
<li>We don’t have to define the task in <code>j</code> as a function of prespecified variables – we can just use any columns of the data.table.</li>
<li>We don’t have to worry about intermediate variables (like <code>case</code> in the next example) contaminating the global environment.</li>
</ul>
<p>There are some syntactical shortcuts for writing a list of columns in <code>by=</code>; see <a href="tables.html#program-cols">3.8.4.3</a>.</p>
</div>
<div id="dt-syntax-ex" class="section level4">
<h4><span class="header-section-number">3.2.4.4</span> An example</h4>
<p>The task in <code>j</code> can really be anything. Just as a demonstration of its power, here’s how it can be used for saving per-group plots to a PDF:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>

bwDT =<span class="st"> </span><span class="kw">data.table</span>(MASS::birthwt)

<span class="kw">pdf</span>(<span class="dt">file=</span><span class="st">&quot;birthweight_graphs.pdf&quot;</span>)
bwDT[, {
  case =<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;high #visits? = % 5s, smoking? = % 5s&quot;</span>, .BY$high_vis, .BY$smoke)
  
  <span class="kw">cat</span>(<span class="st">&quot;Handling case:&quot;</span>, case, <span class="st">&quot;...</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">plot</span>(
    age ~<span class="st"> </span>lwt, 
    <span class="dt">main =</span> case
  )  
}, by=.(<span class="dt">high_vis =</span> ftv &gt;=<span class="st"> </span><span class="dv">1</span>, <span class="dt">smoke =</span> <span class="kw">as.logical</span>(smoke))]</code></pre></div>
<pre><code># Handling case: high #visits? = FALSE, smoking? = FALSE ...</code></pre>
<pre><code># Handling case: high #visits? =  TRUE, smoking? = FALSE ...</code></pre>
<pre><code># Handling case: high #visits? =  TRUE, smoking? =  TRUE ...</code></pre>
<pre><code># Handling case: high #visits? = FALSE, smoking? =  TRUE ...</code></pre>
<pre><code># Empty data.table (0 rows) of 2 cols: high_vis,smoke</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dev.off</span>()</code></pre></div>
<pre><code># png 
#   2</code></pre>
<p>Plotting graphs is beyond the scope of this document, but the example above should make intuitive sense after reading the docs for each object, <code>?MASS::birthwt</code>, <code>?pdf</code>, et al. For each group, we’re formatting a string with <code>sprintf</code>; printing it with <code>cat</code>; and saving a plot. The special symbol <code>.BY</code> is a list containing the per-group values of the <code>by=</code> variables. Formatting and printing strings will be covered more in <a href="work.html#strings">4.8</a>.</p>

<div class="rmd-caution">
<strong>Filtering on logical columns.</strong> <code>DT[z]</code> and <code>DT[!z]</code> will give errors, for design reasons related to the syntax for joins (<a href="tables.html#dt-joins">3.5</a>). To get around this, always wrap the column in parentheses: <code>DT[(z)]</code> and <code>DT[!(z)]</code>.
</div>
<p></p>

<div class="rmd-caution">
<strong>Grouping on floats.</strong> Much of the computational and syntactical magic of the package comes from grouping rows together with the <code>by=</code> argument. To group on a floating-point variable, however, is just asking for trouble, <a href="http://floating-point-gui.de/">for the usual numerical computing reasons</a>. Instead, always use characters, integers or factors. To discretize a continuous variable into bins, use <code>cut</code>.
</div>
<p></p>

<div class="rmd-details">
<strong>Verbose data.table messages.</strong> To learn how data.table queries work, I recommend toggling the setting <code>options(datatable.verbose = TRUE)</code>. This option is similar to verbose output from an optimization call (reporting the value of the objective at each iteration, etc.). To only see verbose output for a single call, add <code>verbose = TRUE</code>. For example,<code>DT[x &gt; &quot;b&quot;, sum(y), by=z, verbose=TRUE]</code>.
</div>
<p></p>
</div>
</div>
</div>
<div id="dt-agg" class="section level2">
<h2><span class="header-section-number">3.3</span> Aggregation</h2>
<p>The mtcars data set (see <code>?mtcars</code>) has two categorical variables:</p>
<ul>
<li><code>am</code> for automatic (0) or manual (1) transmission; and</li>
<li><code>vs</code> for v (0) or straight (1) engine shape.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
carsDT =<span class="st"> </span><span class="kw">data.table</span>(mtcars, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)
<span class="co"># quick inspection</span>
<span class="kw">first</span>(carsDT)</code></pre></div>
<pre><code>#           rn mpg cyl disp  hp drat   wt  qsec vs am gear carb
# 1: Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4</code></pre>
<p>Suppose we want to compare the mean horsepower, <code>hp</code>, across these categories:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .(<span class="dt">mean_hp =</span> <span class="kw">mean</span>(hp)), by=.(am, vs)]</code></pre></div>
<pre><code>#    am vs   mean_hp
# 1:  1  0 180.83333
# 2:  1  1  80.57143
# 3:  0  1 102.14286
# 4:  0  0 194.16667</code></pre>
<p>So, we just write <code>j</code> of <code>DT[i,j,by]</code> as an expression to compute the summary statistic, optionally giving it a name by wrapping in <code>.(name = expression)</code>.</p>
<p>Sections <a href="tables.html#explore-onevar">3.7.4</a> and <a href="tables.html#explore-vars">3.7.5</a> cover more options for exploring data with summary statistics; and <a href="tables.html#dcast-browse">3.7.6</a> shows how to put this result in wide format (with, e.g., <code>am</code> on rows and <code>vs</code> on columns).</p>
<div id="dt-lapply" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Iterating over columns</h3>
<p>Now suppose we want to compare mean horsepower, weight and displacement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## carsDT[, .(mean_hp = mean(hp), mean_wt = mean(wt), mean_disp = mean(disp)), by=.(am, vs)]
## # can be simplified to...
carsDT[, <span class="kw">lapply</span>(.SD, mean), by=.(am, vs), .SDcols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;hp&quot;</span>, <span class="st">&quot;wt&quot;</span>, <span class="st">&quot;disp&quot;</span>)]</code></pre></div>
<pre><code>#    am vs        hp       wt     disp
# 1:  1  0 180.83333 2.857500 206.2167
# 2:  1  1  80.57143 2.028286  89.8000
# 3:  0  1 102.14286 3.194286 175.1143
# 4:  0  0 194.16667 4.104083 357.6167</code></pre>
<p>So, we just write the relevant columns in <code>.SDcols</code> and refer to <code>.SD</code>, the <em><strong>S</strong>ubset of <strong>D</strong>ata</em>. Within each <code>by=</code> group, the query has access to <code>.SD</code> with rows for that group and columns as specified in <code>.SDcols</code>. <code>.SD</code>, like <code>.BY</code> seen earlier, is a special symbol available in some arguments of <code>DT[...]</code>, documented at <code>?.SD</code>.</p>
<p>We can use <code>lapply</code> (a function designed for iterating over lists) here since <code>.SD</code> is a data.table, which is a list of column vectors (see <a href="basics.html#lapply-df">2.6.1</a>). The column names carry over to the result because <code>lapply</code> always carries over names.</p>
<p>While dot notation <code>.SDcols=.(hp, wt, disp)</code> is not yet supported, there are a variety of convenience features for specifying <code>.SDcols</code>, covered in <a href="tables.html#program-cols">3.8.4.3</a>.</p>

<div class="rmd-caution">
<strong>“Aggregating” across columns.</strong> One major red flag to look out for is the desire to “aggregate” columns by row, setting <code>by=1:nrow(DT)</code> and possibly using <code>unlist(.SD)</code> somewhere. Not only will this be incredibly slow, but it also suggests that the data is poorly organized, costing a lot of extra mental energy at every step. Section <a href="tables.html#structuring-data">3.8</a> explains some ways to format data better to avoid the need for this problematic approach.
</div>
<p></p>
</div>
</div>
<div id="dt-subassign" class="section level2">
<h2><span class="header-section-number">3.4</span> Modifying data</h2>
<p>Creating, editing and removing columns are all done using <code>:=</code> in <code>j</code> of <code>DT[i, j, by]</code>. This functionality operates in-place, in the sense that the underlying data stays in the same place, which is more efficient in terms of how much RAM and time is taken. See <code>vignette(&quot;datatable-reference-semantics&quot;)</code> for details.</p>

<div class="rmd-details">
<strong>What can be modified in-place?</strong> The scope of in-place operations is currently limited to altering columns. Adding and removing rows in-place is not yet supported; it is harder to do in R, due to its column-oriented storage of tables (contrasting with database systems that store data rowwise for easy INSERT and DELETE queries).
</div>
<p></p>
<div id="dt-col-create" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Creating columns</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE
# 3: c 3 FALSE
# 4: d 4  TRUE
# 5: e 5  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creating a column</span>
DT[, u :<span class="er">=</span><span class="st"> </span><span class="dv">5</span>:<span class="dv">1</span>][]</code></pre></div>
<pre><code>#    x y     z u
# 1: a 1 FALSE 5
# 2: b 2 FALSE 4
# 3: c 3 FALSE 3
# 4: d 4  TRUE 2
# 5: e 5  TRUE 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creating multiple</span>
DT[, <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(<span class="dt">v =</span> <span class="dv">2</span>, <span class="dt">w =</span> 3L)][]</code></pre></div>
<pre><code>#    x y     z u v w
# 1: a 1 FALSE 5 2 3
# 2: b 2 FALSE 4 2 3
# 3: c 3 FALSE 3 2 3
# 4: d 4  TRUE 2 2 3
# 5: e 5  TRUE 1 2 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creating with dynamic names</span>
nms =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
DT[, (nms) :<span class="er">=</span><span class="st"> </span>.(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)][]</code></pre></div>
<pre><code>#    x y     z u v w a b c
# 1: a 1 FALSE 5 2 3 1 2 3
# 2: b 2 FALSE 4 2 3 1 2 3
# 3: c 3 FALSE 3 2 3 1 2 3
# 4: d 4  TRUE 2 2 3 1 2 3
# 5: e 5  TRUE 1 2 3 1 2 3</code></pre>
<p>All of these tasks are performed in-place – altering <code>DT</code> without making a new object. Usually, the results are not printed in the console; but they appear here because <code>[]</code> is “chained” onto the end of each task.</p>

<div class="rmd-caution">
<strong><code>:=</code> is the function for <em>creation, modification and deletion</em> of columns.</strong> This will be covered it more detail in subsequent sections, but is worth emphasising. In particular, this contrasts with Stata (which uses distinct verbs <code>gen</code>, <code>replace</code> and <code>drop</code>).
</div>
<p></p>

<div class="rmd-details">
<strong>Iterative column creation.</strong> The <code>`:=`(...)</code> syntax does <em>not</em> support iterative definitions like <code>DT[, `:=`(W1 = u + y, W2 = W1^2)]</code>. One common workaround is <code>DT[, `:=`(W1 = W1 &lt;- u + y, W2 = W1^2)]</code>. This solution may not be intuitive for new R users, but the gist is: <code>W1 &lt;- u + y</code> creates <code>W1</code> as an object in <code>DT[...]</code> and then returns its value, let’s call it <code>v</code>. Now, <code>W2 = W1^2</code> can find <code>W1</code>, since it was created by <code>&lt;-</code>; and <code>W1 = W1 &lt;- u + y</code> simplifies to <code>W1 &lt;- v</code>, where <code>v</code> is the return value of <code>W1 &lt;- u + y</code>.
</div>
<p></p>
</div>
<div id="removing-columns" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Removing columns</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nms =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;v&quot;</span>, <span class="st">&quot;w&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
DT[, (nms) :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span>][]</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE
# 3: c 3 FALSE
# 4: d 4  TRUE
# 5: e 5  TRUE</code></pre>
<p>A warning will print if we remove some columns that don’t currently exist.</p>
</div>
<div id="dt-replace-all" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Replacing entire columns</h3>
<p>Data.table is careful about column types:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span>10L ][]  <span class="co"># Create a new column of integers</span></code></pre></div>
<pre><code>#    x y     z  a
# 1: a 1 FALSE 10
# 2: b 2 FALSE 10
# 3: c 3 FALSE 10
# 4: d 4  TRUE 10
# 5: e 5  TRUE 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span>21L ][]  <span class="co"># Replace it with another column of integers</span></code></pre></div>
<pre><code>#    x y     z  a
# 1: a 1 FALSE 21
# 2: b 2 FALSE 21
# 3: c 3 FALSE 21
# 4: d 4  TRUE 21
# 5: e 5  TRUE 21</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span><span class="fl">32.5</span> ][] <span class="co"># Replace it with a float</span></code></pre></div>
<pre><code># Warning in `[.data.table`(DT, , `:=`(a, 32.5)): Coerced &#39;double&#39; RHS to &#39;integer&#39; to
# match the column&#39;s type; may have truncated precision. Either change the target column
# to &#39;double&#39; first (by creating a new &#39;double&#39; vector length 5 (nrows of entire table)
# and assign that; i.e. &#39;replace&#39; column), or coerce RHS to &#39;integer&#39; (e.g. 1L, NA_[real|
# integer]_, as.*, etc) to make your intent clear and for speed. Or, set the column type
# correctly up front when you create the table and stick to it, please.</code></pre>
<pre><code>#    x y     z  a
# 1: a 1 FALSE 32
# 2: b 2 FALSE 32
# 3: c 3 FALSE 32
# 4: d 4  TRUE 32
# 5: e 5  TRUE 32</code></pre>
<p>The warning in the last call is related to coercion of vector classes (<a href="basics.html#classes">2.1.2</a>).</p>

<div class="rmd-details">
<p><strong>Safeguards against accidental coercion.</strong> The verbose warning printed above is typical for the package and an excellent feature. Running the final command, data.table knows that the <code>a</code> column is of integer type and sees that 32.5 is conspiciously <em>not an integer</em>. So it gives a warning when coercing 32.5 to an integer (to match <code>a</code>).</p>
Elsewhere in R, <code>a</code> would be coerced to match the float <code>32.5</code> – probably not the behavior we want – with no warning. That is, if we have <code>x &lt;- c(21L, 22L)</code>, we can freely assign <code>x[1] &lt;- 32.5</code>; and the same freedom (by which I mean “danger”) is present even if <code>x</code> is a data frame column. For more on the issue, search online for “type safety.”
</div>
<p></p>
<p>If we want this assignment to work, we need to change <code>a</code>’s type by passing a full vector, as described in the warning:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span><span class="kw">rep</span>(<span class="fl">32.5</span>, .N) ][]</code></pre></div>
<pre><code>#    x y     z    a
# 1: a 1 FALSE 32.5
# 2: b 2 FALSE 32.5
# 3: c 3 FALSE 32.5
# 4: d 4  TRUE 32.5
# 5: e 5  TRUE 32.5</code></pre>
<p>The coercion is done silently, but it can be made more visible by turning on <code>verbose</code>, which notes the “plonk” of a full vector replacement. <code>.N</code> is a special symbol for the number of rows (or the number of rows in a subset when <code>i</code> or <code>by=</code> is present).</p>
</div>
<div id="dt-ifelse" class="section level3">
<h3><span class="header-section-number">3.4.4</span> Replacing columns conditionally</h3>
<p>Conditional replacement here is analogous to a SQL UPDATE query or a replace if command in Stata. To illustrate, we will look again at a vectorized <code>if</code>/<code>else</code> assignment, mentioned in <a href="basics.html#ifelse">2.5.2</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[     , b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>] <span class="co"># initialize to baseline value</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> &quot;Zebra&quot;</span>][] <span class="co"># replace based on a condition</span></code></pre></div>
<pre><code>#    x y     z    a        b
# 1: a 1 FALSE 32.5 Aardvark
# 2: b 2 FALSE 32.5    Zebra
# 3: c 3 FALSE 32.5    Zebra
# 4: d 4  TRUE 32.5    Zebra
# 5: e 5  TRUE 32.5    Zebra</code></pre>
<p>This can also be done with chaining:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>][y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> &quot;Zebra&quot;</span>]</code></pre></div>
<p>This chaining works because <code>DT[...][...]</code> is evaluated like <code>(DT[...])[...]</code> and the return value of the piece in parentheses is <code>DT</code> – provided <code>j</code> has a <code>:=</code> statement.</p>

<div class="rmd-caution">
<strong>Broken chains.</strong> If <code>j</code> is not a <code>:=</code> statement, the return value is not the original data.table but rather a new one. Subsequent steps in the chain will not affect the starting table. So, after <code>DT[y &lt; Inf, d := 1]</code> and <code>DT[y &lt; Inf][, d := 2]</code>, what does the <code>d</code> column look like in <code>DT</code>? See the Exercise section of <code>vignette(&quot;datatable-reference-semantics&quot;)</code>; and the Note section of <code>?`:=`</code>.
</div>
<p></p>
<p>As we saw in the last section, partial replacement of a column will trigger a warning if the classes don’t match:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>][y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> </span><span class="dv">111</span>]</code></pre></div>
<pre><code># Warning in `[.data.table`(DT[, `:=`(b, &quot;Aardvark&quot;)], y &gt; 1, `:=`(b, 111)): Coerced
# &#39;double&#39; RHS to &#39;character&#39; to match the column&#39;s type; may have truncated precision.
# Either change the target column to &#39;double&#39; first (by creating a new &#39;double&#39; vector
# length 5 (nrows of entire table) and assign that; i.e. &#39;replace&#39; column), or coerce RHS
# to &#39;character&#39; (e.g. 1L, NA_[real|integer]_, as.*, etc) to make your intent clear and for
# speed. Or, set the column type correctly up front when you create the table and stick to
# it, please.</code></pre>
<p>Another nice feature, similar to Stata, is reporting of the number of rows modified. This can be seen by turning <code>verbose</code> on:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>][y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> &quot;Zebra&quot;</span>, verbose =<span class="st"> </span><span class="ot">TRUE</span>]</code></pre></div>
<pre><code># Detected that j uses these columns: b 
# Assigning to 4 row subset of 5 rows</code></pre>
<p>The number reported is the number of rows assigned to (irrespective of whether their values were changed by the assignment), in contrast with Stata, which reports the number of changes.</p>
</div>
<div id="other-in-place-modifications" class="section level3">
<h3><span class="header-section-number">3.4.5</span> Other in-place modifications</h3>
<p>The data.table package has a few other tools for modifying table attributes in-place:</p>
<ul>
<li><p>The <code>set</code> function is another way of making assignments like <code>:=</code>.</p></li>
<li><p><code>setDT</code> and <code>setDF</code>, seen earlier, alter the class.</p></li>
<li><p><code>setorder</code> will sort the table by some or all of its columns.</p></li>
<li><p><code>setcolorder</code> changes the order in which columns are displayed.</p></li>
<li><p>Indices and the key (explained in <a href="tables.html#keys-indices">3.5.8.1</a>) can be set with <code>setindex</code> and <code>setkey</code>, respectively.</p></li>
<li><p><code>setnames</code> will alter column names. For example, in <a href="tables.html#dt-lapply">3.3.1</a> we saw…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, <span class="kw">lapply</span>(.SD, mean), by=.(am, vs), .SDcols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;hp&quot;</span>, <span class="st">&quot;wt&quot;</span>, <span class="st">&quot;disp&quot;</span>)]</code></pre></div>
<pre><code>#    am vs        hp       wt     disp
# 1:  1  0 180.83333 2.857500 206.2167
# 2:  1  1  80.57143 2.028286  89.8000
# 3:  0  1 102.14286 3.194286 175.1143
# 4:  0  0 194.16667 4.104083 357.6167</code></pre>
<p>… and if we want to add the prefix <code>&quot;mean_&quot;</code> to the results, we can do</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;hp&quot;</span>, <span class="st">&quot;wt&quot;</span>, <span class="st">&quot;disp&quot;</span>)
carsDT[, <span class="kw">lapply</span>(.SD, mean), by=.(am, vs), .SDcols =<span class="st"> </span>cols] %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">setnames</span>(cols, <span class="kw">sprintf</span>(<span class="st">&quot;mean_%s&quot;</span>, cols)) %&gt;%<span class="st"> </span>print</code></pre></div>
<pre><code>#    am vs   mean_hp  mean_wt mean_disp
# 1:  1  0 180.83333 2.857500  206.2167
# 2:  1  1  80.57143 2.028286   89.8000
# 3:  0  1 102.14286 3.194286  175.1143
# 4:  0  0 194.16667 4.104083  357.6167</code></pre>
<p>The trailing <code>%&gt;% print</code> command is used because, <code>setnames</code>, like <code>:=</code> and the other <code>set*</code> operators, does not print the table on its own. The string-formatter <code>sprintf</code> will be explained in <a href="work.html#strings">4.8</a>.</p></li>
<li><p><code>setattr</code> is a general function for altering attributes of a vector or other object (see <code>?attributes</code>). For example, if we have a factor column (encoding categorical data), we can change its “levels”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
fDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">fac =</span> <span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>)))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(fDT$fac)</code></pre></div>
<pre><code># [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fDT$fac %&gt;%<span class="st"> </span><span class="kw">setattr</span>(<span class="st">&quot;levels&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;Q&quot;</span>))
<span class="kw">levels</span>(fDT$fac)</code></pre></div>
<pre><code># [1] &quot;A&quot; &quot;B&quot; &quot;Q&quot;</code></pre></li>
</ul>
</div>
<div id="avoiding-in-place-modification" class="section level3">
<h3><span class="header-section-number">3.4.6</span> Avoiding in-place modification</h3>
<p>To create a new data.table starting from an existing table, use</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT2 =<span class="st"> </span><span class="kw">copy</span>(DT1)</code></pre></div>
<p>We have to use this instead of <code>DT2 = DT1</code> since with the latter we have only created a new “pointer” to the first table. I routinely make copies like this after reading in data (<a href="tables.html#fread">3.6.2</a>) so that I can back out where I tripped over something in the process of data cleaning.</p>
<p>Besides <code>DT2 = DT1</code>, <code>names1 = names(DT1)</code> is also unsafe, since the <code>names</code> function does not extract the column names as they are at a given time, but rather points at the names attribute, which can change as columns are modified or rearranged.</p>
</div>
<div id="using-in-place-modification-in-functions" class="section level3">
<h3><span class="header-section-number">3.4.7</span> Using in-place modification in functions</h3>
<p>A user-written function (<a href="basics.html#function-writing">2.4.4</a>) like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(DT) DT[, newcol :<span class="er">=</span><span class="st"> </span><span class="dv">1111</span> ][]</code></pre></div>
<p>will act like <code>:=</code> and the <code>set*</code> functions, altering its input in-place. This can be useful, but requires extra caution. See the “<code>:=</code> for its side effect” section of <code>vignette(&quot;datatable-reference-semantics&quot;)</code> for discussion.</p>
<p>The <code>[]</code> inside the function is necessary for printing, due to restrictions of R syntax and how data.table gets around them.</p>
</div>
</div>
<div id="dt-joins" class="section level2">
<h2><span class="header-section-number">3.5</span> Joins</h2>
<p>They are called “joins” or “merges.”</p>
<div id="equi-joins" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Equi joins</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
a =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(1L, 1L, 2L, 3L, <span class="ot">NA_integer_</span>), <span class="dt">t =</span> <span class="kw">c</span>(1L, 2L, 1L, 2L, <span class="ot">NA_integer_</span>), <span class="dt">x =</span> <span class="dv">11</span>:<span class="dv">15</span>)</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  1  2 12
# 3:  2  1 13
# 4:  3  2 14
# 5: NA NA 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">y =</span> <span class="kw">c</span>(11L, 15L))</code></pre></div>
<pre><code>#    id  y
# 1:  1 11
# 2:  2 15</code></pre>
<p>The idiom for a simple equi join is <code>x[i, on=.(...)]</code> or <code>x[i]</code> for short:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id)]</code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  1 2 12 11
# 3:  2 1 13 15</code></pre>
<p>It is called an equi join since we are only getting matches where equality holds between the <code>on=</code> columns in the two tables.</p>
<p>Think of <code>x[i]</code> as using index table <code>i</code> to look up rows of <code>x</code>, in the same way an “index matrix” can look up elements of a matrix (<a href="basics.html#matrix-extract">2.2.4</a>). By default, we see results for every row of <code>i</code>, even those that are unmatched.</p>
<p>Here are some more complicated examples:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(<span class="dt">x =</span> y)]</code></pre></div>
<pre><code>#    id  t  x i.id
# 1:  1  1 11    1
# 2: NA NA 15    2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id, <span class="dt">x =</span> y)]</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  2 NA 15</code></pre>
<p>When merging on columns with different names, they must be written in <code>on=</code> like <code>x = y</code> where <code>x</code> is from the “left” table, and <code>y</code> from the “right” one. Because we are using <code>i</code> to lookup rows in <code>x</code>, the displayed column will have its name from <code>x</code> and its values from <code>i</code>.</p>
<p>A character vector also works in, e.g., <code>on=c(&quot;id&quot;, x = &quot;y&quot;)</code>, making it easier to merge programmatically.</p>
</div>
<div id="subset-lookup" class="section level3">
<h3><span class="header-section-number">3.5.2</span> Subset lookup</h3>
<p>For browsing dynamic data (that grows over time), it is convenient and quick to use joins:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[.(1L), on=.(id)]</code></pre></div>
<pre><code>#    id t  x
# 1:  1 1 11
# 2:  1 2 12</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or, as a function</span>
ra &lt;-<span class="st"> </span>function(my_id) a[.(my_id), on=.(id)] 
<span class="kw">ra</span>(2L)</code></pre></div>
<pre><code>#    id t  x
# 1:  2 1 13</code></pre>
<p>Note that the index <code>i</code> is a list here, not a data.table. The link between the two is close, since data.tables are just lists of columns (<a href="tables.html#dt-lapply">3.3.1</a>). Any list passed in <code>i</code> will be treated the same as the analogous data.table with appropriate column names.</p>
<p>Subset browsing becomes even easier when keys are set so that <code>on=</code> can be skipped (<a href="tables.html#keys-indices">3.5.8.1</a>).</p>
</div>
<div id="aggregating-in-a-join" class="section level3">
<h3><span class="header-section-number">3.5.3</span> Aggregating in a join</h3>
<p>Looking again at the first join above, suppose we want to use <code>b</code> to find rows in <code>a</code> and then add up <code>a$x</code>. We’ll do this by using <code>by=.EACHI</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id)]</code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  1 2 12 11
# 3:  2 1 13 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), <span class="kw">sum</span>(x), by=.EACHI]</code></pre></div>
<pre><code>#    id V1
# 1:  1 23
# 2:  2 13</code></pre>
<p>It is called “each <code>i</code>” since the syntax is <code>x[i, ...]</code> and we are computing per row of the index <code>i</code>. I prefer to write the <code>on=</code> before the <code>j</code> (unlike the core syntax of <code>DT[i,j,by]</code>) since the <code>on=</code> merging columns are closely related to the <code>i</code> index.</p>
<p>If we tried summing <code>b$y</code> here, we would not get <code>11+11</code> for <code>id</code> 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id)] <span class="co"># y shows up twice</span></code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  1 2 12 11
# 3:  2 1 13 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), .(<span class="kw">sum</span>(x), <span class="kw">sum</span>(y)), by=.EACHI] <span class="co"># we only get one y</span></code></pre></div>
<pre><code>#    id V1 V2
# 1:  1 23 11
# 2:  2 13 15</code></pre>
<p>This is because we are working by each row of <code>b</code>. For <code>id</code> 1 in <code>b</code>, <code>y</code> is a single value, <code>11</code>. So really there is no point in summing <code>y</code> or otherwise aggregating columns from <code>i</code> when using <code>by=.EACHI</code>.</p>

<div class="rmd-caution">
<strong>Beware <code>DT[i,on=,j,by=bycols]</code>.</strong> Just to repeat: only <code>by=.EACHI</code> works in a join. Typing other <code>by=</code> values there will cause <code>i</code>’s columns to become unavailable. This <a href="https://github.com/Rdatatable/data.table/issues/733">may eventually change</a>.
</div>
<p></p>
</div>
<div id="joins-update" class="section level3">
<h3><span class="header-section-number">3.5.4</span> Updating in a join</h3>
<p>Continuing from the last example, we are computing <code>sum(x)</code> per row of <code>b</code>, so maybe we want to save the result as a column in <code>b</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b[, sumx :<span class="er">=</span><span class="st"> </span>
<span class="st">    </span>a[b, on=.(id), <span class="kw">sum</span>(x), by=.EACHI]$V1
]
<span class="co"># or</span>
b[, sumx :<span class="er">=</span><span class="st"> </span>
<span class="st">    </span>a[.SD, on=.(id), <span class="kw">sum</span>(x), by=.EACHI]$V1
]</code></pre></div>
<pre><code>#    id  y sumx
# 1:  1 11   23
# 2:  2 15   13</code></pre>

<div class="rmd-caution">
<strong>Default names for <code>j</code> computations.</strong> When the task in <code>j</code> evaluates to an unnamed list, default names <code>V1, V2, ...</code> are assigned. We can use these to extract a single computed column with <code>$V1</code>, <code>$V2</code>, etc. Since we can only extract one column at a time, we usually only create and extract a single column, auto-named <code>V1</code>.
</div>
<p></p>
<p>On the other hand, we may want to take values from <code>b</code> and assign them to the larger table <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), y :<span class="er">=</span><span class="st"> </span>i.y ]</code></pre></div>
<pre><code>#    id  t  x  y
# 1:  1  1 11 11
# 2:  1  2 12 11
# 3:  2  1 13 15
# 4:  3  2 14 NA
# 5: NA NA 15 NA</code></pre>
<p>This sort of operation is very common when doing analysis with well-organized relational data, and will come up again in <a href="tables.html#structuring-data">3.8</a>. It is essentially the same as a SQL UPDATE JOIN. It might also be called a “merge assign” (though I seem to be the only one using that term).</p>
<p>The <code>i.*</code> prefix in <code>i.y</code> indicates that we are taking the column from the <code>i</code> table in <code>x[i]</code>. We can similarly use an <code>x.*</code> prefix for columns from <code>x</code>. This helps to disambiguate if the same column names appear in both tables, and is particularly helpful with non-equi joins (<a href="tables.html#joins-nonequi">3.5.7</a>). I recommend always using <code>i.*</code> prefixes when copying columns in an update join.</p>

<div class="rmd-caution">
<strong>Beware multiple matches in an update join.</strong> When there are multiple matches (<a href="tables.html#join-multimatch">3.5.6.1</a>), an update join will apparently only use the last one. <a href="https://github.com/Rdatatable/data.table/issues/2022">Unfortunately</a>, this is done silently. Try <code>b[a, on=.(id), x := i.x, verbose = TRUE ][]</code>. With <code>verbose</code> on, we see a helpful message about assignment “to 3 row subset of 2 rows.”
</div>
<p></p>
</div>
<div id="self-join-to-fill-in-missing-levels" class="section level3">
<h3><span class="header-section-number">3.5.5</span> Self join to fill in missing levels</h3>
<p>Consider the <code>a</code> data set from above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
a =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(1L, 1L, 2L, 3L, <span class="ot">NA_integer_</span>), <span class="dt">t =</span> <span class="kw">c</span>(1L, 2L, 1L, 2L, <span class="ot">NA_integer_</span>), <span class="dt">x =</span> <span class="dv">11</span>:<span class="dv">15</span>)</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  1  2 12
# 3:  2  1 13
# 4:  3  2 14
# 5: NA NA 15</code></pre>
<p>Now we want to “complete” the data set so that every <code>id</code> has a row for every time <code>t</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[<span class="kw">CJ</span>(<span class="dt">id =</span> id, <span class="dt">t =</span> t, <span class="dt">unique=</span><span class="ot">TRUE</span>), on=.(id, t)]</code></pre></div>
<pre><code>#     id  t  x
#  1: NA NA 15
#  2: NA  1 NA
#  3: NA  2 NA
#  4:  1 NA NA
#  5:  1  1 11
#  6:  1  2 12
#  7:  2 NA NA
#  8:  2  1 13
#  9:  2  2 NA
# 10:  3 NA NA
# 11:  3  1 NA
# 12:  3  2 14</code></pre>
<p>This is called a self join because we are using the table’s own columns in <code>i</code> of <code>x[i, on=]</code>. The <code>CJ</code> function is a helper that takes all combinations of vectors, alternately called the Cartesian product or a “cross join.” See <a href="work.html#combos">4.2</a> for details. By applying <code>unique=TRUE</code>, we treat each vector <em>as a set</em> in the mathematical sense, only considering distinct values.</p>
<p>Notice that missing values (<code>NA</code>) in <code>i</code> are treated in the same way as other values.</p>
</div>
<div id="join-matches" class="section level3">
<h3><span class="header-section-number">3.5.6</span> Handling matches</h3>
<p>For this section, we’ll reset the tables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
a =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(1L, 1L, 2L, 3L, <span class="ot">NA_integer_</span>), <span class="dt">t =</span> <span class="kw">c</span>(1L, 2L, 1L, 2L, <span class="ot">NA_integer_</span>), <span class="dt">x =</span> <span class="dv">11</span>:<span class="dv">15</span>)</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  1  2 12
# 3:  2  1 13
# 4:  3  2 14
# 5: NA NA 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">y =</span> <span class="kw">c</span>(11L, 15L))</code></pre></div>
<pre><code>#    id  y
# 1:  1 11
# 2:  2 15</code></pre>
<div id="join-multimatch" class="section level4">
<h4><span class="header-section-number">3.5.6.1</span> Handling multiply-matched rows</h4>
<p>In <code>a[b, on=.(id)]</code>, we are indexing by rows of <code>b</code> and so get matches for every row of <code>b</code>. By default, we get <em>all</em> matches in <code>a</code>, but this can be tweaked:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), mult=<span class="st">&quot;first&quot;</span>]</code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  2 1 13 15</code></pre>
<p>Now each row of <code>b</code> only returns the first matching row (from the top) in <code>a</code>. Similarly, we could select <code>mult=&quot;last&quot;</code>.</p>
</div>
<div id="join-unmatched" class="section level4">
<h4><span class="header-section-number">3.5.6.2</span> Handling unmatched rows</h4>
<p>Flipping it around, if we use <code>a</code> to index <code>b</code>, we have some index rows from <code>a</code> that don’t have any matches in <code>b</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b[a, on=.(id)]</code></pre></div>
<pre><code>#    id  y  t  x
# 1:  1 11  1 11
# 2:  1 11  2 12
# 3:  2 15  1 13
# 4:  3 NA  2 14
# 5: NA NA NA 15</code></pre>
<p>These unmatched rows still show up in the result, which is usually nice. However, this behavior can also be tweaked:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b[a, on=.(id), nomatch=<span class="dv">0</span>]</code></pre></div>
<pre><code>#    id  y t  x
# 1:  1 11 1 11
# 2:  1 11 2 12
# 3:  2 15 1 13</code></pre>
<p>Dropping unmatched elements of <code>i</code> is similar to filtering <code>_m == 3</code> in Stata.</p>

<div class="rmd-caution">
<strong>Diagnostics for merges.</strong> In Stata, joins report on how well they went – did everything match? how many didn’t match? The analogous question for an <code>x[i]</code> join is – for each row of <code>i</code>, how many matches did we find in <code>x</code>? To see the answer, use <code>b[a, on=.(id), .N, by=.EACHI]</code>.
</div>
 
<div class="rmd-details">
<p><strong>Comparison with Stata.</strong> Because <code>x[i]</code> uses <code>i</code> to look up rows in <code>x</code>, we are never looking ar rows that correspond to Stata’s <code>_m == 1</code> – that belong to <code>x</code> but are not matched by <code>i</code>.</p>
There is another way of merging, <code>merge(b, a)</code>, that allows for <code>all.x</code> and <code>all.y</code>, resembling Stata’s options, but I have never found any reason to use it.
</div>
<p></p>
</div>
<div id="im-rolling" class="section level4">
<h4><span class="header-section-number">3.5.6.3</span> Handling imperfect matches with rolling joins</h4>
<p>Sometimes we want unmatched rows paired with the closest match occurring earlier or later in the table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># target x</span>
myxDT =<span class="st"> </span><span class="kw">list</span>(<span class="dt">myx =</span> <span class="kw">c</span>(5L, 10L, 15L, 20L))

<span class="co"># exact match (equi-join)</span>
a[myxDT, on=.(<span class="dt">x =</span> myx), .(i.myx, x.x)]</code></pre></div>
<pre><code>#    i.myx x.x
# 1:     5  NA
# 2:    10  NA
# 3:    15  15
# 4:    20  NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># nearest match</span>
a[myxDT, on=.(<span class="dt">x =</span> myx), roll=<span class="st">&quot;nearest&quot;</span>, .(i.myx, x.x)]</code></pre></div>
<pre><code>#    i.myx x.x
# 1:     5  11
# 2:    10  11
# 3:    15  15
# 4:    20  15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># upward match within 3</span>
a[myxDT, on=.(<span class="dt">x =</span> myx), roll=-<span class="dv">3</span>, .(i.myx, x.x)]</code></pre></div>
<pre><code>#    i.myx x.x
# 1:     5  NA
# 2:    10  11
# 3:    15  15
# 4:    20  NA</code></pre>
<p>Recall from <a href="tables.html#joins-update">3.5.4</a> that the <code>i.*</code> and <code>x.*</code> prefixes refer to where columns come from in <code>x[i]</code>.</p>
<p>When joining on multiple columns, the roll is taken on the last column listed in <code>on=</code>.</p>
<p>The value of <code>roll=</code> refers to how much higher or lower the value of <code>x</code> can be and still qualify as a match. We add (up to) <code>roll</code> to the target row if necessary to find a match. So <code>roll = -3</code> means we would accept a <code>x</code> as far away as <code>x - 3 = myx</code>.</p>
</div>
</div>
<div id="joins-nonequi" class="section level3">
<h3><span class="header-section-number">3.5.7</span> Non-equi joins</h3>
<p>It is sometimes useful to match on a range of values. To do this, we explicitly name all columns in <code>i</code> and define inequalities in <code>on=</code>. Suppose we want to see, for every time <code>t</code> in 1..5, how many individuals were seen in the preceding three days:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">x_dn =</span> 10L, <span class="dt">x_up =</span> 13L)</code></pre></div>
<pre><code>#    id x_dn x_up
# 1:  1   10   13
# 2:  2   10   13
# 3:  3   10   13</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[mDT, on=.(id, x &gt;=<span class="st"> </span>x_dn, x &lt;=<span class="st"> </span>x_up), .(id, i.x_dn, i.x_up, x.x)]</code></pre></div>
<pre><code>#    id i.x_dn i.x_up x.x
# 1:  1     10     13  11
# 2:  1     10     13  12
# 3:  2     10     13  13
# 4:  3     10     13  NA</code></pre>
<p>So we are defining a range <code>x_dn</code> to <code>x_up</code> for each <code>id</code> and finding all matches of <code>x</code> within the range.</p>
<p>These could alternately be called “interval joins.” For more on interval joins and subsets, see <code>?inrange</code>, <code>?foverlaps</code> and the <a href="http://www.bioconductor.org/packages/IRanges/">IRanges package</a> that inspired these data.table tools.</p>
</div>
<div id="shortcuts-and-tricks" class="section level3">
<h3><span class="header-section-number">3.5.8</span> Shortcuts and tricks</h3>
<p>When joining on a single character or factor column, the <code>.()</code> in <code>i</code> can be skipped:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dt">u =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">v =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>))
DT[<span class="st">&quot;A&quot;</span>, on=.(id)]</code></pre></div>
<pre><code>#    id u v
# 1:  A 0 1
# 2:  A 1 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## # instead of
## DT[.(&quot;A&quot;), on=.(id)]</code></pre></div>
<div id="keys-indices" class="section level4">
<h4><span class="header-section-number">3.5.8.1</span> Setting keys and indices</h4>
<p>If a table is always joined on the same column(s), these can be set as its “key.” Setting the key of <code>x</code> sorts the table and allows for skipping <code>on=</code> during <code>x[i,on=]</code> joins. It also can have some performance benefits. See <code>?setkey</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(DT, id)
DT[<span class="st">&quot;A&quot;</span>]</code></pre></div>
<pre><code>#    id u v
# 1:  A 0 1
# 2:  A 1 4</code></pre>
<p>This can be dangerous, however, since even if <code>i</code> has names, they are ignored:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(DT, u, v)
DT[.(<span class="dt">v =</span> <span class="dv">7</span>, <span class="dt">u =</span> <span class="dv">2</span>)]</code></pre></div>
<pre><code>#    id u v
# 1: NA 7 2</code></pre>
<p>No match is found here since <code>i=.(v = 7, u = 2)</code> is mapped to the key <code>.(u,v)</code> by position and not by name.</p>
<p>It can also be dangerous in another way. If the key consists of all columns, we might not notice when joining and finding no match:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(DT, id, u, v)
DT[.(<span class="st">&quot;B&quot;</span>, <span class="dv">1</span>, <span class="dv">1</span>)]</code></pre></div>
<pre><code>#    id u v
# 1:  B 1 1</code></pre>
<p>It looks like we found one match, but in fact we found zero. To avoid this, a custom manual browsing function can be written:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r0 &lt;-<span class="st"> </span>function(..., <span class="dt">d =</span> DT) {
  x =<span class="st"> </span>d[.(...), nomatch=<span class="dv">0</span>]
  <span class="kw">print</span>(<span class="dt">x =</span> x, <span class="dt">nrows=</span><span class="ot">Inf</span>, <span class="dt">row.names=</span><span class="ot">FALSE</span>)
  <span class="kw">invisible</span>(x)
}

<span class="kw">r0</span>(<span class="st">&quot;B&quot;</span>, <span class="dv">1</span>, <span class="dv">1</span>)</code></pre></div>
<pre><code># Empty data.table (0 rows) of 3 cols: id,u,v</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">r0</span>(<span class="st">&quot;B&quot;</span>, <span class="dv">2</span>, <span class="dv">7</span>)</code></pre></div>
<pre><code>#  id u v
#   B 2 7</code></pre>
<p>Most of the performance benefits of a key can also be achieved with an “index.” Unlike a key, which sorts the table, an index simply notes the order of the table with respect to some columns. A table can have many indices, but only one key:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setindex</span>(DT, id, u)
<span class="kw">setindex</span>(DT, id, v)
## key(DT)
## indices(DT, vectors=TRUE)
## str(DT)</code></pre></div>
<p>The performance benefits show up in most joins and some subsetting operations, too. Turn on <code>verbose</code> data.table messages to see when it is and is not kicking in. Also see <code>vignette(&quot;datatable-secondary-indices-and-auto-indexing&quot;)</code>; and regarding whether setting a key is important (as some old tutorials might say), see the package developer’s <a href="https://github.com/Rdatatable/data.table/issues/1232#issuecomment-131190268">post</a>.</p>
<p>Keys and indices are destroyed whenever any of their columns are edited in a way that won’t obviously preserve order.</p>

<div class="rmd-details">
<strong>Attribute verification.</strong> Keys and indices are simply stored as attributes and may be invalid. For example, with <code>DT = data.table(id = 2:1, v = 2:1); setattr(DT, &quot;sorted&quot;, &quot;id&quot;)</code>, we’ve told the table that it is sorted by <code>id</code> even though it isn’t. Some functions may check the validity of the key, but others won’t, like <code>DT[.(1L)]</code>.
</div>
<p></p>
</div>
<div id="anti-joins" class="section level4">
<h4><span class="header-section-number">3.5.8.2</span> Anti joins</h4>
<p>We also have the option of selecting <em>unmatched</em> rows with <code>!</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[!b, on=.(id)]</code></pre></div>
<pre><code>#    id  t  x
# 1:  3  2 14
# 2: NA NA 15</code></pre>
<p>This “not join” or “anti join” returns all rows of <code>a</code> that are not matched by rows in <code>b</code>.</p>
</div>
</div>
</div>
<div id="input-output" class="section level2">
<h2><span class="header-section-number">3.6</span> Input and output</h2>
<p>This section covers reading tables from disk; basic cleaning of column formats; and writing to disk.</p>
<div id="file-paths" class="section level3">
<h3><span class="header-section-number">3.6.1</span> File paths</h3>
<p>Don’t provide paths with backslashes, like <code>&quot;C:\data\input.csv&quot;</code>, since <code>\</code> is special character in R. My workaround is to use forward slashes or construct the path using <code>file.path</code>.</p>
<ul>
<li>For a list of files and folders, use <code>dir</code> or <code>list.files</code>.</li>
<li>For relative paths, <code>&quot;.&quot;</code> is the current folder; <code>&quot;..&quot;</code> navigates one level up; and <code>normalizePath</code> converts to an absolute path.</li>
<li>For the current path, use <code>getwd</code>; and to alter it, <code>setwd(new_path)</code>.</li>
<li>To extract parts of a path, use, e.g., <code>file_ext</code> from the tools package (included in the base R installation).</li>
</ul>
<p>For functions to manipulate files, see <code>?files</code> and <code>?dir.create</code>; and for file attributes, <code>?file.info</code>.</p>
</div>
<div id="fread" class="section level3">
<h3><span class="header-section-number">3.6.2</span> <code>fread</code> to read delimited files</h3>
<p>To read tables from CSVs or other delimited formats, <code>fread</code> is quite fast and reliable:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;file.csv&quot;</span>)</code></pre></div>
<p>See <code>?fread</code> and <a href="https://github.com/Rdatatable/data.table/wiki/Convenience-features-of-fread">the wiki</a> for a discussion of features. I usually find that <code>fread</code> just works without any need for tweaks. However, it currently doesn’t recognize date or time formats, which need to be handled after reading (<a href="tables.html#dates-times">3.6.4</a>).</p>
</div>
<div id="rbindlist-read" class="section level3">
<h3><span class="header-section-number">3.6.3</span> <code>rbindlist</code> to combine tables</h3>
<p>To read and combine several tables with the same columns, <code>rbindlist</code> is the right tool. The short approach is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rbindlist</span>(<span class="kw">lapply</span>(<span class="kw">list.files</span>(<span class="dt">patt=</span><span class="st">&quot;csv$&quot;</span>), fread), <span class="dt">id=</span><span class="ot">TRUE</span>)
<span class="co"># or...</span>
<span class="kw">list.files</span>(<span class="dt">patt=</span><span class="st">&quot;csv$&quot;</span>) %&gt;%<span class="st"> </span><span class="kw">lapply</span>(fread) %&gt;%<span class="st"> </span><span class="kw">rbindlist</span>(<span class="dt">id=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>The rest of this section covers the longer approach I recommend, using a table with one row per file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>

<span class="co"># example data</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
for (i in <span class="dv">1</span>:<span class="dv">3</span>) 
  <span class="kw">fwrite</span>(<span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">v =</span> <span class="kw">sample</span>(letters, <span class="dv">2</span>)), <span class="dt">file =</span> <span class="kw">sprintf</span>(<span class="st">&quot;file201%s.csv&quot;</span>, i))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># First, identify the files wanted:</span>
fileDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">fn =</span> <span class="kw">list.files</span>(<span class="dt">pattern=</span><span class="st">&quot;csv$&quot;</span>))

<span class="co"># Next, optionally parse the names for metadata using regex:</span>
fileDT[, year :<span class="er">=</span><span class="st"> </span><span class="kw">type.convert</span>(<span class="kw">sub</span>(<span class="st">&quot;.*([0-9]{4}).*&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1&quot;</span>, fn))]

<span class="co"># Finally construct a string file-ID column:</span>
fileDT[, id :<span class="er">=</span><span class="st"> </span><span class="kw">as.character</span>(.I)][]</code></pre></div>
<pre><code>#              fn year id
# 1: file2011.csv 2011  1
# 2: file2012.csv 2012  2
# 3: file2013.csv 2013  3</code></pre>
<p>From here, read in the files as a new column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fileDT[, contents :<span class="er">=</span><span class="st"> </span>.(<span class="kw">lapply</span>(fn, fread))][]</code></pre></div>
<pre><code>#              fn year id     contents
# 1: file2011.csv 2011  1 &lt;data.table&gt;
# 2: file2012.csv 2012  2 &lt;data.table&gt;
# 3: file2013.csv 2013  3 &lt;data.table&gt;</code></pre>
<p>Then, combine them for the final table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span>fileDT[, <span class="kw">rbindlist</span>(<span class="kw">setNames</span>(contents, id), <span class="dt">idcol=</span><span class="st">&quot;file_id&quot;</span>)]

<span class="co"># Perhaps add in metadata using an update join</span>
DT[fileDT, on=.(<span class="dt">file_id =</span> id), year :<span class="er">=</span><span class="st"> </span>i.year ][]</code></pre></div>
<pre><code>#    file_id id v year
# 1:       1  1 g 2011
# 2:       1  2 j 2011
# 3:       2  1 o 2012
# 4:       2  2 w 2012
# 5:       3  1 f 2013
# 6:       3  2 w 2013</code></pre>
<p>Results can be debugged by investigating individual files like <code>fileDT[year == 2012, contents[[1]]]</code>. The <code>setNames</code> function (<a href="basics.html#names">2.1.5</a>) is needed here since <code>rbindlist</code> uses names to populate the id column.</p>
</div>
<div id="dates-times" class="section level3">
<h3><span class="header-section-number">3.6.4</span> Date and time columns</h3>
<p>Currently, <code>fread</code> does not recognize or translate time or date columns to native R formats.</p>
<p>I recommend a couple packages, anytime and nanotime, for use when needed (more on which below). They have minimal dependencies and are maintained with an eye towards continued compatibility with the data.table package.</p>
<div id="idatetime" class="section level4">
<h4><span class="header-section-number">3.6.4.1</span> Date and time of day, separately</h4>
<p>I usually handle this using the formats provided with data.table, <code>IDate</code> and <code>ITime</code>, for date and time of day:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">d =</span> <span class="kw">c</span>(<span class="st">&quot;2017/01/21&quot;</span>, <span class="st">&quot;2017/01/22&quot;</span>), <span class="dt">t =</span> <span class="kw">c</span>(<span class="st">&quot;5:50&quot;</span>, <span class="st">&quot;13:50&quot;</span>))</code></pre></div>
<pre><code>#    id          d     t
# 1:  1 2017/01/21  5:50
# 2:  2 2017/01/22 13:50</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  3 variables:
#  $ id: int  1 2
#  $ d : chr  &quot;2017/01/21&quot; &quot;2017/01/22&quot;
#  $ t : chr  &quot;5:50&quot; &quot;13:50&quot;
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(
  <span class="dt">d =</span> <span class="kw">as.IDate</span>(d),
  <span class="dt">t =</span> <span class="kw">as.ITime</span>(t)
)][]</code></pre></div>
<pre><code>#    id          d        t
# 1:  1 2017-01-21 05:50:00
# 2:  2 2017-01-22 13:50:00</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  3 variables:
#  $ id: int  1 2
#  $ d : IDate, format: &quot;2017-01-21&quot; &quot;2017-01-22&quot;
#  $ t :Class &#39;ITime&#39;  int [1:2] 21000 49800
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>In the <code>str</code> output, we can see that ITime is stored as an integer, and the same is true of IDate. This is more efficient than a floating-point class in terms of storage and many table operations.</p>
<p>In this example, the <code>as.*</code> functions immediately recognize how to interpret the strings given. In many cases, however, we need to pass a format parameter, like <code>as.IDate(&quot;01/13/2013&quot;, &quot;%m/%d/%Y&quot;)</code>. See <code>?strptime</code> and <code>?as.Date</code> for documentation on how to do this. Because it’s hard to get the format right the first time, I usually test a format out like…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[1L, <span class="kw">as.IDate</span>(d, <span class="st">&quot;%Y%M%D&quot;</span>)] </code></pre></div>
<p>This is similar to the <code>dryrun</code> option in Nick Cox’s numdate package for Stata.</p>
<p>Parsing dates and times by tweaking format strings can be mind-numbing, so it’s worth considering loading <a href="http://dirk.eddelbuettel.com/code/anytime.html">the anytime package</a>, which will automatically recognize many more formats than <code>as.IDate</code> and <code>as.ITime</code> normally will.</p>
</div>
<div id="datetimes" class="section level4">
<h4><span class="header-section-number">3.6.4.2</span> Datetimes</h4>
<p>Data.table also can parse a datetime string (well, a factor) into separate IDate and ITime columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">dt =</span> <span class="st">&quot;2017-01-01 01:11&quot;</span>)
DT[, <span class="kw">c</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;t&quot;</span>) :<span class="er">=</span><span class="st"> </span><span class="kw">IDateTime</span>(<span class="kw">as.factor</span>(dt))][]</code></pre></div>
<pre><code>#                  dt          d        t
# 1: 2017-01-01 01:11 2017-01-01 01:11:00</code></pre>
<p>However, it does not include a combined datetime class, which would be useful if we want to measure time differences across days.</p>
<p>For a combined datetime class, we have to use POSIXct. This brings with it a couple of annoyances. First, it uses floating-point measurement, so grouping on it with <code>by=</code> is not a good idea and some table operations will be slower. Second, in keeping with POSIX rules, it has an irritating time zone attribute that always demands careful watching. Nonetheless, it is the standard option for a datetime format currently. (There is also a POSIXlt format, but data.table discourages it, since it does not build on atomic vectors.)</p>
<p>If datetimes are central to the analysis, it might be worth loading <a href="https://CRAN.R-project.org/package=chron">the chron package</a>, which offers a datetime class without the time-zone annoyances of POSIXct. It is “suggested” by the data.table package (in CRAN lingo), so probably reliably compatible.</p>
</div>
<div id="sub-second-measures" class="section level4">
<h4><span class="header-section-number">3.6.4.3</span> Sub-second measures</h4>
<p>The ITime class is an integer measure of seconds since midnight. POSIXct will be necessary if finer-measured seconds are needed (e.g., from online activity data). If even finer measurement is needed (e.g., for network latency measurement), <a href="http://dirk.eddelbuettel.com/code/nanotime.html">the <code>nanotime</code> package</a> is available.</p>
</div>
<div id="computations" class="section level4">
<h4><span class="header-section-number">3.6.4.4</span> Computations</h4>
<p>There are many convenient extractor functions, <code>month</code>, <code>wday</code> and so on, listed in <code>?IDateTime</code> and <code>?weekdays</code>.</p>
<p>The <code>max</code> or <code>min</code> of a vector of dates can be taken (just as it can be for numbers, characters and ordered factors); and inequalities also work.</p>
<p>Arithmetic on IDates with <code>+</code> and <code>-</code> reads <code>1L</code> as one day; and on ITimes, as one second.</p>
<p>Time differences between dates or times can be taken using <code>difftime</code>, which allows for the specification of units of measure for the output.</p>
</div>
<div id="erroneous-na" class="section level4">
<h4><span class="header-section-number">3.6.4.5</span> Erroneously coded <code>NA</code>s</h4>
<p>While doing arithmetic with dates and times is convenient, it has some risks. These are essentially numeric and integer vectors with special display formats. When the display format breaks down, we see <code>NA</code> even if the underlying numeric or integer value is not missing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">d =</span> <span class="kw">as.IDate</span>(<span class="st">&quot;2017-01-01&quot;</span>) +<span class="st"> </span><span class="dv">0</span>:<span class="dv">10</span>)

<span class="co"># find min date greater than today</span>
d_next =<span class="st"> </span>tDT[ d &gt;<span class="st"> </span><span class="kw">as.IDate</span>(<span class="kw">Sys.Date</span>()), <span class="kw">min</span>(d) ]</code></pre></div>
<pre><code># Warning in min.default(structure(integer(0), class = c(&quot;IDate&quot;, &quot;Date&quot;)), : no non-missing
# arguments to min; returning Inf</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d_next</code></pre></div>
<pre><code># [1] NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># check if d_next is past the year 2099</span>
d_next &gt;<span class="st"> </span><span class="kw">as.IDate</span>(<span class="st">&quot;2099-01-01&quot;</span>)</code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p><code>NA &gt; x</code> should always evaluate to <code>NA</code> (<a href="basics.html#na">2.1.6</a>), but here we see that it does not. To see the reason, we need to extract the core data by coercion or use <code>dput</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># str is no help</span>
<span class="kw">str</span>(d_next)</code></pre></div>
<pre><code>#  IDate[1:1], format: NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># as.vector strips class</span>
<span class="kw">as.vector</span>(d_next)</code></pre></div>
<pre><code># [1] Inf</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or unclass</span>
<span class="kw">unclass</span>(d_next)</code></pre></div>
<pre><code># [1] Inf</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or we can inspect with dput</span>
<span class="kw">dput</span>(d_next)</code></pre></div>
<pre><code># structure(Inf, class = c(&quot;IDate&quot;, &quot;Date&quot;))</code></pre>
<p>This is an issue to watch out for with any fancy vector classes. To get around it in this case, we can sort and pick the first match (which is NA since there are no valid matches):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d_next2 =<span class="st"> </span>tDT[ d &gt;<span class="st"> </span><span class="kw">as.IDate</span>(<span class="kw">Sys.Date</span>()) ][<span class="kw">order</span>(-d), d[1L] ]
<span class="kw">dput</span>(d_next2)</code></pre></div>
<pre><code># structure(NA_integer_, class = c(&quot;IDate&quot;, &quot;Date&quot;))</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or a rolling join</span>
d_next3 =<span class="st"> </span>tDT[<span class="kw">order</span>(-d)][.(<span class="kw">as.IDate</span>(<span class="kw">Sys.Date</span>())), on =.(d), roll=-<span class="ot">Inf</span>, x.d]
<span class="kw">dput</span>(d_next3)</code></pre></div>
<pre><code># structure(NA_integer_, class = c(&quot;IDate&quot;, &quot;Date&quot;))</code></pre>
<p>The second approach is a rolling join (<a href="tables.html#im-rolling">3.5.6.3</a>), taking advantage of the <code>nomatch=NA</code> default in joins.</p>
</div>
</div>
<div id="char-input" class="section level3">
<h3><span class="header-section-number">3.6.5</span> Character columns</h3>
<p>With character columns that combine multiple variables, there are a few options.</p>
<ul>
<li><p>If the “split” of the variable is fixed-width, <code>substr</code> or <code>substring</code> works.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;A001ABC&quot;</span>, <span class="st">&quot;B001DEF&quot;</span>))
DT[, <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(<span class="dt">x_id =</span> <span class="kw">substring</span>(x, <span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">x_num =</span> <span class="kw">substring</span>(x, <span class="dv">2</span>, <span class="dv">4</span>), <span class="dt">x_val =</span> <span class="kw">substring</span>(x, <span class="dv">5</span>, <span class="dv">7</span>))][]</code></pre></div>
<pre><code>#          x x_id x_num x_val
# 1: A001ABC    A   001   ABC
# 2: B001DEF    B   001   DEF</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  4 variables:
#  $ x    : chr  &quot;A001ABC&quot; &quot;B001DEF&quot;
#  $ x_id : chr  &quot;A&quot; &quot;B&quot;
#  $ x_num: chr  &quot;001&quot; &quot;001&quot;
#  $ x_val: chr  &quot;ABC&quot; &quot;DEF&quot;
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre></li>
<li><p>If the split follows a pattern that can be characterized using regular expressions (<a href="work.html#strings">4.8</a>), <code>tstrsplit</code> can make the split and automatically convert to appropriate column types just as <code>fread</code> does:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;A_1_22.2&quot;</span>, <span class="st">&quot;B_33_44.4&quot;</span>))
DT[, <span class="kw">c</span>(<span class="st">&quot;x_id&quot;</span>, <span class="st">&quot;x_int&quot;</span>, <span class="st">&quot;x_float&quot;</span>) :<span class="er">=</span><span class="st"> </span><span class="kw">tstrsplit</span>(x, <span class="st">&quot;_&quot;</span>, <span class="dt">type.convert =</span> <span class="ot">TRUE</span>)][]</code></pre></div>
<pre><code>#            x x_id x_int x_float
# 1:  A_1_22.2    A     1    22.2
# 2: B_33_44.4    B    33    44.4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  4 variables:
#  $ x      : chr  &quot;A_1_22.2&quot; &quot;B_33_44.4&quot;
#  $ x_id   : chr  &quot;A&quot; &quot;B&quot;
#  $ x_int  : int  1 33
#  $ x_float: num  22.2 44.4
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre></li>
</ul>
<p>With US states, built-ins (<a href="basics.html#built-ins">2.7</a>) and an update join (<a href="tables.html#joins-update">3.5.4</a>) can be used to convert between abbreviated and long forms:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">state_code =</span> <span class="kw">c</span>(<span class="st">&quot;MN&quot;</span>, <span class="st">&quot;KS&quot;</span>))
DT[.(<span class="dt">state_code =</span> state.abb, <span class="dt">state_name =</span> state.name), on=.(state_code), 
   state_name :<span class="er">=</span><span class="st"> </span>i.state_name 
]</code></pre></div>
<pre><code>#    state_code state_name
# 1:         MN  Minnesota
# 2:         KS     Kansas</code></pre>
<p>In the case of messier strings, the convenience functions in the stringi package may be helpful, along with a read of <code>?regex</code> and the string section in the next chapter (<a href="work.html#strings">4.8</a>).</p>
</div>
<div id="dt-recode" class="section level3">
<h3><span class="header-section-number">3.6.6</span> Categorical columns</h3>
<p><code>fread</code> will read string columns in as character by default, and this is usually the way to go.</p>
<p>When “recoding” values in a character column, I suggest being explicit by storing the mapping in its own table and doing an update join (<a href="tables.html#joins-update">3.5.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">v =</span> <span class="kw">c</span>(<span class="st">&quot;Yes&quot;</span>, <span class="st">&quot;argle&quot;</span>, <span class="st">&quot;bargle&quot;</span>, <span class="st">&quot;No&quot;</span>, <span class="st">&quot;Yep&quot;</span>, <span class="st">&quot;garble&quot;</span>, <span class="st">&quot;Nope&quot;</span>, <span class="st">&quot;blargh&quot;</span>))
<span class="co"># desired mapping</span>
v_translateDT =<span class="st"> </span><span class="kw">rbind</span>(
  <span class="kw">data.table</span>(<span class="dt">v_old =</span> <span class="kw">c</span>(<span class="st">&quot;Yes&quot;</span>, <span class="st">&quot;Yep&quot;</span>), <span class="dt">v_new =</span> <span class="ot">TRUE</span>),
  <span class="kw">data.table</span>(<span class="dt">v_old =</span> <span class="kw">c</span>(<span class="st">&quot;No&quot;</span>, <span class="st">&quot;Nope&quot;</span>), <span class="dt">v_new =</span> <span class="ot">FALSE</span>)
)
<span class="co"># update join</span>
DT[v_translateDT, on=.(<span class="dt">v =</span> v_old), vt :<span class="er">=</span><span class="st"> </span>i.v_new ]</code></pre></div>
<p>Here, we are mapping to a logical column. Of course, the same thing could be done with a factor, an ordered factor or a string.</p>
</div>
<div id="list-columns" class="section level3">
<h3><span class="header-section-number">3.6.7</span> List columns</h3>
<p>Data.table supports columns of class <code>list</code>. A “list column” is a list with a length equal to the number of rows of the table. Each element of the list (that is, each row) can hold anything, just like a normal list. We saw an example of this in <a href="tables.html#rbindlist-read">3.6.3</a>.</p>
<p>List columns are rarely a good fit with tabular data for a few reasons. First, they make the data structure significantly harder to understand. Second, grouping, sorting or merging on them is not supported and probably never will be. Third, they do not play nice with time series operators like <code>shift</code> (<a href="work.html#lag">4.4.1</a>).</p>
<p>They are good for many things, but should be avoided if possible while cleaning the primary data. Nonetheless, <code>fread</code> does support reading list columns in.</p>
</div>
<div id="fwrite" class="section level3">
<h3><span class="header-section-number">3.6.8</span> <code>fwrite</code> to write delimited files</h3>
<p>To write a CSV or other delimited-table format, <code>fwrite</code> is usually the best option.</p>
<p>It is fast and includes nice features for printing dates and times, like the <code>squash</code> option that will print dates like <code>20171020</code>. For other tools for printing exotic columns out as strings see <a href="work.html#strings">4.8</a>.</p>
</div>
<div id="dt-saveload" class="section level3">
<h3><span class="header-section-number">3.6.9</span> Saving and loading R objects</h3>
<p>To save a table for later use in R, there are native formats, RData and RDS. In contrast with delimited files like CSVs, these files are small; are quick to save and load; and will allow the later user to skip tedious and error-prone data processing tasks.</p>
<p>Another consideration is whether the data storage is long-term or short term. If the objects are important and need to be accessible in 10-20 years, it would naturally be safer to store them in flat delimited file (assuming a tabular format makes sense for them). On the other hand, R’s storage formats will always be accessible by opening a suitable old version of R; and <a href="http://r.789695.n4.nabble.com/RData-File-Specification-td917010.html">R’s formats are open and (implicitly) documented</a> and so should presumably be readable with a little work.</p>
<p>One thing to watch out for when loading data.tables from disk is broken “self” pointers, leading to an error about “Invalid .internal.selfref”. This can be fixed by using <code>setDT</code> or <code>alloc.col</code> on all loaded tables, as explained in <code>vignette(&quot;datatable-faq&quot;)</code> under “Reading <code>data.table</code> from RDS or RData file”. Generally, I don’t bother with this safety precaution and haven’t run into problems yet, so I’m not sure how critical it is.</p>
<div id="collections-of-objects" class="section level4">
<h4><span class="header-section-number">3.6.9.1</span> Collections of objects</h4>
<p>The <code>.RData</code> format allows saving and loading multiple objects. When loading, the objects are dropped into the main workspace by default. To avoid the namespace conflicts this invites, I usually load to a new environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>
n   =<span class="st"> </span><span class="dv">10</span>
L   =<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
dat =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">v =</span> <span class="dv">3</span>)
<span class="kw">save</span>(n, L, dat, <span class="dt">file =</span> <span class="st">&quot;stuff.rdata&quot;</span>)

<span class="co"># and later, in another script</span>
<span class="kw">rm</span>(<span class="dt">list =</span> <span class="kw">ls</span>()) <span class="co"># clear workspace</span>
n   =<span class="st"> </span><span class="dv">20</span>          <span class="co"># create a different n</span>
<span class="kw">load</span>(<span class="st">&quot;stuff.rdata&quot;</span>, <span class="dt">env =</span> e_stuff &lt;-<span class="st"> </span><span class="kw">new.env</span>())</code></pre></div>
<p>Now, <code>n</code> is still 20, while the loaded value of <code>n = 10</code> can be accessed like <code>e_stuff$n</code>. The <code>$</code> and <code>[[</code> extractors for lists (<a href="basics.html#extract-list">2.1.8</a>) also work on environments, as does <code>names(e_stuff)</code>.</p>
<p>One nice feature of the R console is that <code>.rdata</code> files can be dragged and dropped into it to load. Also, opening an <code>.rdata</code> file with the R console will start a new session and load it. (At least this is true in Windows.)</p>
</div>
<div id="single-objects" class="section level4">
<h4><span class="header-section-number">3.6.9.2</span> Single objects</h4>
<p>Another option is the RDS format. This stores a single R object, so there is no need to fiddle with environments:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>
dat =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">v =</span> <span class="dv">3</span>)
<span class="kw">saveRDS</span>(dat, <span class="dt">file =</span> <span class="st">&quot;dat.rds&quot;</span>)

<span class="co"># and later, in another script</span>
old_dat &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;dat.rds&quot;</span>)</code></pre></div>
</div>
</div>
<div id="reading-and-writing-other-formats" class="section level3">
<h3><span class="header-section-number">3.6.10</span> Reading and writing other formats</h3>
<p>For “foreign” table formats (Excel, Stata, etc), use an internet search. These input and output tools will always be in active development because the formats themselves are in flux. of course, it is unwise to use any such formats for long-term data storage.</p>
</div>
<div id="format-cols" class="section level3">
<h3><span class="header-section-number">3.6.11</span> Formatting the display of columns</h3>
<p>While the way R displays dates (like <code>2017-11-22</code>) might not align with what is seen elsewhere, I suggest getting used to it rather than seeking a workaround, though I’m sure there are some (like making a new class). It will be easier for everyone looking at the data if it is in a standard format.</p>
<p>For the display of numbers, again, I suggest leaving it alone instead of, e.g., rounding or truncating everything. If it’s really an issue that must be addressed, read about <code>scipen</code> in <code>?options</code>.</p>
</div>
</div>
<div id="exploring-data" class="section level2">
<h2><span class="header-section-number">3.7</span> Exploring data</h2>
<p>We’ll look at two example data sets <code>mtcars</code> and <code>airquality</code>:</p>
<p>As a first step, we’ll clean up <code>carsDT</code>’s categorical variables (noted in <a href="tables.html#dt-agg">3.3</a>), using the approach suggested in <a href="tables.html#dt-recode">3.6.6</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rm</span>(<span class="dt">list =</span> <span class="kw">ls</span>())                  <span class="co"># clear tables and other objects</span>

airDT  =<span class="st"> </span><span class="kw">data.table</span>(airquality)
carsDT =<span class="st"> </span><span class="kw">data.table</span>(mtcars, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)
carsDT[.(<span class="dt">old_am =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">new_am =</span> <span class="kw">c</span>(<span class="st">&quot;auto&quot;</span>, <span class="st">&quot;manual&quot;</span>)), on=.(<span class="dt">am =</span> old_am), 
  new_am :<span class="er">=</span><span class="st"> </span>i.new_am ]           <span class="co"># grab new column</span>
carsDT[, am :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span> ]            <span class="co"># drop old column</span>
<span class="kw">setnames</span>(carsDT, <span class="st">&quot;new_am&quot;</span>, <span class="st">&quot;am&quot;</span>) <span class="co"># rename new column</span>

carsDT[.(<span class="dt">old_vs =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">new_vs =</span> <span class="kw">c</span>(<span class="st">&quot;v&quot;</span>, <span class="st">&quot;straight&quot;</span>)), on=.(<span class="dt">vs =</span> old_vs), 
  new_vs :<span class="er">=</span><span class="st"> </span>i.new_vs ]           <span class="co"># grab new column</span>
carsDT[, vs :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span> ]            <span class="co"># drop old column</span>
<span class="kw">setnames</span>(carsDT, <span class="st">&quot;new_vs&quot;</span>, <span class="st">&quot;vs&quot;</span>) <span class="co"># rename new column</span></code></pre></div>
<p>The rigmarole with dropping and renaming is necessary because data.table’s type safety protections (<a href="tables.html#dt-replace-all">3.4.3</a>) prevent overwriting columns with a new class (from numeric 1/0 to character “auto”/“manual”) in an update join.</p>
<div id="browse-env" class="section level3">
<h3><span class="header-section-number">3.7.1</span> Browsing loaded objects</h3>
<p>For a list of all loaded tables, run…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tables</span>()</code></pre></div>
<pre><code>#      NAME   NROW NCOL MB COLS                                            KEY
# [1,] airDT   153    6  1 Ozone,Solar.R,Wind,Temp,Month,Day                  
# [2,] carsDT   32   12  1 rn,mpg,cyl,disp,hp,drat,wt,qsec,gear,carb,am,vs    
# Total: 2MB</code></pre>
<p>We saw in <a href="tables.html#dt-saveload">3.6.9</a> that a collection of tables (and other objects) saved on disk can be loaded into an environment. We can look at tables in such an environment, too:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">load</span>(<span class="st">&quot;stuff.rdata&quot;</span>, <span class="dt">env =</span> e_stuff &lt;-<span class="st"> </span><span class="kw">new.env</span>())
<span class="kw">tables</span>(<span class="dt">env =</span> e_stuff)</code></pre></div>
<pre><code>#      NAME NROW NCOL MB COLS KEY
# [1,] dat     1    1  1 v       
# Total: 1MB</code></pre>
<p>The <code>tables</code> output shows keys and other attributes, which is handy. If we look at objects of all types (tables, vectors, matrices, functions and more), we usually only view names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>()</code></pre></div>
<pre><code># [1] &quot;airDT&quot;   &quot;carsDT&quot;  &quot;e_stuff&quot;</code></pre>
<p>Output can be filtered according to a regex (<a href="work.html#strings">4.8</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>(<span class="dt">patt =</span> <span class="st">&quot;DT$&quot;</span>)</code></pre></div>
<pre><code># [1] &quot;airDT&quot;  &quot;carsDT&quot;</code></pre>
<p>And it can be done within an environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>(<span class="dt">env =</span> e_stuff)</code></pre></div>
<pre><code># [1] &quot;dat&quot; &quot;L&quot;   &quot;n&quot;</code></pre>
<p>To remove tables or other objects, use <code>rm</code>. A common step is to remove all objects listed by <code>ls()</code>, like <code>rm(list = ls())</code>.</p>
</div>
<div id="dt-subset" class="section level3">
<h3><span class="header-section-number">3.7.2</span> Subsetting</h3>
<div id="selecting-by-value" class="section level4">
<h4><span class="header-section-number">3.7.2.1</span> Selecting by value</h4>
<p>This is analogous to a SQL WHERE clause or a Stata <code>if</code> clause.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[ am ==<span class="st"> &quot;auto&quot;</span> &amp;<span class="st"> </span>disp &lt;<span class="st"> </span><span class="dv">300</span> ]</code></pre></div>
<pre><code>#                 rn  mpg cyl  disp  hp drat    wt  qsec gear carb   am       vs
#  1: Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44    3    1 auto straight
#  2:        Valiant 18.1   6 225.0 105 2.76 3.460 20.22    3    1 auto straight
#  3:      Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00    4    2 auto straight
#  4:       Merc 230 22.8   4 140.8  95 3.92 3.150 22.90    4    2 auto straight
#  5:       Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4 auto straight
#  6:      Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90    4    4 auto straight
#  7:     Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40    3    3 auto        v
#  8:     Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60    3    3 auto        v
#  9:    Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00    3    3 auto        v
# 10:  Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01    3    1 auto straight</code></pre>
<p>This syntax, <code>DT[i]</code>, is the subsetting task needed in the vast majority of cases. The rest of <a href="tables.html#dt-subset">3.7.2</a> can safely be skipped the first time through; it is mostly useful for reference.</p>
</div>
<div id="selecting-by-group-statistic" class="section level4">
<h4><span class="header-section-number">3.7.2.2</span> Selecting by group statistic</h4>
<p>This is analogous to a SQL HAVING clause.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[ , if (<span class="kw">mean</span>(wt) &gt;<span class="st"> </span><span class="dv">3</span>) .SD, by=.(am, vs) ]</code></pre></div>
<pre><code>#       am       vs                  rn  mpg cyl  disp  hp drat    wt  qsec gear carb
#  1: auto straight      Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44    3    1
#  2: auto straight             Valiant 18.1   6 225.0 105 2.76 3.460 20.22    3    1
#  3: auto straight           Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00    4    2
#  4: auto straight            Merc 230 22.8   4 140.8  95 3.92 3.150 22.90    4    2
#  5: auto straight            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4
#  6: auto straight           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90    4    4
#  7: auto straight       Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01    3    1
#  8: auto        v   Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02    3    2
#  9: auto        v          Duster 360 14.3   8 360.0 245 3.21 3.570 15.84    3    4
# 10: auto        v          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40    3    3
# 11: auto        v          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60    3    3
# 12: auto        v         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00    3    3
# 13: auto        v  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98    3    4
# 14: auto        v Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82    3    4
# 15: auto        v   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42    3    4
# 16: auto        v    Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87    3    2
# 17: auto        v         AMC Javelin 15.2   8 304.0 150 3.15 3.435 17.30    3    2
# 18: auto        v          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41    3    4
# 19: auto        v    Pontiac Firebird 19.2   8 400.0 175 3.08 3.845 17.05    3    2</code></pre>
<p>We are including the group only if it meets our condition. The structure <code>if (cond) x</code> returns <code>x</code> if the condition is true and nothing (<code>NULL</code>) otherwise, omitting those rows.</p>
</div>
<div id="selecting-rows-within-each-group" class="section level4">
<h4><span class="header-section-number">3.7.2.3</span> Selecting rows within each group</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sorting by carb decreasing, selecting first row per group</span>
<span class="co"># thus a row with maximum carb within the group</span>
carsDT[ <span class="kw">order</span>(-carb), .SD[1L], by=.(am, vs) ]</code></pre></div>
<pre><code>#        am       vs            rn  mpg cyl  disp  hp drat    wt  qsec gear carb
# 1: manual        v Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60    5    8
# 2:   auto        v    Duster 360 14.3   8 360.0 245 3.21 3.570 15.84    3    4
# 3:   auto straight      Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4
# 4: manual straight   Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52    4    2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># instead select all row(s) with maximum carb</span>
carsDT[ , .SD[carb ==<span class="st"> </span><span class="kw">max</span>(carb)], by=.(am, vs) ]</code></pre></div>
<pre><code>#         am       vs                  rn  mpg cyl  disp  hp drat    wt  qsec gear carb
#  1: manual        v       Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60    5    8
#  2: manual straight         Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52    4    2
#  3: manual straight        Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.90    5    2
#  4: manual straight          Volvo 142E 21.4   4 121.0 109 4.11 2.780 18.60    4    2
#  5:   auto straight            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4
#  6:   auto straight           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90    4    4
#  7:   auto        v          Duster 360 14.3   8 360.0 245 3.21 3.570 15.84    3    4
#  8:   auto        v  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98    3    4
#  9:   auto        v Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82    3    4
# 10:   auto        v   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42    3    4
# 11:   auto        v          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41    3    4</code></pre>

<div class="rmd-details">
<strong>Efficient selection of rows within each group.</strong> The second task here is <a href="https://github.com/Rdatatable/data.table/issues/735">somewhat inefficient</a> currently, with a faster workaround <a href="http://stackoverflow.com/a/16574176">provided by eddi</a>: <code>carsDT[carsDT[ , .I[carb == max(carb)], by=.(am, vs) ]$V1]</code>. And <a href="http://stackoverflow.com/a/31854111">Arun provided a further improvement</a>: <code>carsDT[carsDT[, max(carb), by=.(am, vs)], on=.(am, vs, carb = V1)]</code>.
</div>
<p></p>
</div>
<div id="finding-where-a-condition-holds" class="section level4">
<h4><span class="header-section-number">3.7.2.4</span> Finding where a condition holds</h4>
<p>To find where a condition holds:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cond =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;aleph&quot;</span>, <span class="st">&quot;baz&quot;</span>, <span class="st">&quot;boz&quot;</span>) &gt;<span class="st"> &quot;b&quot;</span>
<span class="kw">which</span>(cond)</code></pre></div>
<pre><code># [1] 2 3</code></pre>
<p>So, it takes us from a logical index to one of positions. When using <code>which</code> on a matrix or array (see <a href="basics.html#matrix-array">2.2</a>), we can find out “where” in terms of row and column using the <code>arr.ind</code> option.</p>
<p>Beware of using <code>which</code> output as an index:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x       =<span class="st"> </span><span class="dv">1</span>:<span class="dv">5</span>
w_not   =<span class="st"> </span><span class="kw">which</span>(x^<span class="dv">2</span> &gt;<span class="st"> </span><span class="dv">50</span>)
w_not</code></pre></div>
<pre><code># integer(0)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-w_not]</code></pre></div>
<pre><code># integer(0)</code></pre>
<p>We wanted to filter to where <code>x</code> fails our condition, but instead we lost the whole vector. Straight-up logical filtering is the safer route here: <code>x[!(x^2 &gt; 50)]</code>.</p>
<p>To find which table rows a subset pertains to, use <code>DT[i, which = TRUE]</code>. The <code>i</code> index could be a logical condition or a table being joined. It might seem like the special symbol <code>.I</code> would work here instead, like <code>DT[i, .I]</code>, but currently it does not.</p>
</div>
</div>
<div id="sorting" class="section level3">
<h3><span class="header-section-number">3.7.3</span> Sorting</h3>
<p>To sort the table in-place, use <code>setorder</code>. And to set a key (which sorts as a side effect), use <code>setkey</code>. When passing columns to sort by programmatically, use <code>setorderv</code> or <code>setkeyv</code>.</p>
<p>For a one-time sort (not altering the order of the object itself), write an <code>order(...)</code> expression in the first argument, like <code>carsDT[order(hp, -carb), j, by=]</code> where <code>j</code> and <code>by=</code> characterize some task to be done with the sorted data.</p>
</div>
<div id="explore-onevar" class="section level3">
<h3><span class="header-section-number">3.7.4</span> Examining each variable</h3>
<div id="summary-functions" class="section level4">
<h4><span class="header-section-number">3.7.4.1</span> Summary functions</h4>
<p>For a snapshot of per-variable stats, there’s <code>summary</code>, but it is very crude and reports nothing about character columns (not even missing values):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(airDT)</code></pre></div>
<pre><code>#      Ozone           Solar.R           Wind             Temp           Month      
#  Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00   Min.   :5.000  
#  1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00   1st Qu.:6.000  
#  Median : 31.50   Median :205.0   Median : 9.700   Median :79.00   Median :7.000  
#  Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88   Mean   :6.993  
#  3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00   3rd Qu.:8.000  
#  Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00   Max.   :9.000  
#  NA&#39;s   :37       NA&#39;s   :7                                                       
#       Day      
#  Min.   : 1.0  
#  1st Qu.: 8.0  
#  Median :16.0  
#  Mean   :15.8  
#  3rd Qu.:23.0  
#  Max.   :31.0  
# </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(carsDT)</code></pre></div>
<pre><code>#       rn                 mpg             cyl             disp             hp       
#  Length:32          Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  
#  Class :character   1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  
#  Mode  :character   Median :19.20   Median :6.000   Median :196.3   Median :123.0  
#                     Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  
#                     3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  
#                     Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  
#       drat             wt             qsec            gear            carb      
#  Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :3.000   Min.   :1.000  
#  1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:3.000   1st Qu.:2.000  
#  Median :3.695   Median :3.325   Median :17.71   Median :4.000   Median :2.000  
#  Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :3.688   Mean   :2.812  
#  3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:4.000   3rd Qu.:4.000  
#  Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :5.000   Max.   :8.000  
#       am                 vs           
#  Length:32          Length:32         
#  Class :character   Class :character  
#  Mode  :character   Mode  :character  
#                                       
#                                       
# </code></pre>
<p>To count missing values per column (analogous to Stata’s mdesc)…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[, .(
  <span class="dt">col =</span> <span class="kw">names</span>(.SD),
  <span class="dt">nna =</span> nna &lt;-<span class="st"> </span><span class="kw">colSums</span>(<span class="kw">is.na</span>(.SD)),
  <span class="dt">nok =</span> .N -<span class="st"> </span>nna,
  <span class="dt">tot =</span> .N
)]</code></pre></div>
<pre><code>#        col nna nok tot
# 1:   Ozone  37 116 153
# 2: Solar.R   7 146 153
# 3:    Wind   0 153 153
# 4:    Temp   0 153 153
# 5:   Month   0 153 153
# 6:     Day   0 153 153</code></pre>
<p>This can also be done by group, like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[, .(
  <span class="dt">col =</span> <span class="kw">names</span>(.SD),
  <span class="dt">nna =</span> nna &lt;-<span class="st"> </span><span class="kw">colSums</span>(<span class="kw">is.na</span>(.SD)),
  <span class="dt">nok =</span> .N -<span class="st"> </span>nna,
  <span class="dt">tot =</span> .N
), by=Month]</code></pre></div>
<p>Various function can be applied and have the usual names: <code>mean</code>, <code>median</code>, <code>range</code> (combining <code>min</code> and <code>max</code>), <code>var</code>, <code>skew</code>, <code>quantile</code>, etc. Most of these functions can be applied by group as well, with syntax like …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># single-valued functions</span>
carsDT[, <span class="kw">mean</span>(drat), by=am]</code></pre></div>
<pre><code>#        am       V1
# 1: manual 4.050000
# 2:   auto 3.286316</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># multi-valued functions</span>
carsDT[, <span class="kw">quantile</span>(drat, <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">25</span>, .<span class="dv">75</span>, .<span class="dv">9</span>)) %&gt;%<span class="st"> </span>as.list, by=am]</code></pre></div>
<pre><code>#        am   10%  25%   75%   90%
# 1: manual 3.650 3.85 4.220 4.388
# 2:   auto 2.896 3.07 3.695 3.920</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># multiple functions</span>
carsDT[, <span class="kw">c</span>(
  .(<span class="dt">mean =</span> <span class="kw">mean</span>(drat)), 
  <span class="kw">quantile</span>(drat, <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">25</span>, .<span class="dv">75</span>, .<span class="dv">9</span>)) %&gt;%<span class="st"> </span>as.list
), by=am]</code></pre></div>
<pre><code>#        am     mean   10%  25%   75%   90%
# 1: manual 4.050000 3.650 3.85 4.220 4.388
# 2:   auto 3.286316 2.896 3.07 3.695 3.920</code></pre>
<p>The <code>as.list</code> is necessary to split the results over multiple columns. It is inefficient, but that won’t matter much when exploring data, I imagine.</p>
</div>
<div id="tabulating" class="section level4">
<h4><span class="header-section-number">3.7.4.2</span> Tabulating</h4>
<p>For a better look at a character or factor column, we’d want to tabulate values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, <span class="kw">table</span>(am, <span class="dt">useNA =</span> <span class="st">&quot;always&quot;</span>)]</code></pre></div>
<pre><code># am
#   auto manual   &lt;NA&gt; 
#     19     13      0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, .N, by=am]</code></pre></div>
<pre><code>#        am  N
# 1: manual 13
# 2:   auto 19</code></pre>
<p>Each of the two options above has advantages in certain cases. We’ll see that <code>table()</code> is useful when browsing tabulations in more dimensions. And the <code>DT[...]</code> syntax is useful for chaining. For example, <code>carsDT[, .N, by=av][order(-N)][1:3]</code> will show counts for the three largest groups, sorted.</p>
<p>For a better look at continuous variables, we can use the same tools after using <code>cut</code> to put values into bins:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .N, by=.(<span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))]</code></pre></div>
<pre><code>#       drat_bin  N
# 1: (3.84,4.39] 11
# 2:  (2.76,3.3] 13
# 3:  (3.3,3.84]  6
# 4: (4.39,4.93]  2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span><span class="kw">cut</span>(<span class="dv">4</span>) %&gt;%<span class="st"> </span>table ]</code></pre></div>
<pre><code># .
#  (2.76,3.3]  (3.3,3.84] (3.84,4.39] (4.39,4.93] 
#          13           6          11           2</code></pre>
</div>
<div id="plotting" class="section level4">
<h4><span class="header-section-number">3.7.4.3</span> Plotting</h4>
<p>We can plot a binned version of the variable; or instead a stem-and-leaf plot; or histogram; or a kernel approximation to the density; or a box plot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, drat %&gt;%<span class="st"> </span><span class="kw">cut</span>(<span class="dv">4</span>) %&gt;%<span class="st"> </span>table %&gt;%<span class="st"> </span>plot ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-1.png" width="672" /></p>
<pre><code># [1] 1 2 3 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span><span class="kw">hist</span>(<span class="dv">4</span>) %&gt;%<span class="st"> </span>{<span class="ot">NULL</span>} ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-2.png" width="672" /></p>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span>stem ]</code></pre></div>
<pre><code># 
#   The decimal point is 1 digit(s) to the left of the |
# 
#   26 | 66
#   28 | 3
#   30 | 07778855
#   32 | 13
#   34 | 4
#   36 | 29037
#   38 | 500222
#   40 | 881
#   42 | 22
#   44 | 3
#   46 | 
#   48 | 3</code></pre>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span>density %&gt;%<span class="st"> </span>plot ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-3.png" width="672" /></p>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span>boxplot  %&gt;%<span class="st"> </span>{<span class="ot">NULL</span>} ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-4.png" width="672" /></p>
<pre><code># NULL</code></pre>
<p>The first option is discouraged by a note in <code>?cut</code>:</p>
<blockquote>
<p>Instead of <code>table(cut(x, br))</code>, <code>hist(x, br, plot = FALSE)</code> is more efficient and less memory hungry.</p>
</blockquote>
<p>The <code>{NULL}</code> at the end is useful for fairly esoteric reasons. With <code>hist</code>, it is to avoid printing the histogram’s internal structure to the console. With <code>boxplot</code> the same reason applies, but in addition, it is to avoid an error caused by how data.table processes the <code>j</code> argument of <code>DT[i,j,by]</code>. Anyway, a trailing <code>NULL</code> can safely be tacked onto the end of any <code>j</code> operation where you don’t actually want to see the return value.</p>
<p>As seen here, using <code>%&gt;%</code> pipes with plotting functions has the unfortunate side effect of yielding blanks in titles and axes. Compare with <code>carsDT[, hist(drat, 4) ]</code>, for example. Nonetheless, piping is often convenient for this. The <code>cut</code>, <code>hist</code>, <code>density</code>, <code>boxplot</code> and <code>plot</code> functions all have many options that can be tweaked, documented in their help files, but with the default options they are a quick way to glance at a variable.</p>
</div>
<div id="other-analyses" class="section level4">
<h4><span class="header-section-number">3.7.4.4</span> Other analyses</h4>
<p>Of course, various statistical tests can be applied to a vector; but that is best left up to an internet search and careful reading of the documentation.</p>
</div>
</div>
<div id="explore-vars" class="section level3">
<h3><span class="header-section-number">3.7.5</span> Examining variables jointly</h3>
<div id="summary-functions-1" class="section level4">
<h4><span class="header-section-number">3.7.5.1</span> Summary functions</h4>
<p>The <code>var</code> function applied to a table will give its variance-covariance matrix. There’s also the correlation matrix with <code>corr</code>; and a plotter for the correlation matrix in <a href="https://CRAN.R-project.org/package=corrplot">the corrplot package</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, <span class="kw">var</span>(.SD), .SDcols =<span class="st"> </span><span class="kw">sapply</span>(carsDT, is.numeric)]</code></pre></div>
<pre><code>#              mpg         cyl        disp          hp         drat          wt
# mpg    36.324103  -9.1723790  -633.09721 -320.732056   2.19506351  -5.1166847
# cyl    -9.172379   3.1895161   199.66028  101.931452  -0.66836694   1.3673710
# disp -633.097208 199.6602823 15360.79983 6721.158669 -47.06401915 107.6842040
# hp   -320.732056 101.9314516  6721.15867 4700.866935 -16.45110887  44.1926613
# drat    2.195064  -0.6683669   -47.06402  -16.451109   0.28588135  -0.3727207
# wt     -5.116685   1.3673710   107.68420   44.192661  -0.37272073   0.9573790
# qsec    4.509149  -1.8868548   -96.05168  -86.770081   0.08714073  -0.3054816
# gear    2.135685  -0.6491935   -50.80262   -6.358871   0.27598790  -0.4210806
# carb   -5.363105   1.5201613    79.06875   83.036290  -0.07840726   0.6757903
#              qsec        gear        carb
# mpg    4.50914919   2.1356855 -5.36310484
# cyl   -1.88685484  -0.6491935  1.52016129
# disp -96.05168145 -50.8026210 79.06875000
# hp   -86.77008065  -6.3588710 83.03629032
# drat   0.08714073   0.2759879 -0.07840726
# wt    -0.30548161  -0.4210806  0.67579032
# qsec   3.19316613  -0.2804032 -1.89411290
# gear  -0.28040323   0.5443548  0.32661290
# carb  -1.89411290   0.3266129  2.60887097</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, <span class="kw">cor</span>(.SD), .SDcols =<span class="st"> </span><span class="kw">sapply</span>(carsDT, is.numeric)]</code></pre></div>
<pre><code>#             mpg        cyl       disp         hp        drat         wt        qsec
# mpg   1.0000000 -0.8521620 -0.8475514 -0.7761684  0.68117191 -0.8676594  0.41868403
# cyl  -0.8521620  1.0000000  0.9020329  0.8324475 -0.69993811  0.7824958 -0.59124207
# disp -0.8475514  0.9020329  1.0000000  0.7909486 -0.71021393  0.8879799 -0.43369788
# hp   -0.7761684  0.8324475  0.7909486  1.0000000 -0.44875912  0.6587479 -0.70822339
# drat  0.6811719 -0.6999381 -0.7102139 -0.4487591  1.00000000 -0.7124406  0.09120476
# wt   -0.8676594  0.7824958  0.8879799  0.6587479 -0.71244065  1.0000000 -0.17471588
# qsec  0.4186840 -0.5912421 -0.4336979 -0.7082234  0.09120476 -0.1747159  1.00000000
# gear  0.4802848 -0.4926866 -0.5555692 -0.1257043  0.69961013 -0.5832870 -0.21268223
# carb -0.5509251  0.5269883  0.3949769  0.7498125 -0.09078980  0.4276059 -0.65624923
#            gear       carb
# mpg   0.4802848 -0.5509251
# cyl  -0.4926866  0.5269883
# disp -0.5555692  0.3949769
# hp   -0.1257043  0.7498125
# drat  0.6996101 -0.0907898
# wt   -0.5832870  0.4276059
# qsec -0.2126822 -0.6562492
# gear  1.0000000  0.2740728
# carb  0.2740728  1.0000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, <span class="kw">cor</span>(.SD) %&gt;%<span class="st"> </span>corrplot::<span class="kw">corrplot</span>() %&gt;%<span class="st"> </span>{<span class="ot">NULL</span>}, .SDcols =<span class="st"> </span><span class="kw">sapply</span>(carsDT, is.numeric)]</code></pre></div>
<p><img src="tutorial_files/figure-html/vcv-1.png" width="672" /></p>
<pre><code># NULL</code></pre>
<p>The trailing <code>()</code> on <code>corrplot::corrplot()</code> is necessary thanks to <a href="https://github.com/tidyverse/magrittr/issues/12">a magrittr bug</a> not yet fixed on CRAN.</p>
</div>
<div id="table-mult" class="section level4">
<h4><span class="header-section-number">3.7.5.2</span> Tabulating</h4>
<p>Cross tabulation of discrete, or discretized, variables uses <code>table</code> or <code>.N</code> again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .N, by=.(am, <span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))]</code></pre></div>
<pre><code>#        am    drat_bin  N
# 1: manual (3.84,4.39]  8
# 2:   auto  (2.76,3.3] 13
# 3:   auto  (3.3,3.84]  3
# 4:   auto (3.84,4.39]  3
# 5: manual (4.39,4.93]  2
# 6: manual  (3.3,3.84]  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, <span class="kw">table</span>(am, <span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))]</code></pre></div>
<pre><code>#         drat_bin
# am       (2.76,3.3] (3.3,3.84] (3.84,4.39] (4.39,4.93]
#   auto           13          3           3           0
#   manual          0          3           8           2</code></pre>
<p>Note that the <code>table</code> approach includes zeros, while they don’t show up in the aggregation using <code>.N</code>.</p>
</div>
<div id="plotting-1" class="section level4">
<h4><span class="header-section-number">3.7.5.3</span> Plotting</h4>
<p>For a pair of continuous variables, <code>qqplot</code> will give a QQ plot; and <code>plot</code>, a scatterplot. To deal with the fact that varying density isn’t always clear in a scatterplot (since dots end up on top of each other), one common recommendation is the <a href="https://cran.r-project.org/package=hexbin">hexbin package</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[, { 
  hexbin::<span class="kw">hexbin</span>(Wind, Temp) %&gt;%<span class="st"> </span>plot
  <span class="ot">NULL</span> 
}]</code></pre></div>
<p><img src="tutorial_files/figure-html/hexbin-1.png" width="672" /></p>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[,  <span class="kw">plot</span>(Wind, Temp)]</code></pre></div>
<p><img src="tutorial_files/figure-html/hexbin-2.png" width="672" /></p>
<pre><code># NULL</code></pre>
<p>To see how a particular curve relates to the data, it can be overlaid on compatible plots like <code>curve(100 - 3*x, add = TRUE)</code>. Without the <code>add=TRUE</code> option, the curve would be placed in a new plot.</p>

<div class="rmd-caution">
<p><strong>Plot windows.</strong> Working interactively in the R console, each plot takes the place of the last one, using the same window. To open new windows use <code>x11()</code> whatever command the plotting function says is necessary. Multiple plots can be fit in the same window using <code>par</code>.</p>
In R Studio, a history of plots is saved in the “Plots” area and can be browsed using the left and right arrow buttons there. The x and broom buttons can be used to remove plots from the history. If you want plots in separate windows (like seen in the R console), <code>x11()</code> or a similar call can be used.
</div>
<p></p>
</div>
<div id="other-analyses-1" class="section level4">
<h4><span class="header-section-number">3.7.5.4</span> Other analyses</h4>
<p>An internet search will reveal many tools for estimating a model and plotting its fitted curve and confidence bands on top of the cloud of points, so I won’t cover those here. Usually, after finding such a tool, a read of its documentation and running its examples will be sufficient to figure it out. And for more than two variables, the same is true – a search online will serve very well, assuming the desired task is clear.</p>
</div>
</div>
<div id="dcast-browse" class="section level3">
<h3><span class="header-section-number">3.7.6</span> Reshaping to wide</h3>
<p>The <code>dcast</code> function is a flexible way of making a table of summary stats. Extending some examples above…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .(.N, <span class="dt">mean_hp =</span> <span class="kw">mean</span>(hp)), by=.(am, <span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))][,
  <span class="kw">dcast</span>(.SD, drat_bin ~<span class="st"> </span>am, <span class="dt">value.var =</span> <span class="kw">c</span>(<span class="st">&quot;N&quot;</span>, <span class="st">&quot;mean_hp&quot;</span>))
]</code></pre></div>
<pre><code>#       drat_bin N_auto N_manual mean_hp_auto mean_hp_manual
# 1:  (2.76,3.3]     13       NA     176.9231             NA
# 2:  (3.3,3.84]      3        3     134.6667       207.6667
# 3: (3.84,4.39]      3        8     113.6667       110.3750
# 4: (4.39,4.93]     NA        2           NA        71.5000</code></pre>
<p>So we get row counts and mean horsepower computed by auto/manual and bins of drat (rear-axle ration). Unfortunately, we get NA counts instead of zeros here, but if the goal is simply to explore data, that shouldn’t be a big deal.</p>
<p>The <code>dcast</code> function and its counterpart, <code>melt</code>, are covered in <code>vignette(&quot;datatable-reshape&quot;)</code>. Also, <code>melt</code> comes up again in <a href="tables.html#structuring-data">3.8</a> below.</p>

<div class="rmd-details">
<p><strong>Melting and casting.</strong> The functions started in <a href="https://CRAN.R-project.org/package=reshape2">the reshape2 package</a>, which contains extensions like melting and casting to and from arrays and matrices.</p>
My guess is that the terms melting and casting (for conversion of a table to and from long format) are taken from mettalurgy. There is only one long-form arrangement of data – its liquid or molten form – and this form is the most flexible. In contrast, there are many rigid wide-form arrangements, each with its own mold to cast the molten data into.
</div>
<p></p>
</div>
</div>
<div id="structuring-data" class="section level2">
<h2><span class="header-section-number">3.8</span> Organizing relational tables</h2>
<p>The best way to organize data in R takes advantage of the power to have multiple data sets in the workspace. With tabular data, that means using “relational” tables that can be linked together by various index columns.</p>
<p>Some good references are the Wikipedia pages on <a href="https://en.wikipedia.org/wiki/Database_normalization">normalization</a> and the <a href="https://en.wikipedia.org/wiki/Relational_model">relational model</a>; and <a href="https://www.jstatsoft.org/article/view/v059i10">Hadley Wickham’s exposition aimed at R users</a>.</p>
<div id="redundant" class="section level3">
<h3><span class="header-section-number">3.8.1</span> Removing redundant data</h3>
<p>Consider this table of experimental results (see <code>?datasets::CO2</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carbDT =<span class="st"> </span><span class="kw">data.table</span>(CO2)
carbDT %&gt;%<span class="st"> </span><span class="kw">print</span>(<span class="dt">nrow =</span> <span class="dv">10</span>)</code></pre></div>
<pre><code>#     Plant        Type  Treatment conc uptake
#  1:   Qn1      Quebec nonchilled   95   16.0
#  2:   Qn1      Quebec nonchilled  175   30.4
#  3:   Qn1      Quebec nonchilled  250   34.8
#  4:   Qn1      Quebec nonchilled  350   37.2
#  5:   Qn1      Quebec nonchilled  500   35.3
# ---                                         
# 80:   Mc3 Mississippi    chilled  250   17.9
# 81:   Mc3 Mississippi    chilled  350   17.9
# 82:   Mc3 Mississippi    chilled  500   17.9
# 83:   Mc3 Mississippi    chilled  675   18.9
# 84:   Mc3 Mississippi    chilled 1000   19.9</code></pre>
<p>Using the tools for inspecting and browsing tables (<a href="tables.html#dt-inspect">3.2.1</a>), we can see that each <code>Plant</code> always has the same type and treatment. Reading the docs for the data set, we see that these are in fact attributes of the plant codes.</p>
<p>We can spin these plant code attributes off:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plantDT =<span class="st"> </span><span class="kw">unique</span>(carbDT[, .(Plant, Type, Treatment)])
<span class="kw">setkey</span>(plantDT, Plant)
carbDT[, <span class="kw">c</span>(<span class="st">&quot;Type&quot;</span>, <span class="st">&quot;Treatment&quot;</span>) :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span> ]
<span class="kw">setkey</span>(carbDT, Plant, conc)</code></pre></div>
<p>The <code>unique</code> function drops duplicates. Related tools are discussed in <a href="work.html#sets">4.1</a>.</p>
<p>There are a few advantages to having data in this format:</p>
<ol style="list-style-type: decimal">
<li>The data takes up less space.</li>
<li><p>The data will be easier to browse, since we won’t have columns spilling off the right side of the screen whenever inspecting the data; and, with the keys (<a href="tables.html#keys-indices">3.5.8.1</a>), we can subset like…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carbDT[.(<span class="st">&quot;Mc1&quot;</span>)]</code></pre></div>
<pre><code>#    Plant conc uptake
# 1:   Mc1   95   10.5
# 2:   Mc1  175   14.9
# 3:   Mc1  250   18.1
# 4:   Mc1  350   18.9
# 5:   Mc1  500   19.5
# 6:   Mc1  675   22.2
# 7:   Mc1 1000   21.9</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carbDT[.(<span class="st">&quot;Mc1&quot;</span>, <span class="dv">95</span>)]</code></pre></div>
<pre><code>#    Plant conc uptake
# 1:   Mc1   95   10.5</code></pre></li>
<li>While we are editing <code>carbDT</code> in the course of data cleaning or analysis, we no longer have to worry about accidentally introducing inconsistencies in <code>Type</code> and <code>Treatment</code> (causing them to vary within a <code>Plant</code> even though they shouldn’t).</li>
<li>Any further <code>Plant</code>-level attributes we need to define (like date the sample was taken) can go into the dedicated table, <code>plantDT</code>, without cluttering up the experimental results in <code>carbDT</code>.</li>
<li><p>Each table has keys that we can characterize and test. To verify that there are no duplicates, for example, we can do</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(
  plantDT %&gt;%<span class="st"> </span>{ .[, .N, by=<span class="kw">key</span>(.)][N &gt;<span class="st"> </span>1L, .N ==<span class="st"> </span>0L] }
)
<span class="kw">stopifnot</span>(
  carbDT %&gt;%<span class="st"> </span>{ .[, .N, by=<span class="kw">key</span>(.)][N &gt;<span class="st"> </span>1L, .N ==<span class="st"> </span>0L] }
)</code></pre></div>
<p>We are counting rows per value of the key, using the tabulation methods mentioned in <a href="tables.html#table-mult">3.7.5.2</a>, <code>DT[, .N, by=key(DT)]</code>; then filtering to key values having more than one row with <code>N &gt; 1</code>; and then asserting that there are no such rows <code>.N == 0L</code>. The <code>stopifnot</code> wrapper is R’s basic tool for assertions.</p>
<p>Similarly, we can verify that every combination of type and treatment appears in <code>plantDT</code>; and that every combination of <code>Plant</code> and <code>conc</code> appears in <code>carbDT</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(
  plantDT[<span class="kw">CJ</span>(<span class="dt">Type =</span> Type, <span class="dt">Treatment =</span> Treatment, <span class="dt">unique =</span> <span class="ot">TRUE</span>), <span class="dt">on=</span>.(Type, Treatment), .N, <span class="dt">by=</span>.EACHI][, <span class="kw">all</span>(N &gt;=<span class="st"> </span>1L)]
)</code></pre></div>
<p>We are using <code>CJ</code> to enumerate combinations (see <a href="work.html#combos">4.2</a>); then counting matches using merge diagnostics (<a href="tables.html#join-unmatched">3.5.6.2</a>); and then asserting that every combo was matched by at least 1 row. The repetition of column names required here is annoying and will hopefully be addressed by nicer syntax soon. For the time being, there’s…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_cols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Type&quot;</span>, <span class="st">&quot;Treatment&quot;</span>)
test_lvls =<span class="st"> </span><span class="kw">do.call</span>(CJ, <span class="kw">c</span>(plantDT[, ..test_cols], <span class="dt">unique=</span><span class="ot">TRUE</span>))
<span class="kw">stopifnot</span>(
  plantDT[test_lvls, <span class="dt">on=</span>test_cols, .N, <span class="dt">by=</span>.EACHI][, <span class="kw">all</span>(N &gt;=<span class="st"> </span><span class="dv">1</span>)]
)</code></pre></div>
<p><code>do.call</code> and other helpful programming tricks are covered in <a href="tables.html#do-call">3.8.4.1</a>.</p></li>
</ol>
<p>Continuing the example, if we had many more types of plants, besides Quebec and Mississippi, we might end up assigning attributes to these as well (like country or latitude). In that case, we would want a further table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">typeDT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">Type =</span> <span class="kw">c</span>(<span class="st">&quot;Quebec&quot;</span>, <span class="st">&quot;Mississippi&quot;</span>, <span class="st">&quot;Queens&quot;</span>, <span class="st">&quot;Montreal&quot;</span>), 
  <span class="dt">Country =</span> <span class="kw">c</span>(<span class="st">&quot;CA&quot;</span>, <span class="st">&quot;US&quot;</span>, <span class="st">&quot;US&quot;</span>, <span class="st">&quot;CA&quot;</span>)
)</code></pre></div>
<pre><code>#           Type Country
# 1:      Quebec      CA
# 2: Mississippi      US
# 3:      Queens      US
# 4:    Montreal      CA</code></pre>
</div>
<div id="melt" class="section level3">
<h3><span class="header-section-number">3.8.2</span> Reshaping to long</h3>
<p>Continuing the last example, imagine we started out with the <code>CO2</code> data set in wide format, with concentrations on columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">dcast</span>(<span class="kw">data.table</span>(CO2), Plant ~<span class="st"> </span>conc, <span class="dt">value.var=</span><span class="st">&quot;uptake&quot;</span>)</code></pre></div>
<pre><code>#     Plant   95  175  250  350  500  675 1000
#  1:   Qn1 16.0 30.4 34.8 37.2 35.3 39.2 39.7
#  2:   Qn2 13.6 27.3 37.1 41.8 40.6 41.4 44.3
#  3:   Qn3 16.2 32.4 40.3 42.1 42.9 43.9 45.5
#  4:   Qc1 14.2 24.1 30.3 34.6 32.5 35.4 38.7
#  5:   Qc3 15.1 21.0 38.1 34.0 38.9 39.6 41.4
#  6:   Qc2  9.3 27.3 35.0 38.8 38.6 37.5 42.4
#  7:   Mn3 11.3 19.4 25.8 27.9 28.5 28.1 27.8
#  8:   Mn2 12.0 22.0 30.6 31.8 32.4 31.1 31.5
#  9:   Mn1 10.6 19.2 26.2 30.0 30.9 32.4 35.5
# 10:   Mc2  7.7 11.4 12.3 13.0 12.5 13.7 14.4
# 11:   Mc3 10.6 18.0 17.9 17.9 17.9 18.9 19.9
# 12:   Mc1 10.5 14.9 18.1 18.9 19.5 22.2 21.9</code></pre>
<p>This format is arguably better for browsing (<a href="tables.html#dcast-browse">3.7.6</a>), but it will become a hassle if we want to find a quantitative relationship between values of concentration (on the columns) and uptake (in the cells). Stubbornly sticking to this data format often (or maybe always) leads to bad code that “aggregates” over columns or runs separately for each and every row (<a href="tables.html#dt-lapply">3.3.1</a>).</p>
<p>To convert to a format amenable to analysis (you know, where numbers are numbers), we use <code>melt</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mDT =<span class="st"> </span><span class="kw">melt</span>(DT, <span class="dt">id =</span> <span class="st">&quot;Plant&quot;</span>, <span class="dt">variable.name =</span> <span class="st">&quot;conc&quot;</span>, <span class="dt">value.var =</span> <span class="st">&quot;uptake&quot;</span>, <span class="dt">variable.factor =</span> <span class="ot">FALSE</span>)
<span class="kw">setkey</span>(mDT, Plant, conc)

<span class="co"># convert to numeric</span>
mDT[, conc :<span class="er">=</span><span class="st"> </span><span class="kw">as.numeric</span>(conc)]</code></pre></div>
<p>It is not essential to set keys (<a href="tables.html#keys-indices">3.5.8.1</a>), but it’s fairly low-cost and makes thinking through the structure of the data clearer.</p>
<p>Even when it’s not as egregious as storing numbers as column names, it is very often the case that multiple columns store similar information that really would be more naturally stored in a single column.</p>
<p>Stubbornly sticking to wide form can create problems particularly with dynamic data (that is updated over time). For example, if you have a column for “daily sales online” and another column for “daily sales in-store”, what happens when you must also store data on “sales through our affiliate”? Adding more and more columns on-the-fly is asking for trouble: what class should this new column have? what are the rules for where it can have missing values? is its name consistent with those of related columns (“sales_online”, “sales_offline”, “sales_partner”, “sales_newpartner”)? This problem is what is meant by <a href="https://en.wikipedia.org/wiki/Database_normalization#Minimize_redesign_when_extending_the_database_structure">“minimise redesign when extending” (on Wikipedia’s normalization page)</a>.</p>
<p>See <code>vignette(&quot;datatable-reshape&quot;)</code> for more on reshaping tables.</p>
</div>
<div id="relational-updatejoin" class="section level3">
<h3><span class="header-section-number">3.8.3</span> Preparing data with update joins</h3>
<p>The set of relational tables is just to structure the data. During analysis, of course we often need to combine variables from the disparate tables; and for this, an update join will always suffice (<a href="tables.html#joins-update">3.5.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat =<span class="st"> </span><span class="kw">copy</span>(carbDT)
dat[plantDT, on=.(Plant), <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(<span class="dt">Type =</span> i.Type, <span class="dt">Treatment =</span> i.Treatment)]
<span class="co"># then do some analysis with dat</span></code></pre></div>

<div class="rmd-caution">
<strong>Dummies for categorical variables.</strong> As a side note: when preparing data for analysis, it is almost never necessary to convert categorical variables (<a href="basics.html#factors">2.1.12</a>) into a set 1/0 dummies (one for each category). Most R functions for analysis recognize and play nice with factors (or character columns).
</div>
<p></p>
</div>
<div id="program-tables" class="section level3">
<h3><span class="header-section-number">3.8.4</span> Programming with tables</h3>
<div id="do-call" class="section level4">
<h4><span class="header-section-number">3.8.4.1</span> Passing a list of arguments</h4>
<p>To pass multiple arguments to a function programmatically, use <code>do.call</code>. Here’s an example for construction of a Cartesian product table (from <a href="tables.html#redundant">3.8.1</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_args =<span class="st"> </span><span class="kw">c</span>(plantDT[, <span class="kw">c</span>(<span class="st">&quot;Type&quot;</span>, <span class="st">&quot;Treatment&quot;</span>)], <span class="dt">unique=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code># $Type
#  [1] Quebec      Quebec      Quebec      Quebec      Quebec      Quebec      Mississippi
#  [8] Mississippi Mississippi Mississippi Mississippi Mississippi
# Levels: Quebec Mississippi
# 
# $Treatment
#  [1] nonchilled nonchilled nonchilled chilled    chilled    chilled    nonchilled
#  [8] nonchilled nonchilled chilled    chilled    chilled   
# Levels: nonchilled chilled
# 
# $unique
# [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">do.call</span>(CJ, my_args)</code></pre></div>
<pre><code>#           Type  Treatment
# 1:      Quebec nonchilled
# 2:      Quebec    chilled
# 3: Mississippi nonchilled
# 4: Mississippi    chilled</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ... does the same as entering each argument manually ...</span>
<span class="kw">CJ</span>(<span class="dt">Type =</span> plantDT$Type, <span class="dt">Treatment =</span> plantDT$Treatment, <span class="dt">unique=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>#           Type  Treatment
# 1:      Quebec nonchilled
# 2:      Quebec    chilled
# 3: Mississippi nonchilled
# 4: Mississippi    chilled</code></pre>
<p>This is the closest R gets to Python’s <code>**kwargs</code> syntax.</p>
</div>
<div id="fundots" class="section level4">
<h4><span class="header-section-number">3.8.4.2</span> Writing wrapper functions</h4>
<p>When writing functions, the <code>...</code> pseudo-argument can be used to capture multiple arguments not known ahead of time, usually to pass them on to other functions. Here’s an example for browsing keyed tables (from <a href="tables.html#keys-indices">3.5.8.1</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r &lt;-<span class="st"> </span>function(d, ...) {
    <span class="co"># verify that the table has a key</span>
    <span class="kw">stopifnot</span>(<span class="kw">length</span>(<span class="kw">key</span>(d)) &gt;<span class="st"> </span>0L)

    <span class="co"># grab the tuple</span>
    tuple =<span class="st"> </span><span class="kw">list</span>(...)

    <span class="co"># join</span>
    x =<span class="st"> </span>d[tuple, nomatch=<span class="dv">0</span>]

    <span class="co"># print</span>
    <span class="kw">print</span>(<span class="dt">x =</span> x, <span class="dt">nrows=</span><span class="ot">Inf</span>, <span class="dt">row.names=</span><span class="ot">FALSE</span>)

    <span class="co"># return</span>
    <span class="kw">invisible</span>(x)
}

<span class="kw">r</span>(carbDT, <span class="st">&quot;Mc1&quot;</span>, <span class="dv">1000</span>)</code></pre></div>
<pre><code>#  Plant conc uptake
#    Mc1 1000   21.9</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_tuple =<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;Mc1&quot;</span>, <span class="dv">1000</span>)
<span class="kw">do.call</span>(r, <span class="kw">c</span>(<span class="kw">list</span>(<span class="dt">d =</span> carbDT), my_tuple))</code></pre></div>
<pre><code>#  Plant conc uptake
#    Mc1 1000   21.9</code></pre>
<p>This function is just for illustration; and I don’t mean to suggest that it’s terribly useful.</p>
</div>
<div id="program-cols" class="section level4">
<h4><span class="header-section-number">3.8.4.3</span> Specifying columns</h4>
<p>Several arguments in <code>DT[...]</code> support extended syntax for specifying columns, similar to Stata:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
exDT =<span class="st"> </span><span class="kw">data.table</span>(CO2)[<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">2</span>,<span class="dv">60</span>,<span class="dv">65</span>)]</code></pre></div>
<ul>
<li><p><code>j</code> slices</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># basic usage</span>
exDT[, <span class="kw">c</span>(<span class="st">&quot;conc&quot;</span>, <span class="st">&quot;uptake&quot;</span>)]</code></pre></div>
<pre><code>#    conc uptake
# 1:   95   16.0
# 2:  175   30.4
# 3:  350   27.9
# 4:  175   14.9</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># range</span>
exDT[, conc:uptake]</code></pre></div>
<pre><code>#    conc uptake
# 1:   95   16.0
# 2:  175   30.4
# 3:  350   27.9
# 4:  175   14.9</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># excluding with -</span>
exDT[, -<span class="kw">c</span>(<span class="st">&quot;conc&quot;</span>, <span class="st">&quot;uptake&quot;</span>)]</code></pre></div>
<pre><code>#    Plant        Type  Treatment
# 1:   Qn1      Quebec nonchilled
# 2:   Qn1      Quebec nonchilled
# 3:   Mn3 Mississippi nonchilled
# 4:   Mc1 Mississippi    chilled</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># excluding with !</span>
exDT[, !<span class="kw">c</span>(<span class="st">&quot;conc&quot;</span>, <span class="st">&quot;uptake&quot;</span>)]</code></pre></div>
<pre><code>#    Plant        Type  Treatment
# 1:   Qn1      Quebec nonchilled
# 2:   Qn1      Quebec nonchilled
# 3:   Mn3 Mississippi nonchilled
# 4:   Mc1 Mississippi    chilled</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># programming</span>
cols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;conc&quot;</span>, <span class="st">&quot;uptake&quot;</span>)
exDT[, ..cols]</code></pre></div>
<pre><code>#    conc uptake
# 1:   95   16.0
# 2:  175   30.4
# 3:  350   27.9
# 4:  175   14.9</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># programming in-line</span>
exDT[, <span class="kw">sapply</span>(exDT, is.numeric), with=<span class="ot">FALSE</span>]</code></pre></div>
<pre><code>#    conc uptake
# 1:   95   16.0
# 2:  175   30.4
# 3:  350   27.9
# 4:  175   14.9</code></pre></li>
<li><p><code>.SDcols</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># basic usage</span>
exDT[, <span class="kw">lapply</span>(.SD, max), .SDcols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;conc&quot;</span>, <span class="st">&quot;uptake&quot;</span>)]</code></pre></div>
<pre><code>#    conc uptake
# 1:  350   30.4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># range</span>
exDT[, <span class="kw">lapply</span>(.SD, max), .SDcols =<span class="st"> </span>conc:uptake]</code></pre></div>
<pre><code>#    conc uptake
# 1:  350   30.4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># conditional</span>
exDT[, <span class="kw">lapply</span>(.SD, max), .SDcols =<span class="st"> </span><span class="kw">sapply</span>(exDT, is.numeric)]</code></pre></div>
<pre><code>#    conc uptake
# 1:  350   30.4</code></pre></li>
<li><p><code>by</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># basic</span>
exDT[, .N, by=<span class="kw">c</span>(<span class="st">&quot;Plant&quot;</span>, <span class="st">&quot;Type&quot;</span>)]</code></pre></div>
<pre><code>#    Plant        Type N
# 1:   Qn1      Quebec 2
# 2:   Mn3 Mississippi 1
# 3:   Mc1 Mississippi 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># single string</span>
exDT[, .N, by=<span class="st">&quot;Plant,Type&quot;</span>]</code></pre></div>
<pre><code>#    Plant        Type N
# 1:   Qn1      Quebec 2
# 2:   Mn3 Mississippi 1
# 3:   Mc1 Mississippi 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># no quotes</span>
exDT[, .N, by=.(Plant, Type)]</code></pre></div>
<pre><code>#    Plant        Type N
# 1:   Qn1      Quebec 2
# 2:   Mn3 Mississippi 1
# 3:   Mc1 Mississippi 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># defined and labeled on-the-fly</span>
exDT[, .N, by=.(Plant, Type, <span class="dt">v =</span> conc +<span class="st"> </span>uptake)]</code></pre></div>
<pre><code>#    Plant        Type     v N
# 1:   Qn1      Quebec 111.0 1
# 2:   Qn1      Quebec 205.4 1
# 3:   Mn3 Mississippi 377.9 1
# 4:   Mc1 Mississippi 189.9 1</code></pre></li>
</ul>
<p>Column numbers also work in <code>.SDcols</code> and <code>j</code>, but don’t do that.</p>
</div>
<div id="dt-eval" class="section level4">
<h4><span class="header-section-number">3.8.4.4</span> Defining data.table calls</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
exDT =<span class="st"> </span><span class="kw">data.table</span>(CO2)[<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">2</span>,<span class="dv">60</span>,<span class="dv">65</span>)]</code></pre></div>
<p>When an <code>i</code> or <code>j</code> call in <code>DT[i, j, by]</code> must be constructed programmatically, it is best to store it as an expression and then to evaluate that expression inside <code>DT[...]</code>, for efficiency. Alternately, the entire <code>DT[...]</code> expression could be constructed and evaluated.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_bycol =<span class="st"> &quot;Type&quot;</span>
my_sumcol =<span class="st"> &quot;uptake&quot;</span>
myj =<span class="st"> </span><span class="kw">substitute</span>(<span class="kw">sum</span>(my_sumcol), <span class="kw">list</span>(<span class="dt">my_sumcol =</span> <span class="kw">as.name</span>(my_sumcol)))
myj</code></pre></div>
<pre><code># sum(uptake)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># eval j expression</span>
exDT[ , <span class="kw">eval</span>(myj), by=my_bycol]</code></pre></div>
<pre><code>#           Type   V1
# 1:      Quebec 46.4
# 2: Mississippi 42.8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># eval entire expression</span>
mycall =<span class="st"> </span><span class="kw">as.call</span>(<span class="kw">list</span>(<span class="kw">as.symbol</span>(<span class="st">&quot;[&quot;</span>), <span class="kw">as.symbol</span>(<span class="st">&quot;exDT&quot;</span>), <span class="dt">j =</span> myj, <span class="dt">by =</span> my_bycol))
mycall</code></pre></div>
<pre><code># exDT[j = sum(uptake), by = &quot;Type&quot;]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(mycall)</code></pre></div>
<pre><code>#           Type   V1
# 1:      Quebec 46.4
# 2: Mississippi 42.8</code></pre>
<p>Uglier but quicker (in terms of programming time) is to use <code>get</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exDT[, <span class="kw">sum</span>(<span class="kw">get</span>(my_sumcol)), by=my_bycol]</code></pre></div>
<pre><code>#           Type   V1
# 1:      Quebec 46.4
# 2: Mississippi 42.8</code></pre>
<p>Along with <code>get</code> for a single column, there’s <code>mget</code> for a list of them. This can be useful for update joins. Revisiting <a href="tables.html#relational-updatejoin">3.8.3</a>, we can do…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat =<span class="st"> </span><span class="kw">copy</span>(carbDT)
up_cols =<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">names</span>(plantDT), <span class="st">&quot;Plant&quot;</span>)
dat[plantDT, on=.(Plant), (up_cols) :<span class="er">=</span><span class="st"> </span><span class="kw">mget</span>(<span class="kw">sprintf</span>(<span class="st">&quot;i.%s&quot;</span>, up_cols))]</code></pre></div>
<p>The <code>setdiff</code> operator subtracts its second argument from the first, treating both as sets. See <a href="work.html#sets">4.1</a>.</p>
</div>
<div id="data.table-options" class="section level4">
<h4><span class="header-section-number">3.8.4.5</span> Data.table options</h4>
<p>The data.table package has many global options related to optimization and console output. To review them…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>() %&gt;%<span class="st"> </span>.[<span class="kw">grep</span>(<span class="st">&quot;datatable&quot;</span>, <span class="kw">names</span>(.))]</code></pre></div>
<pre><code># $datatable.alloccol
# [1] 1024
# 
# $datatable.allow.cartesian
# [1] FALSE
# 
# $datatable.auto.index
# [1] TRUE
# 
# $datatable.dfdispatchwarn
# [1] TRUE
# 
# $datatable.fread.datatable
# [1] TRUE
# 
# $datatable.fread.dec.experiment
# [1] TRUE
# 
# $datatable.fread.dec.locale
# [1] &quot;French_France.1252&quot;
# 
# $datatable.integer64
# [1] &quot;integer64&quot;
# 
# $datatable.nomatch
# [1] NA
# 
# $datatable.old.unique.by.key
# [1] FALSE
# 
# $datatable.optimize
# [1] Inf
# 
# $datatable.print.class
# [1] FALSE
# 
# $datatable.print.nrows
# [1] 100
# 
# $datatable.print.rownames
# [1] TRUE
# 
# $datatable.print.topn
# [1] 5
# 
# $datatable.showProgress
# [1] TRUE
# 
# $datatable.use.index
# [1] TRUE
# 
# $datatable.verbose
# [1] FALSE
# 
# $datatable.warnredundantby
# [1] TRUE</code></pre>
<p>Options can be set like <code>options(name = value)</code>.</p>
</div>
<div id="debugging" class="section level4">
<h4><span class="header-section-number">3.8.4.6</span> Debugging</h4>
<p>When writing complicated by-group code of the form…</p>
<pre><code>DT[, {
  ...
  do stuff
  ...
}, by=.(x, y, z)]</code></pre>
<p>I find that a convenient way to debug is to run it for the first group only:</p>
<pre><code>DT[, if (.GRP == 1L) {
  ...
  do stuff
  ...
}, by=.(x, y, z)]</code></pre>
<p>This is similar to the “dry run” approach to parsing dates (looking at only the first row or two, see <a href="tables.html#idatetime">3.6.4.1</a>). R has debugging tools like <code>debugonce</code> and <code>browser</code> as well, though they may take some getting used to for those who, like me, are not used to debugging properly.</p>

</div>
</div>
</div>
</div>
<p style="text-align: center;">
<a href="basics.html"><button class="btn btn-default">Previous</button></a>
<a href="work.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
