<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="  Quick R Tutorial" />
<meta property="og:type" content="book" />


<meta property="og:description" content="This book covers the essentials of using R." />


<meta name="author" content="Frank Erickson" />

<meta name="date" content="2017-03-27" />


<meta name="description" content="This book covers the essentials of using R.">

<title>  Quick R Tutorial</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link rel="stylesheet" href="toc.css" type="text/css" />

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
</style>
</head>

<body>

<div class="container-fluid main-container">


<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li class="has-sub"><a href="index.html#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="index.html#getting-started-with-r"><span class="toc-section-number">1.1</span> Getting started with R</a></li>
<li><a href="index.html#reading-this-book"><span class="toc-section-number">1.2</span> Reading this book</a></li>
<li><a href="index.html#about-this-book"><span class="toc-section-number">1.3</span> About this book</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#basics"><span class="toc-section-number">2</span> Basics</a><ul>
<li class="has-sub"><a href="basics.html#vectors"><span class="toc-section-number">2.1</span> Vectors</a><ul>
<li><a href="basics.html#documentation"><span class="toc-section-number">2.1.1</span> Documentation</a></li>
<li><a href="basics.html#classes"><span class="toc-section-number">2.1.2</span> Classes</a></li>
<li><a href="basics.html#making-comparisons"><span class="toc-section-number">2.1.3</span> Making comparisons</a></li>
<li><a href="basics.html#str"><span class="toc-section-number">2.1.4</span> Inspecting objects</a></li>
<li><a href="basics.html#names"><span class="toc-section-number">2.1.5</span> Named elements</a></li>
<li><a href="basics.html#na"><span class="toc-section-number">2.1.6</span> Missing values</a></li>
<li><a href="basics.html#slicing"><span class="toc-section-number">2.1.7</span> Slicing to a subvector</a></li>
<li><a href="basics.html#extract-list"><span class="toc-section-number">2.1.8</span> Extracting from a list</a></li>
<li><a href="basics.html#subassigning"><span class="toc-section-number">2.1.9</span> Assigning to a subvector</a></li>
<li><a href="basics.html#assigning-to-a-list-element"><span class="toc-section-number">2.1.10</span> Assigning to a list element</a></li>
<li><a href="basics.html#initializing"><span class="toc-section-number">2.1.11</span> Initializing</a></li>
<li><a href="basics.html#factors"><span class="toc-section-number">2.1.12</span> Factors</a></li>
<li><a href="basics.html#sort-rank-order"><span class="toc-section-number">2.1.13</span> Sorting, rank, order</a></li>
<li><a href="basics.html#testing-membership"><span class="toc-section-number">2.1.14</span> Testing membership</a></li>
<li><a href="basics.html#exercises"><span class="toc-section-number">2.1.15</span> Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#matrix-array"><span class="toc-section-number">2.2</span> Matrices and arrays</a><ul>
<li><a href="basics.html#building-matrices"><span class="toc-section-number">2.2.1</span> Building matrices</a></li>
<li><a href="basics.html#named-rows-and-columns"><span class="toc-section-number">2.2.2</span> Named rows and columns</a></li>
<li><a href="basics.html#slicing-matrix"><span class="toc-section-number">2.2.3</span> Slicing to a submatrix</a></li>
<li><a href="basics.html#matrix-extract"><span class="toc-section-number">2.2.4</span> Extracting from matrices</a></li>
<li><a href="basics.html#subassigning-to-matrices"><span class="toc-section-number">2.2.5</span> Subassigning to matrices</a></li>
<li><a href="basics.html#arrays"><span class="toc-section-number">2.2.6</span> Arrays</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#syntax"><span class="toc-section-number">2.3</span> Syntax</a><ul>
<li><a href="basics.html#assigning-to-attributes"><span class="toc-section-number">2.3.1</span> Assigning to attributes</a></li>
<li><a href="basics.html#arithmetic"><span class="toc-section-number">2.3.2</span> Arithmetic</a></li>
<li><a href="basics.html#logical-operators"><span class="toc-section-number">2.3.3</span> Logical operators</a></li>
<li><a href="basics.html#matrix-algebra"><span class="toc-section-number">2.3.4</span> Matrix algebra</a></li>
<li><a href="basics.html#order-ops"><span class="toc-section-number">2.3.5</span> Order of operations</a></li>
<li><a href="basics.html#vectorization"><span class="toc-section-number">2.3.6</span> Elementwise operations</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#functions"><span class="toc-section-number">2.4</span> Functions</a><ul>
<li><a href="basics.html#community-made-functions"><span class="toc-section-number">2.4.1</span> Community-made functions</a></li>
<li><a href="basics.html#passing-arguments"><span class="toc-section-number">2.4.2</span> Passing arguments</a></li>
<li><a href="basics.html#lapply"><span class="toc-section-number">2.4.3</span> Iterating over a list</a></li>
<li><a href="basics.html#function-writing"><span class="toc-section-number">2.4.4</span> Writing functions</a></li>
<li><a href="basics.html#scoping"><span class="toc-section-number">2.4.5</span> Scoping</a></li>
<li><a href="basics.html#lazy"><span class="toc-section-number">2.4.6</span> Lazy evaluation</a></li>
<li><a href="basics.html#function-environment"><span class="toc-section-number">2.4.7</span> Environment</a></li>
<li><a href="basics.html#default-args"><span class="toc-section-number">2.4.8</span> Default arguments</a></li>
<li><a href="basics.html#finding-a-function-by-name"><span class="toc-section-number">2.4.9</span> Finding a function by name</a></li>
<li><a href="basics.html#inspect-fns"><span class="toc-section-number">2.4.10</span> Inspecting function source code</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#loops"><span class="toc-section-number">2.5</span> Loops and control flow</a><ul>
<li><a href="basics.html#for-loops"><span class="toc-section-number">2.5.1</span> Thinking about <code>for</code> loops</a></li>
<li><a href="basics.html#ifelse"><span class="toc-section-number">2.5.2</span> <code>if</code>/<code>else</code> elementwise</a></li>
</ul></li>
<li class="has-sub"><a href="basics.html#data-frames"><span class="toc-section-number">2.6</span> Data frames</a><ul>
<li><a href="basics.html#lapply-df"><span class="toc-section-number">2.6.1</span> Iterating over columns</a></li>
<li><a href="basics.html#view"><span class="toc-section-number">2.6.2</span> Inspection</a></li>
</ul></li>
<li><a href="basics.html#built-ins"><span class="toc-section-number">2.7</span> Built-in constants</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#tables"><span class="toc-section-number">3</span> Tables</a><ul>
<li class="has-sub"><a href="tables.html#essential-packages"><span class="toc-section-number">3.1</span> Essential packages</a><ul>
<li><a href="tables.html#magrittr"><span class="toc-section-number">3.1.1</span> The magrittr package</a></li>
<li><a href="tables.html#data-table"><span class="toc-section-number">3.1.2</span> The data.table package</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-class"><span class="toc-section-number">3.2</span> The data.table class</a><ul>
<li><a href="tables.html#dt-inspect"><span class="toc-section-number">3.2.1</span> Inspecting</a></li>
<li><a href="tables.html#dt-slicing"><span class="toc-section-number">3.2.2</span> Slicing</a></li>
<li><a href="tables.html#extracting-columns"><span class="toc-section-number">3.2.3</span> Extracting columns</a></li>
<li><a href="tables.html#extensions-to-the-data.frame-class"><span class="toc-section-number">3.2.4</span> Extensions to the data.frame class</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-agg"><span class="toc-section-number">3.3</span> Aggregation</a><ul>
<li><a href="tables.html#dt-lapply"><span class="toc-section-number">3.3.1</span> Iterating over columns</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-subassign"><span class="toc-section-number">3.4</span> Modifying data</a><ul>
<li><a href="tables.html#dt-col-create"><span class="toc-section-number">3.4.1</span> Creating columns</a></li>
<li><a href="tables.html#removing-columns"><span class="toc-section-number">3.4.2</span> Removing columns</a></li>
<li><a href="tables.html#dt-replace-all"><span class="toc-section-number">3.4.3</span> Replacing entire columns</a></li>
<li><a href="tables.html#dt-ifelse"><span class="toc-section-number">3.4.4</span> Replacing columns conditionally</a></li>
<li><a href="tables.html#other-in-place-modifications"><span class="toc-section-number">3.4.5</span> Other in-place modifications</a></li>
<li><a href="tables.html#avoiding-in-place-modification"><span class="toc-section-number">3.4.6</span> Avoiding in-place modification</a></li>
<li><a href="tables.html#using-in-place-modification-in-functions"><span class="toc-section-number">3.4.7</span> Using in-place modification in functions</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#dt-joins"><span class="toc-section-number">3.5</span> Joins</a><ul>
<li><a href="tables.html#equi-joins"><span class="toc-section-number">3.5.1</span> Equi joins</a></li>
<li><a href="tables.html#subset-lookup"><span class="toc-section-number">3.5.2</span> Subset lookup</a></li>
<li><a href="tables.html#aggregating-in-a-join"><span class="toc-section-number">3.5.3</span> Aggregating in a join</a></li>
<li><a href="tables.html#joins-update"><span class="toc-section-number">3.5.4</span> Updating in a join</a></li>
<li><a href="tables.html#self-join-to-fill-in-missing-levels"><span class="toc-section-number">3.5.5</span> Self join to fill in missing levels</a></li>
<li><a href="tables.html#join-matches"><span class="toc-section-number">3.5.6</span> Handling matches</a></li>
<li><a href="tables.html#joins-nonequi"><span class="toc-section-number">3.5.7</span> Non-equi joins</a></li>
<li><a href="tables.html#shortcuts-and-tricks"><span class="toc-section-number">3.5.8</span> Shortcuts and tricks</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#input-output"><span class="toc-section-number">3.6</span> Input and output</a><ul>
<li><a href="tables.html#file-paths"><span class="toc-section-number">3.6.1</span> File paths</a></li>
<li><a href="tables.html#fread"><span class="toc-section-number">3.6.2</span> <code>fread</code> to read delimited files</a></li>
<li><a href="tables.html#rbindlist-read"><span class="toc-section-number">3.6.3</span> <code>rbindlist</code> to combine tables</a></li>
<li><a href="tables.html#dates-times"><span class="toc-section-number">3.6.4</span> Date and time columns</a></li>
<li><a href="tables.html#character-columns"><span class="toc-section-number">3.6.5</span> Character columns</a></li>
<li><a href="tables.html#dt-recode"><span class="toc-section-number">3.6.6</span> Categorical columns</a></li>
<li><a href="tables.html#list-columns"><span class="toc-section-number">3.6.7</span> List columns</a></li>
<li><a href="tables.html#fwrite"><span class="toc-section-number">3.6.8</span> <code>fwrite</code> to write delimited files</a></li>
<li><a href="tables.html#dt-saveload"><span class="toc-section-number">3.6.9</span> Saving and loading R objects</a></li>
<li><a href="tables.html#reading-and-writing-other-formats"><span class="toc-section-number">3.6.10</span> Reading and writing other formats</a></li>
<li><a href="tables.html#formatting-the-display-of-columns"><span class="toc-section-number">3.6.11</span> Formatting the display of columns</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#exploring-data"><span class="toc-section-number">3.7</span> Exploring data</a><ul>
<li><a href="tables.html#browse-env"><span class="toc-section-number">3.7.1</span> Browsing loaded objects</a></li>
<li><a href="tables.html#dt-subset"><span class="toc-section-number">3.7.2</span> Subsetting</a></li>
<li><a href="tables.html#sorting"><span class="toc-section-number">3.7.3</span> Sorting</a></li>
<li><a href="tables.html#explore-onevar"><span class="toc-section-number">3.7.4</span> Examining each variable</a></li>
<li><a href="tables.html#explore-vars"><span class="toc-section-number">3.7.5</span> Examining variables jointly</a></li>
<li><a href="tables.html#dcast"><span class="toc-section-number">3.7.6</span> Reshaping to wide</a></li>
</ul></li>
<li class="has-sub"><a href="tables.html#structuring-data"><span class="toc-section-number">3.8</span> Organizing relational tables</a><ul>
<li><a href="tables.html#melt"><span class="toc-section-number">3.8.1</span> Reshaping to long format</a></li>
<li><a href="tables.html#choosing-tables-and-keys"><span class="toc-section-number">3.8.2</span> Choosing tables and keys</a></li>
<li><a href="tables.html#listing-levels"><span class="toc-section-number">3.8.3</span> Listing levels</a></li>
<li><a href="tables.html#exploring-levels"><span class="toc-section-number">3.8.4</span> Exploring levels</a></li>
<li><a href="tables.html#aggregate-join"><span class="toc-section-number">3.8.5</span> Collapsing</a></li>
<li><a href="tables.html#expanding"><span class="toc-section-number">3.8.6</span> Expanding</a></li>
<li><a href="tables.html#update-joins"><span class="toc-section-number">3.8.7</span> Update joins</a></li>
<li><a href="tables.html#programming-data.table-calls"><span class="toc-section-number">3.8.8</span> Programming data.table calls</a></li>
<li><a href="tables.html#bad-aggregations"><span class="toc-section-number">3.8.9</span> Bad aggregations</a></li>
</ul></li>
</ul></li>
<li class="has-sub"><a href="work.html#work"><span class="toc-section-number">4</span> Getting work done</a><ul>
<li><a href="work.html#sets-and-combinations"><span class="toc-section-number">4.1</span> Sets and combinations</a></li>
<li class="has-sub"><a href="work.html#randomization"><span class="toc-section-number">4.2</span> Randomization</a><ul>
<li><a href="work.html#distribution-draws"><span class="toc-section-number">4.2.1</span> Distribution draws</a></li>
<li><a href="work.html#urn-draws"><span class="toc-section-number">4.2.2</span> Urn draws</a></li>
<li><a href="work.html#permutations"><span class="toc-section-number">4.2.3</span> Permutations</a></li>
<li><a href="work.html#simulations"><span class="toc-section-number">4.2.4</span> Simulations</a></li>
</ul></li>
<li class="has-sub"><a href="work.html#sequences"><span class="toc-section-number">4.3</span> Working with sequences</a><ul>
<li><a href="work.html#lag"><span class="toc-section-number">4.3.1</span> Lag operators</a></li>
<li><a href="work.html#taking-differences"><span class="toc-section-number">4.3.2</span> Taking differences</a></li>
<li><a href="work.html#rolling-computations"><span class="toc-section-number">4.3.3</span> Rolling computations</a></li>
<li><a href="work.html#run-length-encoding"><span class="toc-section-number">4.3.4</span> Run-length encoding</a></li>
<li><a href="work.html#grouping-on-runs"><span class="toc-section-number">4.3.5</span> Grouping on runs</a></li>
</ul></li>
<li><a href="work.html#combining-table-columns"><span class="toc-section-number">4.4</span> Combining table columns</a></li>
<li class="has-sub"><a href="work.html#reg"><span class="toc-section-number">4.5</span> Regression</a><ul>
<li><a href="work.html#extracting-results"><span class="toc-section-number">4.5.1</span> Extracting results</a></li>
</ul></li>
<li><a href="work.html#optimization"><span class="toc-section-number">4.6</span> Optimization</a></li>
<li><a href="work.html#integration"><span class="toc-section-number">4.7</span> Integration</a></li>
<li><a href="work.html#strings"><span class="toc-section-number">4.8</span> String operations</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="tables" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Tables</h1>
<p>This chapter covers navigating tabular data with R. The core syntax is (<a href="tables.html#dt-syntax">3.2.4.3</a>):</p>
<pre><code>DT[where, select|update|do, by] # SQL verbs
DT[i, j, by]                    # R function arguments</code></pre>
<p>It reads as:</p>
<ol style="list-style-type: decimal">
<li>Subset using <code>i</code>, then</li>
<li>Group using <code>by</code>, then</li>
<li>Do <code>j</code></li>
</ol>
<div id="essential-packages" class="section level2">
<h2><span class="header-section-number">3.1</span> Essential packages</h2>
<p>This section covers packages that help me work more efficiently, to the point where I regard them as essential. They’ll be used throughout the rest of this document. They don’t have any dependencies on other packages, and I expect they’ll be available as long as R is. It will be assumed in subsequent sections that these libraries have been attached:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)
<span class="kw">library</span>(data.table)</code></pre></div>
<div id="magrittr" class="section level3">
<h3><span class="header-section-number">3.1.1</span> The magrittr package</h3>
<p><a href="https://cran.r-project.org/package=magrittr">Magrittr</a> introduces syntax with “pipes,” improving readability by unnesting function calls:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># we can do</span>
x %&gt;%<span class="st"> </span>f %&gt;%<span class="st"> </span>g %&gt;%<span class="st"> </span>h
<span class="co"># instead of </span>
<span class="kw">h</span>(<span class="kw">g</span>(<span class="kw">f</span>(x)))</code></pre></div>
<p>In addition, it allows more compact function definitions (<a href="basics.html#function-writing">2.4.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fun =<span class="st"> </span>. %&gt;%<span class="st"> </span>.^<span class="dv">2</span> %&gt;%<span class="st"> </span>sum %&gt;%<span class="st"> </span>sqrt
<span class="kw">fun</span>(<span class="dv">1</span>:<span class="dv">3</span>)</code></pre></div>
<pre><code># [1] 3.741657</code></pre>
<p>Despite these advantages, magrittr can slow down code, so avoid using it anywhere where speed might be an issue.</p>
<p>To install, just use CRAN:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&#39;magrittr&#39;</span>)</code></pre></div>
<p>The name is a pun on <a href="https://en.wikipedia.org/wiki/The_Treachery_of_Images">René Magritte’s pipe painting</a>. To get a handle on the package, I would start with the package <a href="https://CRAN.R-project.org/package=magrittr/vignettes/magrittr.html">vignette</a>.</p>
</div>
<div id="data-table" class="section level3">
<h3><span class="header-section-number">3.1.2</span> The data.table package</h3>
<p><a href="http://r-datatable.com">Data.table</a> offers a variant of the <code>data.frame</code> class for data frames (seen in <a href="basics.html#data-frames">2.6</a>), optimized for fast sorted and grouped operations and enhanced with cleaner syntax. Section <a href="tables.html#dt-class">3.2</a> introduces this <code>data.table</code> class.</p>
<p>The package also bundles in a variety of other functionality:</p>
<ul>
<li>ITime and IDate date and time classes</li>
<li><code>fread</code> and <code>fwrite</code> for fast reading and writing of delimited files</li>
<li><code>dcast</code> and <code>melt</code> for reshaping tables</li>
</ul>
<p>Because these disparate features are bundled together in data.table, we don’t have to load more packages and worry about their complicated dependencies or namespace conflicts (<a href="basics.html#namespaces">2.4.1.3</a>).</p>
<div id="installation" class="section level4">
<h4><span class="header-section-number">3.1.2.1</span> Installation</h4>
<p>Again, CRAN can be used:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&#39;data.table&#39;</span>)</code></pre></div>
<p>However, the package is under active development, with new features available only in the development version. To install it, follow <a href="https://github.com/Rdatatable/data.table/wiki/Installation">the instructions from the package wiki</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">remove.packages</span>(<span class="st">&quot;data.table&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;data.table&quot;</span>, <span class="dt">type =</span> <span class="st">&quot;source&quot;</span>,
  <span class="dt">repos =</span> <span class="st">&quot;http://Rdatatable.github.io/data.table&quot;</span>)</code></pre></div>
<p>If using Windows, you’ll need to first install <a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a> (requiring administrator privileges), as explained in the last link.</p>
</div>
<div id="getting-started" class="section level4">
<h4><span class="header-section-number">3.1.2.2</span> Getting started</h4>
<p>The official vignettes for the package are a great way to start with the package. See them on the <a href="http://r-datatable.com/Getting-started">wiki</a> or with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">browseVignettes</span>(<span class="dt">package=</span><span class="st">&quot;data.table&quot;</span>)</code></pre></div>
<p>(Beware that as of March 2017, the website vignettes are somewhat out-of-date.) The website also includes links to other useful materials (an online course, presentation materials, blog posts). Before using the package, I started by reading some slides and the FAQ in full.</p>
</div>
</div>
</div>
<div id="dt-class" class="section level2">
<h2><span class="header-section-number">3.2</span> The data.table class</h2>
<p>Data.tables extend the data frame class introduced in <a href="basics.html#data-frames">2.6</a>.</p>
<p>This section reviews basic operations seen in the last chapter (inspecting, slicing, extracting), before discussing how <code>data.table</code> extends <code>data.frame</code>.</p>
<div id="dt-inspect" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Inspecting</h3>
<p>Consider the <code>quakes</code> data set (with more info in <code>?quakes</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT =<span class="st"> </span><span class="kw">data.table</span>(quakes)</code></pre></div>
<pre><code>#          lat   long depth mag stations
#    1: -20.42 181.62   562 4.8       41
#    2: -20.62 181.03   650 4.2       15
#    3: -26.00 184.10    42 5.4       43
#    4: -17.97 181.66   626 4.1       19
#    5: -20.42 181.96   649 4.0       11
#   ---                                 
#  996: -25.93 179.54   470 4.4       22
#  997: -12.28 167.06   248 4.7       35
#  998: -20.13 184.20   244 4.5       34
#  999: -17.40 187.80    40 4.5       14
# 1000: -21.59 170.56   165 6.0      119</code></pre>
<p>By default, data.tables with over 100 rows will print in the compressed form seen above, showing just the first and last five rows. To globally change how many rows are needed, use <code>options(datatable.print.nrows = n)</code>. To override it a single time, use <code>print</code> with <code>nrows=</code>. I usually set <code>nrows=Inf</code> to print all rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT %&gt;%<span class="st"> </span><span class="kw">print</span>(<span class="dt">nrow =</span> <span class="ot">Inf</span>)</code></pre></div>
<p>To browse a table in a new window, <code>View</code> for data frames (<a href="basics.html#view">2.6.2</a>) again works:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT %&gt;%<span class="st"> </span>View
<span class="co"># or if using RStudio</span>
quakeDT %&gt;%<span class="st"> </span>utils::<span class="kw">View</span>()</code></pre></div>
<p>To inspect the structure of a data.table, we can again use <code>str</code> (<a href="basics.html#str">2.1.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quakeDT %&gt;%<span class="st"> </span>str</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    1000 obs. of  5 variables:
#  $ lat     : num  -20.4 -20.6 -26 -18 -20.4 ...
#  $ long    : num  182 181 184 182 182 ...
#  $ depth   : int  562 650 42 626 649 195 82 194 211 622 ...
#  $ mag     : num  4.8 4.2 5.4 4.1 4 4 4.8 4.4 4.7 4.3 ...
#  $ stations: int  41 15 43 19 11 12 43 15 35 19 ...
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Here, we see the class of each column along with the first few values. In addition, there is an obscure <code>&quot;.internal.selfref&quot;</code> attribute, which we can ignore except when saving or loading the table from disk (<a href="tables.html#dt-saveload">3.6.9</a>). Other attributes will sometimes also show up here, related to optimizing the performance of ordered or grouped queries on the table (<a href="tables.html#keys-indices">3.5.8.1</a>).</p>
<p>In the code above, we could use syntax like <code>View(quakeDT)</code> instead of <code>quakeDT %&gt;% View</code>, but I often find the latter handier, since it’s easy to insert intermediate steps, like <code>quakeDT %&gt;% head(10) %&gt;% View</code>. Also, while <code>%&gt;%</code> is slow, it’s not going to matter for tasks like browsing data.</p>
</div>
<div id="dt-slicing" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Slicing</h3>
<p>A slice of a data.table is a smaller data.table formed by subsetting rows, columns, or both, analogous to vector and matrix slices seen in <a href="basics.html#slicing">2.1.7</a> and <a href="basics.html#slicing-matrix">2.2.3</a>. The remaining columns will retain attributes from the full table (class, levels for factors, etc.).</p>
<p>The syntax is familiar from vectors and matrices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[<span class="dv">1</span>:<span class="dv">2</span>, ]</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, <span class="st">&quot;z&quot;</span>]</code></pre></div>
<pre><code>#        z
# 1: FALSE
# 2: FALSE
# 3: FALSE
# 4:  TRUE
# 5:  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[-<span class="dv">3</span>, <span class="kw">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)]</code></pre></div>
<pre><code>#    y     z
# 1: 1 FALSE
# 2: 2 FALSE
# 3: 4  TRUE
# 4: 5  TRUE</code></pre>
<p>One difference with matrices is that when only slicing rows, we can skip the comma:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[<span class="dv">1</span>:<span class="dv">2</span>]</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE</code></pre>
<p>Other differences come into play when subsetting columns programmatically, where we need either a <code>..</code> prefix…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">keep_cols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)
DT[, keep_cols]                  <span class="co"># error</span></code></pre></div>
<pre><code># Error in `[.data.table`(DT, , keep_cols): j (the 2nd argument inside [...]) is a single symbol but column name &#39;keep_cols&#39; is not found. Perhaps you intended DT[,..keep_cols] or DT[,keep_cols,with=FALSE]. This difference to data.frame is deliberate and explained in FAQ 1.1.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, ..keep_cols]                <span class="co"># use this instead</span></code></pre></div>
<pre><code>#    y     z
# 1: 1 FALSE
# 2: 2 FALSE
# 3: 3 FALSE
# 4: 4  TRUE
# 5: 5  TRUE</code></pre>
<p>… or <code>with=FALSE</code> if programming inline:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, letters[<span class="dv">25</span>:<span class="dv">26</span>]]             <span class="co"># no error, but doesn&#39;t print what we want</span></code></pre></div>
<pre><code># [1] &quot;y&quot; &quot;z&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, letters[<span class="dv">25</span>:<span class="dv">26</span>], with=<span class="ot">FALSE</span>] <span class="co"># use this instead</span></code></pre></div>
<pre><code>#    y     z
# 1: 1 FALSE
# 2: 2 FALSE
# 3: 3 FALSE
# 4: 4  TRUE
# 5: 5  TRUE</code></pre>
<p>These requirements are a quirk of the more flexible <code>DT[...]</code> syntax that supports far more than taking slices, as discussed in <a href="tables.html#dt-syntax">3.2.4.3</a>.</p>

<div class="rmd-caution">
<strong>Use column names, not numbers.</strong> Subsetting by hard-coded column number, like <code>DT[, 2:3]</code> or <code>cols = 2:3; DT[, ..cols]</code> works but is discouraged. Column numbers can easily change in the course of writing or updating a script, invalidating column number references in a way that will be annoying to debug. See the first answer in <code>vignette(&quot;datatable-faq&quot;)</code> for a deeper discussion.
</div>
<p></p>

<div class="rmd-details">
<strong>How data frame slicing works.</strong> This is really getting in the weeds, since I suggest not using data frames at all, but you’ll see two major differences if you do. First, <code>DT[, &quot;z&quot;]</code> will extract the <code>z</code> column instead of taking a slice thanks to data frames’ <code>drop=TRUE</code> default (which also came up regarding matrices in the last chapter). Second, <code>DT[1:2]</code> will slice the first two <em>columns</em> instead of the first two rows, thanks to the fact that data frames (and data.tables) are lists and the no-comma usage of <code>[</code> triggers list slicing.
</div>
<p></p>
<p><code>head</code>, <code>tail</code> and the special empty and missing-data slices (all seen in the last chapter) work by row:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(DT, -<span class="dv">3</span>)    <span class="co"># top, removing last 3</span></code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(DT, <span class="dv">2</span>)     <span class="co"># bottom 2</span></code></pre></div>
<pre><code>#    x y    z
# 1: d 4 TRUE
# 2: e 5 TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[0L]          <span class="co"># empty </span></code></pre></div>
<pre><code># Empty data.table (0 rows) of 3 cols: x,y,z</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[<span class="ot">NA_integer_</span>] <span class="co"># missing</span></code></pre></div>
<pre><code>#     x  y  z
# 1: NA NA NA</code></pre>
<p>The package also offers <code>first</code> and <code>last</code>, which are simply special cases of <code>head</code> and <code>tail</code>.</p>
<p>Fancier slicing methods, like <code>DT[x &gt; &quot;b&quot;, .(y, z)]</code>, will be introduced with the rest of the <code>DT[...]</code> syntax in <a href="tables.html#dt-syntax">3.2.4.3</a>.</p>
<p>There are some syntactical shortcuts for slicing to a set of columns in <code>j</code>; see <a href="tables.html#program-cols">3.8.8.1</a>.</p>
</div>
<div id="extracting-columns" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Extracting columns</h3>
<p>Since data.tables (and data frames) are lists, we can extract columns like <code>DT$z</code> or <code>DT[[&quot;z&quot;]]</code>.</p>
<p>With the full <code>DT[...]</code> syntax (<a href="tables.html#dt-syntax">3.2.4.3</a>), it is easy to extract a column for a limited set of rows, like <code>DT[x &gt; &quot;b&quot;, z]</code>.</p>
</div>
<div id="extensions-to-the-data.frame-class" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Extensions to the data.frame class</h3>
<p>The first thing to note is that data.tables <em>are</em> data frames, so any function that works on a data frame will work fine with data.tables, too (even if the data.table package is not installed or attached).</p>
<div id="modification-in-place" class="section level4">
<h4><span class="header-section-number">3.2.4.1</span> Modification in-place</h4>
<p>In contrast with the rest of R, data.tables are primarily modified “in-place” (or “by reference”), which can be much more efficient. As a first example, we can switch the class of a data frame to data.table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DF =<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DF)</code></pre></div>
<pre><code># &#39;data.frame&#39;: 5 obs. of  3 variables:
#  $ x: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
#  $ y: num  1 2 3 4 5
#  $ z: logi  FALSE FALSE FALSE TRUE TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setDT</span>(DF)
<span class="kw">str</span>(DF)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    5 obs. of  3 variables:
#  $ x: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
#  $ y: num  1 2 3 4 5
#  $ z: logi  FALSE FALSE FALSE TRUE TRUE
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>We did not use <code>=</code> or <code>&lt;-</code> to assign the result of <code>setDT</code>; the function simply altered <code>DF</code> in-place. All of data.table’s functions named like <code>set*</code> do this.</p>

<div class="rmd-details">
<strong>R’s copy-on-modify.</strong> Understanding the contrast between modification in-place and base R’s modification rules (often called “copy-on-modify”) probably requires some familiarity with C (see threads on <a href="http://stackoverflow.com/questions/15759117/what-exactly-is-copy-on-modify-semantics-in-r-and-where-is-the-canonical-source">stackoverflow</a> or <a href="http://r.789695.n4.nabble.com/Confused-about-NAMED-td4103326.html">the mailing list</a> if interested). I wouldn’t worry about it except to note that many base R operations make copies, which is costly in terms of RAM and computing time; while those operations’ data.table counterparts do not have this problem.
</div>
<p></p>
</div>
<div id="dt-factorvchar" class="section level4">
<h4><span class="header-section-number">3.2.4.2</span> Factor vs character columns</h4>
<p>Another difference is that <code>data.frame(...)</code> reads string input as a <code>factor</code> categorical variable (<a href="basics.html#factors">2.1.12</a>), as seen in the <code>str</code> output above; while <code>data.table(...)</code> reads it as character:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)
<span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    5 obs. of  3 variables:
#  $ x: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
#  $ y: num  1 2 3 4 5
#  $ z: logi  FALSE FALSE FALSE TRUE TRUE
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Data frames’ preference for factors may still bite when reading files in with <code>read.table</code> from base R instead of <code>fread</code> from data.table (<a href="tables.html#fread">3.6.2</a>).</p>
</div>
<div id="dt-syntax" class="section level4">
<h4><span class="header-section-number">3.2.4.3</span> Extended syntax for <code>DT[...]</code> </h4>
<p>The third major difference is the extension of the <code>DT[...]</code> syntax to support more than simple slices (like <code>DF[i,j]</code>, where <code>i</code> and <code>j</code> as indices, covered in <a href="tables.html#dt-slicing">3.2.2</a>). It offers SQL-style syntax that is cleaner, particularly for by-group operations:</p>
<pre><code># (pseudocode)
DT[where, select|update|do, by] # SQL verbs
DT[i, j, by]                    # R function arguments</code></pre>
<p>This should be read as a command to take a sequence of steps:</p>
<ol style="list-style-type: decimal">
<li>Subset using <code>i</code></li>
<li>Group using <code>by</code></li>
<li>Do <code>j</code></li>
</ol>
<p>We can use column names as barewords, and even form expressions in terms of columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[x &gt;<span class="st"> &quot;b&quot;</span>, <span class="kw">sum</span>(y), by=z]</code></pre></div>
<pre><code>#        z V1
# 1: FALSE  3
# 2:  TRUE  9</code></pre>
<p>Typically, the <code>i</code> and <code>j</code> arguments are called by position, as seen here; while <code>by=</code> is called by name.</p>
<p>Whenever <code>j</code> evaluates to a list, the output will be a new data.table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[x &gt;<span class="st"> &quot;b&quot;</span>, .(<span class="dt">n_bigy =</span> <span class="kw">sum</span>(y &gt;<span class="st"> </span><span class="dv">2</span>), <span class="dt">n_smally =</span> <span class="kw">sum</span>(y &lt;=<span class="st"> </span><span class="dv">2</span>)), by=z]</code></pre></div>
<pre><code>#        z n_bigy n_smally
# 1: FALSE      1        0
# 2:  TRUE      2        0</code></pre>

<div class="rmd-caution">
<strong>The <code>.()</code> convenience function.</strong> Inside many arguments of <code>DT[...]</code>, we can use the shorthand <code>.()</code>, which stands for <code>list()</code>.
</div>
<p></p>
<p>The use of <code>by=</code> is very similar to a <code>for</code> loop (<a href="basics.html#for-loops">2.5.1</a>) over subsets, but it is better in a few important ways:</p>
<ul>
<li>We don’t have to manually construct and keep track of some “split-up data” list to iterate over.</li>
<li>Fast by-group functions are used when available (see <code>?GForce</code>)</li>
<li>We don’t have to define the task in <code>j</code> as a function of prespecified variables – we can just use any columns of the data.table.</li>
<li>We don’t have to worry about intermediate variables (like <code>case</code> in the next example) contaminating the global environment.</li>
</ul>
<p>There are some syntactical shortcuts for writing a list of columns in <code>by=</code>; see <a href="tables.html#program-cols">3.8.8.1</a>.</p>
</div>
<div id="an-example" class="section level4">
<h4><span class="header-section-number">3.2.4.4</span> An example</h4>
<p>The task in <code>j</code> can really be anything. Just as a demonstration of its power, here’s how it can be used for saving per-group plots to a PDF:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>

bwDT =<span class="st"> </span><span class="kw">data.table</span>(MASS::birthwt)

<span class="kw">pdf</span>(<span class="dt">file=</span><span class="st">&quot;birthweight_graphs.pdf&quot;</span>)
bwDT[, {
  case =<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;high #visits? = %s, smoking? = %s&quot;</span>, .BY$high_vis, .BY$smoke)
  
  <span class="kw">cat</span>(<span class="st">&quot;Handling&quot;</span>, case, <span class="st">&quot;...</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">plot</span>(
    age ~<span class="st"> </span>lwt, 
    <span class="dt">main =</span> case
  )  
}, by=.(<span class="dt">high_vis =</span> ftv &gt;=<span class="st"> </span><span class="dv">1</span>, smoke)]</code></pre></div>
<pre><code># Handling high #visits? = FALSE, smoking? = 0 ...</code></pre>
<pre><code># Handling high #visits? = TRUE, smoking? = 0 ...</code></pre>
<pre><code># Handling high #visits? = TRUE, smoking? = 1 ...</code></pre>
<pre><code># Handling high #visits? = FALSE, smoking? = 1 ...</code></pre>
<pre><code># Empty data.table (0 rows) of 2 cols: high_vis,smoke</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dev.off</span>()</code></pre></div>
<pre><code># png 
#   2</code></pre>
<p>Plotting graphs is beyond the scope of this document, but the example above should make intuitive sense after reading the docs for each object, <code>?MASS::birthwt</code>, <code>?pdf</code>, et al. For each group, we’re formatting a string with <code>sprintf</code>; printing it with <code>cat</code>; and saving a plot. The special symbol <code>.BY</code> is a list containing the per-group values of the <code>by=</code> variables. Formatting and printing strings will be covered more in <a href="work.html#strings">4.8</a>.</p>

<div class="rmd-caution">
<strong>Filtering on logical columns.</strong> <code>DT[z]</code> and <code>DT[!z]</code> will give errors, for design reasons related to the syntax for joins (<a href="tables.html#dt-joins">3.5</a>). To get around this, always wrap the column in parentheses: <code>DT[(z)]</code> and <code>DT[!(z)]</code>.
</div>
<p></p>

<div class="rmd-caution">
<strong>Grouping on floats.</strong> Much of the computational and syntactical magic of the package comes from grouping rows together with the <code>by=</code> argument. To group on a floating-point variable, however, is just asking for trouble, <a href="http://floating-point-gui.de/">for the usual numerical computing reasons</a>. Instead, always use characters, integers or factors. To discretise a continuous variable into bins, use <code>cut</code>.
</div>
<p></p>

<div class="rmd-details">
<strong>Verbose data.table messages.</strong> To learn how data.table queries work, I recommend toggling the setting <code>options(datatable.verbose = TRUE)</code>. This option is similar to verbose output from an optimization call (reporting the value of the objective at each iteration, etc.). To only see verbose output for a single call, add <code>verbose = TRUE</code>. For example,<code>DT[x &gt; &quot;b&quot;, sum(y), by=z, verbose=TRUE]</code>.
</div>
<p></p>
</div>
</div>
</div>
<div id="dt-agg" class="section level2">
<h2><span class="header-section-number">3.3</span> Aggregation</h2>
<p>The mtcars data set (see <code>?mtcars</code>) has two categorical variables:</p>
<ul>
<li><code>am</code> for automatic (0) or manual (1) transmission; and</li>
<li><code>vs</code> for v (0) or straight (1) engine shape.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
carsDT =<span class="st"> </span><span class="kw">data.table</span>(mtcars, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)
<span class="co"># quick inspection</span>
<span class="kw">first</span>(carsDT)</code></pre></div>
<pre><code>#           rn mpg cyl disp  hp drat   wt  qsec vs am gear carb
# 1: Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4</code></pre>
<p>Suppose we want to compare the mean horsepower, <code>hp</code>, across these categories:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .(<span class="dt">mean_hp =</span> <span class="kw">mean</span>(hp)), by=.(am, vs)]</code></pre></div>
<pre><code>#    am vs   mean_hp
# 1:  1  0 180.83333
# 2:  1  1  80.57143
# 3:  0  1 102.14286
# 4:  0  0 194.16667</code></pre>
<p>So, we just write <code>j</code> of <code>DT[i,j,by]</code> as an expression to compute the summary statistic, optionally giving it a name by wrapping in <code>.(name = expression)</code>.</p>
<p>Sections <a href="tables.html#explore-onevar">3.7.4</a> and <a href="tables.html#explore-vars">3.7.5</a> cover more options for exploring data with summary statistics; and <a href="tables.html#dcast">3.7.6</a> shows how to put this result in wide format (with, e.g., <code>am</code> on rows and <code>vs</code> on columns).</p>
<div id="dt-lapply" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Iterating over columns</h3>
<p>Now suppose we want to compare mean horsepower, weight and displacement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## carsDT[, .(mean_hp = mean(hp), mean_wt = mean(wt), mean_disp = mean(disp)), by=.(am, vs)]
## # can be simplified to...
carsDT[, <span class="kw">lapply</span>(.SD, mean), by=.(am, vs), .SDcols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;hp&quot;</span>, <span class="st">&quot;wt&quot;</span>, <span class="st">&quot;disp&quot;</span>)]</code></pre></div>
<pre><code>#    am vs        hp       wt     disp
# 1:  1  0 180.83333 2.857500 206.2167
# 2:  1  1  80.57143 2.028286  89.8000
# 3:  0  1 102.14286 3.194286 175.1143
# 4:  0  0 194.16667 4.104083 357.6167</code></pre>
<p>So, we just write the relevant columns in <code>.SDcols</code> and refer to <code>.SD</code>, the <em><strong>S</strong>ubset of <strong>D</strong>ata</em>. Within each <code>by=</code> group, the query has access to <code>.SD</code> with rows for that group and columns as specified in <code>.SDcols</code>. <code>.SD</code>, like <code>.BY</code> seen earlier, is a special symbol available in some arguments of <code>DT[...]</code>, documented at <code>?.SD</code>.</p>
<p>We can use <code>lapply</code> (a function designed for iterating over lists) here since <code>.SD</code> is a data.table, which is a list of column vectors (see <a href="basics.html#lapply-df">2.6.1</a>). The column names carry over to the result because <code>lapply</code> always carries over names.</p>
<p>While dot notation <code>.SDcols=.(hp, wt, disp)</code> is not yet supported, there are a variety of convenience features for specifying <code>.SDcols</code>, covered in <a href="tables.html#program-cols">3.8.8.1</a>.</p>

<div class="rmd-caution">
<strong>“Aggregating” across columns.</strong> One major red flag to look out for is the desire to “aggregate” columns by row, setting <code>by=1:nrow(DT)</code> and possibly using <code>unlist(.SD)</code> somewhere. Not only will this be incredibly slow, but it also suggests that the data is poorly organized, costing a lot of extra mental energy at every step. Section <a href="tables.html#structuring-data">3.8</a> explains some ways to format data better to avoid the need for this problematic approach.
</div>
<p></p>
</div>
</div>
<div id="dt-subassign" class="section level2">
<h2><span class="header-section-number">3.4</span> Modifying data</h2>
<p>Creating, editing and removing columns are all done using <code>:=</code> in <code>j</code> of <code>DT[i, j, by]</code>. This functionality operates in-place, in the sense that the underlying data stays in the same place, which is more efficient in terms of how much RAM and time is taken. See <code>vignette(&quot;datatable-reference-semantics&quot;)</code> for details.</p>

<div class="rmd-details">
<strong>What can be modified in-place?</strong> The scope of in-place operations is currently limited to altering columns. Adding and removing rows in-place is not yet supported; it is harder to do in R, due to its column-oriented storage of tables (contrasting with database systems that store data rowwise for easy INSERT and DELETE queries).
</div>
<p></p>
<div id="dt-col-create" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Creating columns</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(
  <span class="dt">x =</span> letters[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)], 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>) &gt;<span class="st"> </span><span class="dv">3</span>
)</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE
# 3: c 3 FALSE
# 4: d 4  TRUE
# 5: e 5  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creating a column</span>
DT[, u :<span class="er">=</span><span class="st"> </span><span class="dv">5</span>:<span class="dv">1</span>][]</code></pre></div>
<pre><code>#    x y     z u
# 1: a 1 FALSE 5
# 2: b 2 FALSE 4
# 3: c 3 FALSE 3
# 4: d 4  TRUE 2
# 5: e 5  TRUE 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creating multiple</span>
DT[, <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(<span class="dt">v =</span> <span class="dv">2</span>, <span class="dt">w =</span> 3L)][]</code></pre></div>
<pre><code>#    x y     z u v w
# 1: a 1 FALSE 5 2 3
# 2: b 2 FALSE 4 2 3
# 3: c 3 FALSE 3 2 3
# 4: d 4  TRUE 2 2 3
# 5: e 5  TRUE 1 2 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creating with dynamic names</span>
nms =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
DT[, (nms) :<span class="er">=</span><span class="st"> </span>.(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)][]</code></pre></div>
<pre><code>#    x y     z u v w a b c
# 1: a 1 FALSE 5 2 3 1 2 3
# 2: b 2 FALSE 4 2 3 1 2 3
# 3: c 3 FALSE 3 2 3 1 2 3
# 4: d 4  TRUE 2 2 3 1 2 3
# 5: e 5  TRUE 1 2 3 1 2 3</code></pre>
<p>All of these tasks are performed in-place – altering <code>DT</code> without making a new object. Usually, the results are not printed in the console; but they appear here because <code>[]</code> is “chained” onto the end of each task.</p>

<div class="rmd-caution">
<strong><code>:=</code> is the function <em>creation, modification and deletion</em> of columns.</strong> This will be covered it more detail in subsequent sections, but is worth emphasising. In particular, this contrasts with Stata (which uses distinct verbs <code>gen</code>, <code>replace</code> and <code>drop</code>).
</div>
<p></p>

<div class="rmd-details">
<strong>Iterative column creation.</strong> The <code>`:=`(...)</code> syntax does <em>not</em> support iterative definitions like <code>DT[, `:=`(W1 = u + y, W2 = W1^2)]</code>. One common workaround is <code>DT[, `:=`(W1 = W1 &lt;- u + y, W2 = W1^2)]</code>. This solution may not be intuitive for new R users, but the gist is: <code>W1 &lt;- u + y</code> creates <code>W1</code> as an object in <code>DT[...]</code> and then returns its value, let’s call it <code>v</code>. Now, <code>W2 = W1^2</code> can find <code>W1</code>, since it was created by <code>&lt;-</code>; and <code>W1 = W1 &lt;- u + y</code> simplifies to <code>W1 &lt;- v</code>, where <code>v</code> is the return value of <code>W1 &lt;- u + y</code>.
</div>
<p></p>
</div>
<div id="removing-columns" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Removing columns</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nms =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;v&quot;</span>, <span class="st">&quot;w&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
DT[, (nms) :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span>][]</code></pre></div>
<pre><code>#    x y     z
# 1: a 1 FALSE
# 2: b 2 FALSE
# 3: c 3 FALSE
# 4: d 4  TRUE
# 5: e 5  TRUE</code></pre>
<p>A warning will print if we remove some columns that don’t currently exist.</p>
</div>
<div id="dt-replace-all" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Replacing entire columns</h3>
<p>Data.table is careful about column types:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span>10L ][]  <span class="co"># Create a new column of integers</span></code></pre></div>
<pre><code>#    x y     z  a
# 1: a 1 FALSE 10
# 2: b 2 FALSE 10
# 3: c 3 FALSE 10
# 4: d 4  TRUE 10
# 5: e 5  TRUE 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span>21L ][]  <span class="co"># Replace it with another column of integers</span></code></pre></div>
<pre><code>#    x y     z  a
# 1: a 1 FALSE 21
# 2: b 2 FALSE 21
# 3: c 3 FALSE 21
# 4: d 4  TRUE 21
# 5: e 5  TRUE 21</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span><span class="fl">32.5</span> ][] <span class="co"># Replace it with a float</span></code></pre></div>
<pre><code># Warning in `[.data.table`(DT, , `:=`(a, 32.5)): Coerced &#39;double&#39; RHS to &#39;integer&#39; to
# match the column&#39;s type; may have truncated precision. Either change the target column
# to &#39;double&#39; first (by creating a new &#39;double&#39; vector length 5 (nrows of entire table)
# and assign that; i.e. &#39;replace&#39; column), or coerce RHS to &#39;integer&#39; (e.g. 1L, NA_[real|
# integer]_, as.*, etc) to make your intent clear and for speed. Or, set the column type
# correctly up front when you create the table and stick to it, please.</code></pre>
<pre><code>#    x y     z  a
# 1: a 1 FALSE 32
# 2: b 2 FALSE 32
# 3: c 3 FALSE 32
# 4: d 4  TRUE 32
# 5: e 5  TRUE 32</code></pre>
<p>The warning in the last call is related to coercion of vector classes (<a href="basics.html#classes">2.1.2</a>).</p>

<div class="rmd-details">
<p><strong>Safeguards against accidental coercion.</strong> The verbose warning printed above is typical for the package and an excellent feature. Running the final command, data.table knows that the <code>a</code> column is of integer type and sees that 32.5 is conspiciously <em>not an integer</em>. So it gives a warning when coercing 32.5 to an integer (to match <code>a</code>).</p>
Elsewhere in R, <code>a</code> would be coerced to match the float <code>32.5</code> – probably not the behavior we want – with no warning. That is, if we have <code>x &lt;- c(21L, 22L)</code>, we can freely assign <code>x[1] &lt;- 32.5</code>; and the same freedom (by which I mean “danger”) is present even if <code>x</code> is a data frame column. For more on the issue, search online for “type safety.”
</div>
<p></p>
<p>If we want this assignment to work, we need to change <code>a</code>’s type by passing a full vector, as described in the warning:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, a :<span class="er">=</span><span class="st"> </span><span class="kw">rep</span>(<span class="fl">32.5</span>, .N) ][]</code></pre></div>
<pre><code>#    x y     z    a
# 1: a 1 FALSE 32.5
# 2: b 2 FALSE 32.5
# 3: c 3 FALSE 32.5
# 4: d 4  TRUE 32.5
# 5: e 5  TRUE 32.5</code></pre>
<p>The coercion is done silently, but it can be made more visible by turning on <code>verbose</code>, which notes the “plonk” of a full vector replacement. <code>.N</code> is a special symbol for the number of rows (or the number of rows in a subset when <code>i</code> or <code>by=</code> is present).</p>
</div>
<div id="dt-ifelse" class="section level3">
<h3><span class="header-section-number">3.4.4</span> Replacing columns conditionally</h3>
<p>Conditional replacement here is analogous to a SQL UPDATE query or a replace if command in Stata. To illustrate, we will look again at a vectorized <code>if</code>/<code>else</code> assignment, mentioned in <a href="basics.html#ifelse">2.5.2</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[     , b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>] <span class="co"># initialize to baseline value</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> &quot;Zebra&quot;</span>][] <span class="co"># replace based on a condition</span></code></pre></div>
<pre><code>#    x y     z    a        b
# 1: a 1 FALSE 32.5 Aardvark
# 2: b 2 FALSE 32.5    Zebra
# 3: c 3 FALSE 32.5    Zebra
# 4: d 4  TRUE 32.5    Zebra
# 5: e 5  TRUE 32.5    Zebra</code></pre>
<p>This can also be done with chaining:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>][y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> &quot;Zebra&quot;</span>]</code></pre></div>
<p>This chaining works because <code>DT[...][...]</code> is evaluated like <code>(DT[...])[...]</code> and the return value of the piece in parentheses is <code>DT</code> – provided <code>j</code> has a <code>:=</code> statement.</p>

<div class="rmd-caution">
<strong>Broken chains.</strong> If <code>j</code> is not a <code>:=</code> statement, the return value is not the original data.table but rather a new one. Subsequent steps in the chain will not affect the starting table. So, after <code>DT[y &lt; Inf, d := 1]</code> and <code>DT[y &lt; Inf][, d := 2]</code>, what does the <code>d</code> column look like in <code>DT</code>? See the Exercise section of <code>vignette(&quot;datatable-reference-semantics&quot;)</code>; and the Note section of <code>?`:=`</code>.
</div>
<p></p>
<p>As we saw in the last section, partial replacement of a column will trigger a warning if the classes don’t match:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>][y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> </span><span class="dv">111</span>]</code></pre></div>
<pre><code># Warning in `[.data.table`(DT[, `:=`(b, &quot;Aardvark&quot;)], y &gt; 1, `:=`(b, 111)): Coerced
# &#39;double&#39; RHS to &#39;character&#39; to match the column&#39;s type; may have truncated precision.
# Either change the target column to &#39;double&#39; first (by creating a new &#39;double&#39; vector
# length 5 (nrows of entire table) and assign that; i.e. &#39;replace&#39; column), or coerce RHS
# to &#39;character&#39; (e.g. 1L, NA_[real|integer]_, as.*, etc) to make your intent clear and for
# speed. Or, set the column type correctly up front when you create the table and stick to
# it, please.</code></pre>
<p>Another nice feature, similar to Stata, is reporting of the number of rows modified. This can be seen by turning <code>verbose</code> on:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, b :<span class="er">=</span><span class="st"> &quot;Aardvark&quot;</span>][y &gt;<span class="st"> </span><span class="dv">1</span>, b :<span class="er">=</span><span class="st"> &quot;Zebra&quot;</span>, verbose =<span class="st"> </span><span class="ot">TRUE</span>]</code></pre></div>
<pre><code># Detected that j uses these columns: b 
# Assigning to 4 row subset of 5 rows</code></pre>
</div>
<div id="other-in-place-modifications" class="section level3">
<h3><span class="header-section-number">3.4.5</span> Other in-place modifications</h3>
<p>The data.table package has a few other tools for modifying table attributes in-place:</p>
<ul>
<li><p>The <code>set</code> function is another way of making assignments like <code>:=</code>.</p></li>
<li><p><code>setDT</code> and <code>setDF</code>, seen earlier, alter the class.</p></li>
<li><p><code>setorder</code> will sort the table by some or all of its columns.</p></li>
<li><p><code>setcolorder</code> changes the order in which columns are displayed.</p></li>
<li><p>Indices and the key (explained in <a href="tables.html#keys-indices">3.5.8.1</a>) can be set with <code>setindex</code> and <code>setkey</code>, respectively.</p></li>
<li><p><code>setnames</code> will alter column names. For example, in <a href="tables.html#dt-lapply">3.3.1</a> we saw…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, <span class="kw">lapply</span>(.SD, mean), by=.(am, vs), .SDcols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;hp&quot;</span>, <span class="st">&quot;wt&quot;</span>, <span class="st">&quot;disp&quot;</span>)]</code></pre></div>
<pre><code>#    am vs        hp       wt     disp
# 1:  1  0 180.83333 2.857500 206.2167
# 2:  1  1  80.57143 2.028286  89.8000
# 3:  0  1 102.14286 3.194286 175.1143
# 4:  0  0 194.16667 4.104083 357.6167</code></pre>
<p>… and if we want to add the prefix <code>&quot;mean_&quot;</code> to the results, we can do</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cols =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;hp&quot;</span>, <span class="st">&quot;wt&quot;</span>, <span class="st">&quot;disp&quot;</span>)
carsDT[, <span class="kw">lapply</span>(.SD, mean), by=.(am, vs), .SDcols =<span class="st"> </span>cols] %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">setnames</span>(cols, <span class="kw">sprintf</span>(<span class="st">&quot;mean_%s&quot;</span>, cols)) %&gt;%<span class="st"> </span>print</code></pre></div>
<pre><code>#    am vs   mean_hp  mean_wt mean_disp
# 1:  1  0 180.83333 2.857500  206.2167
# 2:  1  1  80.57143 2.028286   89.8000
# 3:  0  1 102.14286 3.194286  175.1143
# 4:  0  0 194.16667 4.104083  357.6167</code></pre>
<p>The trailing <code>%&gt;% print</code> command is used because, <code>setnames</code>, like <code>:=</code> and the other <code>set*</code> operators, does not print the table on its own. The string-formatter <code>sprintf</code> will be explained in <a href="work.html#strings">4.8</a>.</p></li>
<li><p><code>setattr</code> is a general function for altering attributes of a vector or other object (see <code>?attributes</code>). For example, if we have a factor column (encoding categorical data), we can change its “levels”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
fDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">fac =</span> <span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>)))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(fDT$fac)</code></pre></div>
<pre><code># [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fDT$fac %&gt;%<span class="st"> </span><span class="kw">setattr</span>(<span class="st">&quot;levels&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;Q&quot;</span>))
<span class="kw">levels</span>(fDT$fac)</code></pre></div>
<pre><code># [1] &quot;A&quot; &quot;B&quot; &quot;Q&quot;</code></pre></li>
</ul>
</div>
<div id="avoiding-in-place-modification" class="section level3">
<h3><span class="header-section-number">3.4.6</span> Avoiding in-place modification</h3>
<p>To create a new data.table starting from an existing table, use</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT2 =<span class="st"> </span><span class="kw">copy</span>(DT1)</code></pre></div>
<p>We have to use this instead of <code>DT2 = DT1</code> since with the latter we have only created a new “pointer” to the first table. I routinely make copies like this after reading in data (<a href="tables.html#fread">3.6.2</a>) so that I can back out where I tripped over something in the process of data cleaning.</p>
<p>Besides <code>DT2 = DT1</code>, <code>names1 = names(DT1)</code> is also unsafe, since the <code>names</code> function does not extract the column names as they are at a given time, but rather points at the names attribute, which can change as columns are modified or rearranged.</p>
</div>
<div id="using-in-place-modification-in-functions" class="section level3">
<h3><span class="header-section-number">3.4.7</span> Using in-place modification in functions</h3>
<p>A user-written function (<a href="basics.html#function-writing">2.4.4</a>) like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(DT) DT[, newcol :<span class="er">=</span><span class="st"> </span><span class="dv">1111</span> ]</code></pre></div>
<p>will act like <code>:=</code> and the <code>set*</code> functions, altering its input in-place. This can be useful, but requires extra caution. See the “<code>:=</code> for its side effect” section of <code>vignette(&quot;datatable-reference-semantics&quot;)</code> for discussion.</p>
</div>
</div>
<div id="dt-joins" class="section level2">
<h2><span class="header-section-number">3.5</span> Joins</h2>
<p>They are called “joins” or “merges.”</p>
<div id="equi-joins" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Equi joins</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
a =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(1L, 1L, 2L, 3L, <span class="ot">NA_integer_</span>), <span class="dt">t =</span> <span class="kw">c</span>(1L, 2L, 1L, 2L, <span class="ot">NA_integer_</span>), <span class="dt">x =</span> <span class="dv">11</span>:<span class="dv">15</span>)</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  1  2 12
# 3:  2  1 13
# 4:  3  2 14
# 5: NA NA 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">y =</span> <span class="kw">c</span>(11L, 15L))</code></pre></div>
<pre><code>#    id  y
# 1:  1 11
# 2:  2 15</code></pre>
<p>The idiom for a simple equi join is <code>x[i, on=.(...)]</code> or <code>x[i]</code> for short:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id)]</code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  1 2 12 11
# 3:  2 1 13 15</code></pre>
<p>It is called an equi join since we are only getting matches where equality holds between the <code>on=</code> columns in the two tables.</p>
<p>Think of <code>x[i]</code> as using index table <code>i</code> to look up rows of <code>x</code>, in the same way an “index matrix” can look up elements of a matrix (<a href="basics.html#matrix-extract">2.2.4</a>). By default, we see results for every row of <code>i</code>, even those that are unmatched.</p>
<p>Here are some more complicated examples:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(<span class="dt">x =</span> y)]</code></pre></div>
<pre><code>#    id  t  x i.id
# 1:  1  1 11    1
# 2: NA NA 15    2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id, <span class="dt">x =</span> y)]</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  2 NA 15</code></pre>
<p>When merging on columns with different names, they must be written in <code>on=</code> like <code>x = y</code> where <code>x</code> is from the “left” table, and <code>y</code> from the “right” one. Because we are using <code>i</code> to lookup rows in <code>x</code>, the displayed column will have its name from <code>x</code> and its values from <code>i</code>.</p>
<p>A character vector also works in, e.g., <code>on=c(&quot;id&quot;, x = &quot;y&quot;)</code>, making it easier to merge programmatically.</p>
</div>
<div id="subset-lookup" class="section level3">
<h3><span class="header-section-number">3.5.2</span> Subset lookup</h3>
<p>For browsing dynamic data (that grows over time), it is convenient and quick to use joins:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[.(1L), on=.(id)]</code></pre></div>
<pre><code>#    id t  x
# 1:  1 1 11
# 2:  1 2 12</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or, as a function</span>
ra &lt;-<span class="st"> </span>function(my_id) a[.(my_id), on=.(id)] 
<span class="kw">ra</span>(2L)</code></pre></div>
<pre><code>#    id t  x
# 1:  2 1 13</code></pre>
<p>Note that the index <code>i</code> is a list here, not a data.table. The link between the two is close, since data.tables are just lists of columns (<a href="tables.html#dt-lapply">3.3.1</a>). Any list passed in <code>i</code> will be treated the same as the analogous data.table with appropriate column names.</p>
<p>Subset browsing becomes even easier when keys are set so that <code>on=</code> can be skipped (<a href="tables.html#keys-indices">3.5.8.1</a>).</p>
</div>
<div id="aggregating-in-a-join" class="section level3">
<h3><span class="header-section-number">3.5.3</span> Aggregating in a join</h3>
<p>Looking again at the first join above, suppose we want to use <code>b</code> to find rows in <code>a</code> and then add up <code>a$x</code>. We’ll do this by using <code>by=.EACHI</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id)]</code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  1 2 12 11
# 3:  2 1 13 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), <span class="kw">sum</span>(x), by=.EACHI]</code></pre></div>
<pre><code>#    id V1
# 1:  1 23
# 2:  2 13</code></pre>
<p>It is called “each <code>i</code>” since the syntax is <code>x[i, ...]</code> and we are computing per row of the index <code>i</code>. I prefer to write the <code>on=</code> before the <code>j</code> (unlike the core syntax of <code>DT[i,j,by]</code>) since the <code>on=</code> merging columns are closely related to the <code>i</code> index.</p>
<p>If we tried summing <code>b$y</code> here, we would not get <code>11+11</code> for <code>id</code> 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id)] <span class="co"># y shows up twice</span></code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  1 2 12 11
# 3:  2 1 13 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), .(<span class="kw">sum</span>(x), <span class="kw">sum</span>(y)), by=.EACHI] <span class="co"># we only get one y</span></code></pre></div>
<pre><code>#    id V1 V2
# 1:  1 23 11
# 2:  2 13 15</code></pre>
<p>This is because we are working by each row of <code>b</code>. For <code>id</code> 1 in <code>b</code>, <code>y</code> is a single value, <code>11</code>. So really there is no point in summing <code>y</code> or otherwise aggregating columns from <code>i</code> when using <code>by=.EACHI</code>.</p>
</div>
<div id="joins-update" class="section level3">
<h3><span class="header-section-number">3.5.4</span> Updating in a join</h3>
<p>Continuing from the last example, we are computing <code>sum(x)</code> per row of <code>b</code>, so maybe we want to save the result as a column in <code>b</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b[, sumx :<span class="er">=</span><span class="st"> </span>
<span class="st">    </span>a[b, on=.(id), <span class="kw">sum</span>(x), by=.EACHI]$V1
]
<span class="co"># or</span>
b[, sumx :<span class="er">=</span><span class="st"> </span>
<span class="st">    </span>a[.SD, on=.(id), <span class="kw">sum</span>(x), by=.EACHI]$V1
]</code></pre></div>
<pre><code>#    id  y sumx
# 1:  1 11   23
# 2:  2 15   13</code></pre>

<div class="rmd-caution">
<strong>Default names for <code>j</code> computations.</strong> When the task in <code>j</code> evaluates to an unnamed list, default names <code>V1, V2, ...</code> are assigned. We can use these to extract a single computed column with <code>$V1</code>, <code>$V2</code>, etc. Since we can only extract one column at a time, we usually only create and extract a single column, auto-named <code>V1</code>.
</div>
<p></p>
<p>On the other hand, we may want to take values from <code>b</code> and assign them to the larger table <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), y :<span class="er">=</span><span class="st"> </span>i.y ]</code></pre></div>
<pre><code>#    id  t  x  y
# 1:  1  1 11 11
# 2:  1  2 12 11
# 3:  2  1 13 15
# 4:  3  2 14 NA
# 5: NA NA 15 NA</code></pre>
<p>This sort of operation is very common when doing analysis with well-organized relational data, and will come up again in <a href="tables.html#structuring-data">3.8</a>. It is essentially the same as a SQL UPDATE JOIN. It might also be called a “merge assign” (though I seem to be the only one using that term).</p>
<p>The <code>i.*</code> prefix in <code>i.y</code> indicates that we are taking the column from the <code>i</code> table in <code>x[i]</code>. We can similarly use an <code>x.*</code> prefix for columns from <code>x</code>. This helps to disambiguate if the same column names appear in both tables, and is particularly helpful with non-equi joins (<a href="tables.html#joins-nonequi">3.5.7</a>). I recommend always using <code>i.*</code> prefixes when copying columns in an update join.</p>

<div class="rmd-caution">
<strong>Beware multiple matches in an update join.</strong> When there are multiple matches (<a href="tables.html#join-multimatch">3.5.6.1</a>), an update join will apparently only use the last one. <a href="https://github.com/Rdatatable/data.table/issues/2022">Unfortunately</a>, this is done silently. Try <code>b[a, on=.(id), x := i.x, verbose = TRUE ][]</code>. With <code>verbose</code> on, we see a helpful message about assignment “to 3 row subset of 2 rows.”
</div>
<p></p>
</div>
<div id="self-join-to-fill-in-missing-levels" class="section level3">
<h3><span class="header-section-number">3.5.5</span> Self join to fill in missing levels</h3>
<p>Consider the <code>a</code> data set from above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span></code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  1  2 12
# 3:  2  1 13
# 4:  3  2 14
# 5: NA NA 15</code></pre>
<p>Now we want to “complete” the data set so that every <code>id</code> has a row for every time <code>t</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[<span class="kw">CJ</span>(<span class="dt">id =</span> id, <span class="dt">t =</span> t, <span class="dt">unique=</span><span class="ot">TRUE</span>), on=.(id, t)]</code></pre></div>
<pre><code>#     id  t  x
#  1: NA NA 15
#  2: NA  1 NA
#  3: NA  2 NA
#  4:  1 NA NA
#  5:  1  1 11
#  6:  1  2 12
#  7:  2 NA NA
#  8:  2  1 13
#  9:  2  2 NA
# 10:  3 NA NA
# 11:  3  1 NA
# 12:  3  2 14</code></pre>
<p>This is called a self join because we are using the table’s own columns in <code>i</code> of <code>x[i, on=]</code>. The <code>CJ</code> function is a helper that takes all combinations of vectors, alternately called the Cartesian product or a “cross join.” By applying <code>unique=TRUE</code>, we treat each vector <em>as a set</em> in the mathematical sense, only considering distinct values.</p>
<p>Notice that missing values (<code>NA</code>) in <code>i</code> are treated in the same way as other values.</p>
</div>
<div id="join-matches" class="section level3">
<h3><span class="header-section-number">3.5.6</span> Handling matches</h3>
<p>For this section, we’ll reset the tables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
a =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(1L, 1L, 2L, 3L, <span class="ot">NA_integer_</span>), <span class="dt">t =</span> <span class="kw">c</span>(1L, 2L, 1L, 2L, <span class="ot">NA_integer_</span>), <span class="dt">x =</span> <span class="dv">11</span>:<span class="dv">15</span>)</code></pre></div>
<pre><code>#    id  t  x
# 1:  1  1 11
# 2:  1  2 12
# 3:  2  1 13
# 4:  3  2 14
# 5: NA NA 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">y =</span> <span class="kw">c</span>(11L, 15L))</code></pre></div>
<pre><code>#    id  y
# 1:  1 11
# 2:  2 15</code></pre>
<div id="join-multimatch" class="section level4">
<h4><span class="header-section-number">3.5.6.1</span> Handling multiply-matched rows</h4>
<p>In <code>a[b, on=.(id)]</code>, we are indexing by rows of <code>b</code> and so get matches for every row of <code>b</code>. By default, we get <em>all</em> matches in <code>a</code>, but this can be tweaked:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[b, on=.(id), mult=<span class="st">&quot;first&quot;</span>]</code></pre></div>
<pre><code>#    id t  x  y
# 1:  1 1 11 11
# 2:  2 1 13 15</code></pre>
<p>Now each row of <code>b</code> only returns the first matching row (from the top) in <code>a</code>. Similarly, we could select <code>mult=&quot;last&quot;</code>.</p>
</div>
<div id="handling-unmatched-rows" class="section level4">
<h4><span class="header-section-number">3.5.6.2</span> Handling unmatched rows</h4>
<p>Flipping it around, if we use <code>a</code> to index <code>b</code>, we have some index rows from <code>a</code> that don’t have any matches in <code>b</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b[a, on=.(id)]</code></pre></div>
<pre><code>#    id  y  t  x
# 1:  1 11  1 11
# 2:  1 11  2 12
# 3:  2 15  1 13
# 4:  3 NA  2 14
# 5: NA NA NA 15</code></pre>
<p>These unmatched rows still show up in the result, which is usually nice. However, this behavior can also be tweaked:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b[a, on=.(id), nomatch=<span class="dv">0</span>]</code></pre></div>
<pre><code>#    id  y t  x
# 1:  1 11 1 11
# 2:  1 11 2 12
# 3:  2 15 1 13</code></pre>
<p>Dropping unmatched elements of <code>i</code> is similar to filtering <code>_m == 3</code> in Stata.</p>

<div class="rmd-details">
<strong>Diagnostics for merges.</strong> In Stata, joins report on how well they went – did everything match? how many didn’t match? The analogous question for an <code>x[i]</code> join is – for each row of <code>i</code>, how many matches did we find in <code>x</code>? To see the answer, use <code>b[a, on=.(id), .N, by=.EACHI]</code>.
</div>
 
<div class="rmd-details">
<p><strong>Comparison with Stata.</strong> Because <code>x[i]</code> uses <code>i</code> to look up rows in <code>x</code>, we are never looking ar rows that correspond to Stata’s <code>_m == 1</code> – that belong to <code>x</code> but are not matched by <code>i</code>.</p>
There is another way of merging, <code>merge(b, a)</code>, that allows for <code>all.x</code> and <code>all.y</code>, resembling Stata’s options, but I have never found any reason to use it.
</div>
<p></p>
</div>
<div id="handling-imperfect-matches-with-rolling-joins" class="section level4">
<h4><span class="header-section-number">3.5.6.3</span> Handling imperfect matches with rolling joins</h4>
<p>Sometimes we want unmatched rows paired with the closest match occurring earlier or later in the table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># target x</span>
myxDT =<span class="st"> </span><span class="kw">list</span>(<span class="dt">myx =</span> <span class="kw">c</span>(5L, 10L, 15L, 20L))

<span class="co"># exact match (equi-join)</span>
a[myxDT, on=.(<span class="dt">x =</span> myx), .(i.myx, x.x)]</code></pre></div>
<pre><code>#    i.myx x.x
# 1:     5  NA
# 2:    10  NA
# 3:    15  15
# 4:    20  NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># nearest match</span>
a[myxDT, on=.(<span class="dt">x =</span> myx), roll=<span class="st">&quot;nearest&quot;</span>, .(i.myx, x.x)]</code></pre></div>
<pre><code>#    i.myx x.x
# 1:     5  11
# 2:    10  11
# 3:    15  15
# 4:    20  15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># upward match within 3</span>
a[myxDT, on=.(<span class="dt">x =</span> myx), roll=-<span class="dv">3</span>, .(i.myx, x.x)]</code></pre></div>
<pre><code>#    i.myx x.x
# 1:     5  NA
# 2:    10  11
# 3:    15  15
# 4:    20  NA</code></pre>
<p>Recall from <a href="tables.html#joins-update">3.5.4</a> that the <code>i.*</code> and <code>x.*</code> prefixes refer to where columns come from in <code>x[i]</code>.</p>
<p>When joining on multiple columns, the roll is taken on the last listed in <code>on=</code>.</p>
<p>The value of <code>roll=</code> refers to how much higher or lower the value of <code>x</code> can be and still qualify as a match. We add (up to) <code>roll</code> to the target row if necessary to find a match. So <code>roll = -3</code> means we would accept a <code>x</code> as far away as <code>x - 3 = myx</code>.</p>
</div>
</div>
<div id="joins-nonequi" class="section level3">
<h3><span class="header-section-number">3.5.7</span> Non-equi joins</h3>
<p>It is sometimes useful to match on a range of values. To do this, we explicitly name all columns in <code>i</code> and define inequalities in <code>on=</code>. Suppose we want to see, for every time <code>t</code> in 1..5, how many individuals were seen in the preceding three days:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">x_dn =</span> 10L, <span class="dt">x_up =</span> 13L)</code></pre></div>
<pre><code>#    id i.x_dn i.x_up x.x
# 1:  1     10     13  11
# 2:  1     10     13  12
# 3:  2     10     13  13
# 4:  3     10     13  NA</code></pre>
<p>So we are defining a range <code>x_dn</code> to <code>x_up</code> for each <code>id</code> and finding all matches of <code>x</code> within the range.</p>
<p>These could alternately be called “interval joins.” For more on interval joins and subsets, see <code>?inrange</code>, <code>?foverlaps</code> and the <a href="http://www.bioconductor.org/packages/IRanges/">IRanges package</a> that inspired these data.table tools.</p>
</div>
<div id="shortcuts-and-tricks" class="section level3">
<h3><span class="header-section-number">3.5.8</span> Shortcuts and tricks</h3>
<p>When joining on a single character or factor column, the <code>.()</code> in <code>i</code> can be skipped:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dt">u =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">v =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>))
DT[<span class="st">&quot;A&quot;</span>, on=.(id)]</code></pre></div>
<pre><code>#    id u v
# 1:  A 0 1
# 2:  A 1 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## # instead of
## DT[.(&quot;A&quot;), on=.(id)]</code></pre></div>
<div id="keys-indices" class="section level4">
<h4><span class="header-section-number">3.5.8.1</span> Setting keys and indices</h4>
<p>If a table is always joined on the same column(s), these can be set as its “key.” Setting the key of <code>x</code> sorts the table and allows for skipping <code>on=</code> during <code>x[i,on=]</code> joins. It also can have some performance benefits. See <code>?setkey</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(DT, id)
DT[<span class="st">&quot;A&quot;</span>]</code></pre></div>
<pre><code>#    id u v
# 1:  A 0 1
# 2:  A 1 4</code></pre>
<p>This can be dangerous, however, since even if <code>i</code> has names, they are ignored:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(DT, u, v)
DT[.(<span class="dt">v =</span> <span class="dv">7</span>, <span class="dt">u =</span> <span class="dv">2</span>)]</code></pre></div>
<pre><code>#    id u v
# 1: NA 7 2</code></pre>
<p>No match is found here since <code>i=.(v = 7, u = 2)</code> is mapped to the key <code>.(u,v)</code> by position and not by name.</p>
<p>Most of the performance benefits of a key can also be achieved with an “index.” Unlike a key, which sorts the table, an index simply notes the order of the table with respect to some columns. A table can have many indices, but only one key:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setindex</span>(DT, id, u)
<span class="kw">setindex</span>(DT, id, v)
## key(DT)
## indices(DT, vectors=TRUE)
## str(DT)</code></pre></div>
<p>The performance benefits show up in most joins and some subsetting operations, too. Turn on <code>verbose</code> data.table messages to see when it is and is not kicking in. Also see <code>vignette(&quot;datatable-secondary-indices-and-auto-indexing&quot;)</code>; and regarding whether setting a key is important (as some old tutorials might say), see the package developer’s <a href="https://github.com/Rdatatable/data.table/issues/1232#issuecomment-131190268">post</a>.</p>
<p>Keys and indices are destroyed whenever any of their columns are edited in a way that won’t obviously preserve order.</p>

<div class="rmd-details">
<strong>Attribute verification.</strong> Keys and indices are simply stored as attributes and may be invalid. For example, with <code>DT = data.table(id = 2:1, v = 2:1); setattr(DT, &quot;sorted&quot;, &quot;id&quot;)</code>, we’ve told the table that it is sorted by <code>id</code> even though it isn’t. Some functions may check the validity of the key, but others won’t, like <code>DT[.(1L)]</code>.
</div>
<p></p>
</div>
<div id="anti-joins" class="section level4">
<h4><span class="header-section-number">3.5.8.2</span> Anti joins</h4>
<p>We also have the option of selecting <em>unmatched</em> rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[!b, on=.(id)]</code></pre></div>
<pre><code>#    id  t  x
# 1:  3  2 14
# 2: NA NA 15</code></pre>
<p>This “not join” or “anti join” returns all rows of <code>a</code> that are not matched by rows in <code>b</code>.</p>
</div>
</div>
</div>
<div id="input-output" class="section level2">
<h2><span class="header-section-number">3.6</span> Input and output</h2>
<p>This section covers reading tables from disk; basic cleaning of column formats; and writing to disk.</p>
<div id="file-paths" class="section level3">
<h3><span class="header-section-number">3.6.1</span> File paths</h3>
<p>Don’t provide paths with backslashes, like <code>&quot;C:\data\input.csv&quot;</code>, since <code>\</code> is special character in R. My workaround is to use forward slashes or construct the path using <code>file.path</code>.</p>
<ul>
<li>For a list of files and folders, use <code>dir</code> or <code>list.files</code>.</li>
<li>For relative paths, <code>&quot;.&quot;</code> is the current folder; <code>&quot;..&quot;</code> navigates one level up; and <code>normalizePath</code> converts to an absolute path.</li>
<li>For the current path, use <code>getwd</code>; and to alter it, <code>setwd(new_path)</code>.</li>
<li>To extract parts of a path, use, e.g., <code>file_ext</code> from the tools package (included in the base R installation).</li>
</ul>
<p>For functions to manipulate files, see <code>?files</code> and <code>?dir.create</code>; and for file attributes, <code>?file.info</code>.</p>
</div>
<div id="fread" class="section level3">
<h3><span class="header-section-number">3.6.2</span> <code>fread</code> to read delimited files</h3>
<p>To read tables from CSVs or other delimited formats, <code>fread</code> is quite fast and reliable:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;file.csv&quot;</span>)</code></pre></div>
<p>See <code>?fread</code> and <a href="https://github.com/Rdatatable/data.table/wiki/Convenience-features-of-fread">the wiki</a> for a discussion of features. I usually find that <code>fread</code> just works without any need for tweaks. However, it currently doesn’t recognize date or time formats, which need to be handled after reading (<a href="tables.html#dates-times">3.6.4</a>).</p>
</div>
<div id="rbindlist-read" class="section level3">
<h3><span class="header-section-number">3.6.3</span> <code>rbindlist</code> to combine tables</h3>
<p>To read and combine several tables with the same columns, <code>rbindlist</code> is the right tool. The short approach is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rbindlist</span>(<span class="kw">lapply</span>(<span class="kw">list.files</span>(<span class="dt">patt=</span><span class="st">&quot;csv$&quot;</span>), fread), <span class="dt">id=</span><span class="ot">TRUE</span>)
<span class="co"># or...</span>
<span class="kw">list.files</span>(<span class="dt">patt=</span><span class="st">&quot;csv$&quot;</span>) %&gt;%<span class="st"> </span><span class="kw">lapply</span>(fread) %&gt;%<span class="st"> </span><span class="kw">rbindlist</span>(<span class="dt">id=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>The rest of this section covers the longer approach I recommend, using a table with one row per file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>

<span class="co"># example data</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
for (i in <span class="dv">1</span>:<span class="dv">3</span>) 
  <span class="kw">fwrite</span>(<span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">v =</span> <span class="kw">sample</span>(letters, <span class="dv">2</span>)), <span class="dt">file =</span> <span class="kw">sprintf</span>(<span class="st">&quot;file201%s.csv&quot;</span>, i))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># First, identify the files wanted:</span>
fileDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">fn =</span> <span class="kw">list.files</span>(<span class="dt">pattern=</span><span class="st">&quot;csv$&quot;</span>))

<span class="co"># Next, optionally parse the names for metadata using regex:</span>
fileDT[, year :<span class="er">=</span><span class="st"> </span><span class="kw">type.convert</span>(<span class="kw">sub</span>(<span class="st">&quot;.*([0-9]{4}).*&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1&quot;</span>, fn))]

<span class="co"># Finally construct a string file-ID column:</span>
fileDT[, id :<span class="er">=</span><span class="st"> </span><span class="kw">as.character</span>(.I)][]</code></pre></div>
<pre><code>#              fn year id
# 1: file2011.csv 2011  1
# 2: file2012.csv 2012  2
# 3: file2013.csv 2013  3</code></pre>
<p>From here, read in the files as a new column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fileDT[, contents :<span class="er">=</span><span class="st"> </span>.(<span class="kw">lapply</span>(fn, fread))][]</code></pre></div>
<pre><code>#              fn year id     contents
# 1: file2011.csv 2011  1 &lt;data.table&gt;
# 2: file2012.csv 2012  2 &lt;data.table&gt;
# 3: file2013.csv 2013  3 &lt;data.table&gt;</code></pre>
<p>Then, combine them for the final table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span>fileDT[, <span class="kw">rbindlist</span>(<span class="kw">setNames</span>(contents, id), <span class="dt">idcol=</span><span class="st">&quot;file_id&quot;</span>)]

<span class="co"># Perhaps add in metadata using an update join</span>
DT[fileDT, on=.(<span class="dt">file_id =</span> id), year :<span class="er">=</span><span class="st"> </span>i.year ][]</code></pre></div>
<pre><code>#    file_id id v year
# 1:       1  1 g 2011
# 2:       1  2 j 2011
# 3:       2  1 o 2012
# 4:       2  2 w 2012
# 5:       3  1 f 2013
# 6:       3  2 w 2013</code></pre>
<p>Results can be debugged by investigating individual files like <code>fileDT[year == 2012, contents[[1]]]</code>. The <code>setNames</code> function (<a href="basics.html#names">2.1.5</a>) is needed here since <code>rbindlist</code> uses names to populate the id column.</p>
</div>
<div id="dates-times" class="section level3">
<h3><span class="header-section-number">3.6.4</span> Date and time columns</h3>
<p>Currently, <code>fread</code> does not recognize or translate time or date columns to native R formats.</p>
<p>I recommend a couple packages, anytime and nanotime, for use when needed (more on which below). They have minimal dependencies and are maintained with an eye towards continued compatibility with the data.table package.</p>
<div id="date-and-time-of-day-separately" class="section level4">
<h4><span class="header-section-number">3.6.4.1</span> Date and time of day, separately</h4>
<p>I usually handle this using the formats provided with data.table, <code>IDate</code> and <code>ITime</code>, for date and time of day:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">d =</span> <span class="kw">c</span>(<span class="st">&quot;2017/01/21&quot;</span>, <span class="st">&quot;2017/01/22&quot;</span>), <span class="dt">t =</span> <span class="kw">c</span>(<span class="st">&quot;5:50&quot;</span>, <span class="st">&quot;13:50&quot;</span>))</code></pre></div>
<pre><code>#    id          d     t
# 1:  1 2017/01/21  5:50
# 2:  2 2017/01/22 13:50</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  3 variables:
#  $ id: int  1 2
#  $ d : chr  &quot;2017/01/21&quot; &quot;2017/01/22&quot;
#  $ t : chr  &quot;5:50&quot; &quot;13:50&quot;
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(
  <span class="dt">d =</span> <span class="kw">as.IDate</span>(d),
  <span class="dt">t =</span> <span class="kw">as.ITime</span>(t)
)][]</code></pre></div>
<pre><code>#    id          d        t
# 1:  1 2017-01-21 05:50:00
# 2:  2 2017-01-22 13:50:00</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  3 variables:
#  $ id: int  1 2
#  $ d : IDate, format: &quot;2017-01-21&quot; &quot;2017-01-22&quot;
#  $ t :Class &#39;ITime&#39;  int [1:2] 21000 49800
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>In the <code>str</code> output, we can see that ITime is stored as an integer, and the same is true of IDate. This is more efficient than a floating-point class in terms of storage and many table operations.</p>
<p>In this example, the <code>as.*</code> functions immediately recognize how to interpret the strings given. In many cases, however, we need to pass a format parameter, like <code>as.IDate(&quot;01/13/2013&quot;, &quot;%m/%d/%Y&quot;)</code>. See <code>?strptime</code> and <code>?as.Date</code> for documentation on how to do this. Because it’s hard to get the format right the first time, I usually test a format out like…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[1L, <span class="kw">as.IDate</span>(d, <span class="st">&quot;%Y%M%D&quot;</span>)] </code></pre></div>
<p>This is similar to the <code>dryrun</code> option in Nick Cox’s numdate package for Stata.</p>
<p>Parsing dates and times by tweaking format strings can be mind-numbing, so it’s worth considering loading <a href="http://dirk.eddelbuettel.com/code/anytime.html">the anytime package</a>, which will automatically recognize many more formats than <code>as.IDate</code> and <code>as.ITime</code> normally will.</p>
</div>
<div id="datetimes" class="section level4">
<h4><span class="header-section-number">3.6.4.2</span> Datetimes</h4>
<p>Data.table also can parse a datetime string (well, a factor) into separate IDate and ITime columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">dt =</span> <span class="st">&quot;2017-01-01 01:11&quot;</span>)
DT[, <span class="kw">c</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;t&quot;</span>) :<span class="er">=</span><span class="st"> </span><span class="kw">IDateTime</span>(<span class="kw">as.factor</span>(dt))][]</code></pre></div>
<pre><code>#                  dt          d        t
# 1: 2017-01-01 01:11 2017-01-01 01:11:00</code></pre>
<p>However, it does not include a combined datetime class, which would be useful if we want to measure time differences across days.</p>
<p>For a combined datetime class, we have to use POSIXct. This brings with it a couple of annoyances. First, it uses floating-point measurement, so grouping on it with <code>by=</code> is not a good idea and some table operations will be slower. Second, in keeping with POSIX rules, it has an irritating time zone attribute that always demands careful watching. Nonetheless, it is the standard option for a datetime format currently. (There is also a POSIXlt format, but data.table discourages it, since it does not build on atomic vectors.)</p>
</div>
<div id="sub-second-measures" class="section level4">
<h4><span class="header-section-number">3.6.4.3</span> Sub-second measures</h4>
<p>The ITime class is an integer measure of seconds since midnight. POSIXct will be necessary if finer-measured seconds are needed (e.g., from online activity data). If even finer measurement is needed (e.g., for network latency measurement), <a href="http://dirk.eddelbuettel.com/code/nanotime.html">the <code>nanotime</code> package</a> is available.</p>
</div>
<div id="computations" class="section level4">
<h4><span class="header-section-number">3.6.4.4</span> Computations</h4>
<p>There are many convenient extractor functions, <code>month</code>, <code>wday</code> and so on, listed in <code>?IDateTime</code> and <code>?weekdays</code>.</p>
<p>The <code>max</code> or <code>min</code> of a vector of dates can be taken (just as it can be for numbers, characters and ordered factors); and inequalities also work.</p>
<p>Arithmetic on IDates with <code>+</code> and <code>-</code> reads <code>1L</code> as one day; and on ITimes, as one second.</p>
<p>Time differences between dates or times can be taken using <code>difftime</code>, which allows for the specification of units of measure for the output.</p>
</div>
</div>
<div id="character-columns" class="section level3">
<h3><span class="header-section-number">3.6.5</span> Character columns</h3>
<p>With character columns that combine multiple variables, there are a few options.</p>
<ul>
<li><p>If the “split” of the variable is fixed-width, <code>substr</code> or <code>substring</code> works.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;A001ABC&quot;</span>, <span class="st">&quot;B001DEF&quot;</span>))
DT[, <span class="st">`</span><span class="dt">:=</span><span class="st">`</span>(<span class="dt">x_id =</span> <span class="kw">substring</span>(x, <span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">x_num =</span> <span class="kw">substring</span>(x, <span class="dv">2</span>, <span class="dv">4</span>), <span class="dt">x_val =</span> <span class="kw">substring</span>(x, <span class="dv">5</span>, <span class="dv">7</span>))][]</code></pre></div>
<pre><code>#          x x_id x_num x_val
# 1: A001ABC    A   001   ABC
# 2: B001DEF    B   001   DEF</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  4 variables:
#  $ x    : chr  &quot;A001ABC&quot; &quot;B001DEF&quot;
#  $ x_id : chr  &quot;A&quot; &quot;B&quot;
#  $ x_num: chr  &quot;001&quot; &quot;001&quot;
#  $ x_val: chr  &quot;ABC&quot; &quot;DEF&quot;
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre></li>
<li><p>If the split follows a pattern that can be characterized using regular expressions (<a href="work.html#strings">4.8</a>), <code>tstrsplit</code> can make the split and automatically convert to appropriate column types just as <code>fread</code> does:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;A_1_22.2&quot;</span>, <span class="st">&quot;B_33_44.4&quot;</span>))
DT[, <span class="kw">c</span>(<span class="st">&quot;x_id&quot;</span>, <span class="st">&quot;x_int&quot;</span>, <span class="st">&quot;x_float&quot;</span>) :<span class="er">=</span><span class="st"> </span><span class="kw">tstrsplit</span>(x, <span class="st">&quot;_&quot;</span>, <span class="dt">type.convert =</span> <span class="ot">TRUE</span>)][]</code></pre></div>
<pre><code>#            x x_id x_int x_float
# 1:  A_1_22.2    A     1    22.2
# 2: B_33_44.4    B    33    44.4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(DT)</code></pre></div>
<pre><code># Classes &#39;data.table&#39; and &#39;data.frame&#39;:    2 obs. of  4 variables:
#  $ x      : chr  &quot;A_1_22.2&quot; &quot;B_33_44.4&quot;
#  $ x_id   : chr  &quot;A&quot; &quot;B&quot;
#  $ x_int  : int  1 33
#  $ x_float: num  22.2 44.4
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre></li>
</ul>
<p>With US states, built-ins (<a href="basics.html#built-ins">2.7</a>) and an update join (<a href="tables.html#joins-update">3.5.4</a>) can be used to convert between abbreviated and long forms:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">state_code =</span> <span class="kw">c</span>(<span class="st">&quot;MN&quot;</span>, <span class="st">&quot;KS&quot;</span>))
DT[.(<span class="dt">state_code =</span> state.abb, <span class="dt">state_name =</span> state.name), on=.(state_code), 
   state_name :<span class="er">=</span><span class="st"> </span>i.state_name 
]</code></pre></div>
<pre><code>#    state_code state_name
# 1:         MN  Minnesota
# 2:         KS     Kansas</code></pre>
<p>In the case of messier strings, the convenience functions in the stringi package may be helpful, along with a read of <code>?regex</code> and the string section in the next chapter (<a href="work.html#strings">4.8</a>).</p>
</div>
<div id="dt-recode" class="section level3">
<h3><span class="header-section-number">3.6.6</span> Categorical columns</h3>
<p><code>fread</code> will read string columns in as character by default, and this is usually the way to go.</p>
<p>When “recoding” values in a character column, I suggest being explicit by storing the mapping in its own table and doing an update join (<a href="tables.html#joins-update">3.5.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example data</span>
DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">v =</span> <span class="kw">c</span>(<span class="st">&quot;Yes&quot;</span>, <span class="st">&quot;argle&quot;</span>, <span class="st">&quot;bargle&quot;</span>, <span class="st">&quot;No&quot;</span>, <span class="st">&quot;Yep&quot;</span>, <span class="st">&quot;garble&quot;</span>, <span class="st">&quot;Nope&quot;</span>, <span class="st">&quot;blargh&quot;</span>))
<span class="co"># desired mapping</span>
v_translateDT =<span class="st"> </span><span class="kw">rbind</span>(
  <span class="kw">data.table</span>(<span class="dt">v_old =</span> <span class="kw">c</span>(<span class="st">&quot;Yes&quot;</span>, <span class="st">&quot;Yep&quot;</span>), <span class="dt">v_new =</span> <span class="ot">TRUE</span>),
  <span class="kw">data.table</span>(<span class="dt">v_old =</span> <span class="kw">c</span>(<span class="st">&quot;No&quot;</span>, <span class="st">&quot;Nope&quot;</span>), <span class="dt">v_new =</span> <span class="ot">FALSE</span>)
)
<span class="co"># update join</span>
DT[v_translateDT, on=.(<span class="dt">v =</span> v_old), vt :<span class="er">=</span><span class="st"> </span>i.v_new ]</code></pre></div>
<p>Here, we are mapping to a logical column. Of course, the same thing could be done with a factor, an ordered factor or a string.</p>
</div>
<div id="list-columns" class="section level3">
<h3><span class="header-section-number">3.6.7</span> List columns</h3>
<p>Data.table supports columns of class <code>list</code>. A “list column” is a list with a length equal to the number of rows of the table. Each element of the list (that is, each row) can hold anything, just like a normal list. We saw an example of this in <a href="tables.html#rbindlist-read">3.6.3</a>.</p>
<p>List columns are rarely a good fit with tabular data for a few reasons. First, they make the data structure significantly harder to understand. Second, grouping, sorting or merging on them is not supported and probably never will be. Third, they do not play nice with time series operators like <code>shift</code> (<a href="work.html#lag">4.3.1</a>).</p>
<p>They are good for many things, but should be avoided if possible while cleaning the primary data. Nonetheless, <code>fread</code> does support reading list columns in.</p>
</div>
<div id="fwrite" class="section level3">
<h3><span class="header-section-number">3.6.8</span> <code>fwrite</code> to write delimited files</h3>
<p>To write a CSV or other delimited-table format, <code>fwrite</code> is usually the best option.</p>
<p>It is fast and includes nice features for printing dates and times, like the <code>squash</code> option that will print dates like <code>20171020</code>.</p>
</div>
<div id="dt-saveload" class="section level3">
<h3><span class="header-section-number">3.6.9</span> Saving and loading R objects</h3>
<p>To save a table for later use in R, there are native formats, RData and RDS. In contrast with delimited files like CSVs, these files are small; are quick to save and load; and will allow the later user to skip tedious and error-prone data processing tasks.</p>
<p>Another consideration is whether the data storage is long-term or short term. If the objects are important and need to be accessible in 10-20 years, it would naturally be safer to store them in flat delimited file (assuming a tabular format makes sense for them). On the other hand, R’s storage formats will always be accessible by opening a suitable old version of R; and <a href="http://r.789695.n4.nabble.com/RData-File-Specification-td917010.html">R’s formats are open and (implicitly) documented</a> and so should presumably be readable with a little work.</p>
<p>One thing to watch out for when loading data.tables from disk is broken “self” pointers, leading to an error about “Invalid .internal.selfref”. This can be fixed by using <code>setDT</code> or <code>alloc.col</code> on all loaded tables, as explained in <code>vignette(&quot;datatable-faq&quot;)</code> under “Reading <code>data.table</code> from RDS or RData file”. Generally, I don’t bother with this safety precaution and haven’t run into problems yet, so I’m not sure how critical it is.</p>
<div id="collections-of-objects" class="section level4">
<h4><span class="header-section-number">3.6.9.1</span> Collections of objects</h4>
<p>The <code>.RData</code> format allows saving and loading multiple objects. When loading, the objects are dropped into the main workspace by default. To avoid the namespace conflicts this invites, I usually load to a new environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>
n   =<span class="st"> </span><span class="dv">10</span>
L   =<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
dat =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">v =</span> <span class="dv">3</span>)
<span class="kw">save</span>(n, L, dat, <span class="dt">file =</span> <span class="st">&quot;stuff.rdata&quot;</span>)

<span class="co"># and later, in another script</span>
<span class="kw">rm</span>(<span class="dt">list =</span> <span class="kw">ls</span>()) <span class="co"># clear workspace</span>
n   =<span class="st"> </span><span class="dv">20</span>          <span class="co"># create a different n</span>
<span class="kw">load</span>(<span class="st">&quot;stuff.rdata&quot;</span>, <span class="dt">env =</span> e_stuff &lt;-<span class="st"> </span><span class="kw">new.env</span>())</code></pre></div>
<p>Now, <code>n</code> is still 20, while the loaded value of <code>n = 10</code> can be accessed like <code>e_stuff$n</code>. The <code>$</code> and <code>[[</code> extractors for lists (<a href="basics.html#extract-list">2.1.8</a>) also work on environments, as does <code>names(e_stuff)</code>.</p>
<p>One nice feature of the R console is that <code>.rdata</code> files can be dragged and dropped into it to load. Also, opening an <code>.rdata</code> file with the R console will start a new session and load it. (At least this is true in Windows.)</p>
</div>
<div id="single-objects" class="section level4">
<h4><span class="header-section-number">3.6.9.2</span> Single objects</h4>
<p>Another option is the RDS format. This stores a single R object, so there is no need to fiddle with environments:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note: this code will save to your current working directory</span>
<span class="co"># type getwd() and read ?setwd for details</span>
dat =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">v =</span> <span class="dv">3</span>)
<span class="kw">saveRDS</span>(dat, <span class="dt">file =</span> <span class="st">&quot;dat.rds&quot;</span>)

<span class="co"># and later, in another script</span>
old_dat &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;dat.rds&quot;</span>)</code></pre></div>
</div>
</div>
<div id="reading-and-writing-other-formats" class="section level3">
<h3><span class="header-section-number">3.6.10</span> Reading and writing other formats</h3>
<p>For “foreign” table formats (Excel, Stata, etc), use an internet search. These input and output tools will always be in active development because the formats themselves are in flux. of course, it is unwise to use any such formats for long-term data storage.</p>
</div>
<div id="formatting-the-display-of-columns" class="section level3">
<h3><span class="header-section-number">3.6.11</span> Formatting the display of columns</h3>
<p>While the way R displays dates (like <code>2017-11-22</code>) might not align with what is seen elsewhere, I suggest getting used to it rather than seeking a workaround, though I’m sure there are some (like making a new class). It will be easier for everyone looking at the data if it is in a standard format.</p>
<p>For the display of numbers, again, I suggest leaving it alone instead of, e.g., rounding or truncating everything. If it’s really an issue that must be addressed, read about <code>scipen</code> in <code>?options</code>.</p>
</div>
</div>
<div id="exploring-data" class="section level2">
<h2><span class="header-section-number">3.7</span> Exploring data</h2>
<p>We’ll look at two example data sets <code>mtcars</code> and <code>airquality</code>:</p>
<p>As a first step, we’ll clean up <code>carsDT</code>’s categorical variables (noted in <a href="tables.html#dt-agg">3.3</a>), using the approach suggested in <a href="tables.html#dt-recode">3.6.6</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rm</span>(<span class="dt">list =</span> <span class="kw">ls</span>())                  <span class="co"># clear tables and other objects</span>

airDT  =<span class="st"> </span><span class="kw">data.table</span>(airquality)
carsDT =<span class="st"> </span><span class="kw">data.table</span>(mtcars, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)
carsDT[.(<span class="dt">old_am =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">new_am =</span> <span class="kw">c</span>(<span class="st">&quot;auto&quot;</span>, <span class="st">&quot;manual&quot;</span>)), on=.(<span class="dt">am =</span> old_am), 
  new_am :<span class="er">=</span><span class="st"> </span>i.new_am ]           <span class="co"># grab new column</span>
carsDT[, am :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span> ]            <span class="co"># drop old column</span>
<span class="kw">setnames</span>(carsDT, <span class="st">&quot;new_am&quot;</span>, <span class="st">&quot;am&quot;</span>) <span class="co"># rename new column</span>

carsDT[.(<span class="dt">old_vs =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">new_vs =</span> <span class="kw">c</span>(<span class="st">&quot;v&quot;</span>, <span class="st">&quot;straight&quot;</span>)), on=.(<span class="dt">vs =</span> old_vs), 
  new_vs :<span class="er">=</span><span class="st"> </span>i.new_vs ]           <span class="co"># grab new column</span>
carsDT[, vs :<span class="er">=</span><span class="st"> </span><span class="ot">NULL</span> ]            <span class="co"># drop old column</span>
<span class="kw">setnames</span>(carsDT, <span class="st">&quot;new_vs&quot;</span>, <span class="st">&quot;vs&quot;</span>) <span class="co"># rename new column</span></code></pre></div>
<p>The rigmarole with dropping and renaming is necessary because data.table’s type safety protections (<a href="tables.html#dt-replace-all">3.4.3</a>) prevent overwriting columns with a new class (from numeric 1/0 to character “auto”/“manual”) in an update join.</p>
<div id="browse-env" class="section level3">
<h3><span class="header-section-number">3.7.1</span> Browsing loaded objects</h3>
<p>For a list of all loaded tables, run…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tables</span>()</code></pre></div>
<pre><code>#      NAME   NROW NCOL MB COLS                                            KEY
# [1,] airDT   153    6  1 Ozone,Solar.R,Wind,Temp,Month,Day                  
# [2,] carsDT   32   12  1 rn,mpg,cyl,disp,hp,drat,wt,qsec,gear,carb,am,vs    
# Total: 2MB</code></pre>
<p>We saw in <a href="tables.html#dt-saveload">3.6.9</a> that a collection of tables (and other objects) saved on disk can be loaded into an environment. We can look at tables in such an environment, too:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">load</span>(<span class="st">&quot;stuff.rdata&quot;</span>, <span class="dt">env =</span> e_stuff &lt;-<span class="st"> </span><span class="kw">new.env</span>())
<span class="kw">tables</span>(<span class="dt">env =</span> e_stuff)</code></pre></div>
<pre><code>#      NAME NROW NCOL MB COLS KEY
# [1,] dat     1    1  1 v       
# Total: 1MB</code></pre>
<p>The <code>tables</code> output shows keys and other attributes, which is handy. If we look at objects of all types (tables, vectors, matrices, functions and more), we usually only view names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>()</code></pre></div>
<pre><code># [1] &quot;airDT&quot;   &quot;carsDT&quot;  &quot;e_stuff&quot;</code></pre>
<p>Output can be filtered according to a regex (<a href="work.html#strings">4.8</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>(<span class="dt">patt =</span> <span class="st">&quot;DT$&quot;</span>)</code></pre></div>
<pre><code># [1] &quot;airDT&quot;  &quot;carsDT&quot;</code></pre>
<p>And it can be done within an environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ls</span>(<span class="dt">env =</span> e_stuff)</code></pre></div>
<pre><code># [1] &quot;dat&quot; &quot;L&quot;   &quot;n&quot;</code></pre>
<p>To remove tables or other objects, use <code>rm</code>. A common step is to remove all objects listed by <code>ls()</code>, like <code>rm(list = ls())</code>.</p>
</div>
<div id="dt-subset" class="section level3">
<h3><span class="header-section-number">3.7.2</span> Subsetting</h3>
<div id="selecting-by-value" class="section level4">
<h4><span class="header-section-number">3.7.2.1</span> Selecting by value</h4>
<p>This is analogous to a SQL WHERE clause or a Stata <code>if</code> clause.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[ am ==<span class="st"> &quot;auto&quot;</span> &amp;<span class="st"> </span>disp &lt;<span class="st"> </span><span class="dv">300</span> ]</code></pre></div>
<pre><code>#                 rn  mpg cyl  disp  hp drat    wt  qsec gear carb   am       vs
#  1: Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44    3    1 auto straight
#  2:        Valiant 18.1   6 225.0 105 2.76 3.460 20.22    3    1 auto straight
#  3:      Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00    4    2 auto straight
#  4:       Merc 230 22.8   4 140.8  95 3.92 3.150 22.90    4    2 auto straight
#  5:       Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4 auto straight
#  6:      Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90    4    4 auto straight
#  7:     Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40    3    3 auto        v
#  8:     Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60    3    3 auto        v
#  9:    Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00    3    3 auto        v
# 10:  Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01    3    1 auto straight</code></pre>
<p>This syntax, <code>DT[i]</code>, is the subsetting task needed in the vast majority of cases. The rest of <a href="tables.html#dt-subset">3.7.2</a> can safely be skipped the first time through; it is mostly useful for reference.</p>
</div>
<div id="selecting-by-group-statistic" class="section level4">
<h4><span class="header-section-number">3.7.2.2</span> Selecting by group statistic</h4>
<p>This is analogous to a SQL HAVING clause.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[ , if (<span class="kw">mean</span>(wt) &gt;<span class="st"> </span><span class="dv">3</span>) .SD, by=.(am, vs) ]</code></pre></div>
<pre><code>#       am       vs                  rn  mpg cyl  disp  hp drat    wt  qsec gear carb
#  1: auto straight      Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44    3    1
#  2: auto straight             Valiant 18.1   6 225.0 105 2.76 3.460 20.22    3    1
#  3: auto straight           Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00    4    2
#  4: auto straight            Merc 230 22.8   4 140.8  95 3.92 3.150 22.90    4    2
#  5: auto straight            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4
#  6: auto straight           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90    4    4
#  7: auto straight       Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01    3    1
#  8: auto        v   Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02    3    2
#  9: auto        v          Duster 360 14.3   8 360.0 245 3.21 3.570 15.84    3    4
# 10: auto        v          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40    3    3
# 11: auto        v          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60    3    3
# 12: auto        v         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00    3    3
# 13: auto        v  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98    3    4
# 14: auto        v Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82    3    4
# 15: auto        v   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42    3    4
# 16: auto        v    Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87    3    2
# 17: auto        v         AMC Javelin 15.2   8 304.0 150 3.15 3.435 17.30    3    2
# 18: auto        v          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41    3    4
# 19: auto        v    Pontiac Firebird 19.2   8 400.0 175 3.08 3.845 17.05    3    2</code></pre>
<p>We are including the group only if it meets our condition. The structure <code>if (cond) x</code> returns <code>x</code> if the condition is true and nothing (<code>NULL</code>) otherwise, omitting those rows.</p>
</div>
<div id="selecting-rows-within-each-group" class="section level4">
<h4><span class="header-section-number">3.7.2.3</span> Selecting rows within each group</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sorting by carb decreasing, selecting first row per group</span>
<span class="co"># thus a row with maximum carb within the group</span>
carsDT[ <span class="kw">order</span>(-carb), .SD[1L], by=.(am, vs) ]</code></pre></div>
<pre><code>#        am       vs            rn  mpg cyl  disp  hp drat    wt  qsec gear carb
# 1: manual        v Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60    5    8
# 2:   auto        v    Duster 360 14.3   8 360.0 245 3.21 3.570 15.84    3    4
# 3:   auto straight      Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4
# 4: manual straight   Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52    4    2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># instead select all row(s) with maximum carb</span>
carsDT[ , .SD[carb ==<span class="st"> </span><span class="kw">max</span>(carb)], by=.(am, vs) ]</code></pre></div>
<pre><code>#         am       vs                  rn  mpg cyl  disp  hp drat    wt  qsec gear carb
#  1: manual        v       Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60    5    8
#  2: manual straight         Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52    4    2
#  3: manual straight        Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.90    5    2
#  4: manual straight          Volvo 142E 21.4   4 121.0 109 4.11 2.780 18.60    4    2
#  5:   auto straight            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30    4    4
#  6:   auto straight           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90    4    4
#  7:   auto        v          Duster 360 14.3   8 360.0 245 3.21 3.570 15.84    3    4
#  8:   auto        v  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98    3    4
#  9:   auto        v Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82    3    4
# 10:   auto        v   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42    3    4
# 11:   auto        v          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41    3    4</code></pre>

<div class="rmd-details">
<strong>Efficient selection of rows within each group.</strong> The second task here is <a href="https://github.com/Rdatatable/data.table/issues/735">somewhat inefficient</a> currently, with a faster workaround <a href="http://stackoverflow.com/a/16574176">provided by eddi</a>: <code>carsDT[carsDT[ , .I[carb == max(carb)], by=.(am, vs) ]$V1]</code>. And <a href="http://stackoverflow.com/a/31854111">Arun provided a further improvement</a>: <code>carsDT[carsDT[, max(carb), by=.(am, vs)], on=.(am, vs, carb = V1)]</code>.
</div>
<p></p>
</div>
<div id="finding-where-a-condition-holds" class="section level4">
<h4><span class="header-section-number">3.7.2.4</span> Finding where a condition holds</h4>
<p>To find where a condition holds:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cond =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;aleph&quot;</span>, <span class="st">&quot;baz&quot;</span>, <span class="st">&quot;boz&quot;</span>) &gt;<span class="st"> &quot;b&quot;</span>
<span class="kw">which</span>(cond)</code></pre></div>
<pre><code># [1] 2 3</code></pre>
<p>So, it takes us from a logical index to one of positions. When using <code>which</code> on a matrix or array (see <a href="basics.html#matrix-array">2.2</a>), we can find out “where” in terms of row and column using the <code>arr.ind</code> option.</p>
<p>Beware of using <code>which</code> output as an index:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x  =<span class="st"> </span><span class="dv">1</span>:<span class="dv">5</span>
w  =<span class="st"> </span><span class="kw">which</span>(x^<span class="dv">2</span> &gt;<span class="st"> </span><span class="dv">50</span>)
w</code></pre></div>
<pre><code># integer(0)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-w]</code></pre></div>
<pre><code># integer(0)</code></pre>
<p>We wanted to filter to where <code>x</code> fails our condition, but instead we lost the whole vector. Straight-up logical filtering is the safer route here: <code>x[!(x^2 &gt; 50)]</code>.</p>
<p>To find which table rows a subset pertains to, use <code>DT[i, which = TRUE]</code>. The <code>i</code> index could be a logical condition or a table being joined. It might seem like the special symbol <code>.I</code> would work here instead, like <code>DT[i, .I]</code>, but currently it does not.</p>
</div>
</div>
<div id="sorting" class="section level3">
<h3><span class="header-section-number">3.7.3</span> Sorting</h3>
<p>To sort the table in-place, use <code>setorder</code>. And to set a key (which sorts as a side effect), use <code>setkey</code>. When passing columns to sort by programmatically, use <code>setorderv</code> or <code>setkeyv</code>.</p>
<p>For a one-time sort (not altering the order of the object itself), write an <code>order(...)</code> expression in the first argument, like <code>carsDT[order(hp, -carb), j, by=]</code> where <code>j</code> and <code>by=</code> characterize some task to be done with the sorted data.</p>
</div>
<div id="explore-onevar" class="section level3">
<h3><span class="header-section-number">3.7.4</span> Examining each variable</h3>
<div id="summary-functions" class="section level4">
<h4><span class="header-section-number">3.7.4.1</span> Summary functions</h4>
<p>For a snapshot of per-variable stats, there’s <code>summary</code>, but it is very crude and reports nothing about character columns (not even missing values):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(airDT)</code></pre></div>
<pre><code>#      Ozone           Solar.R           Wind             Temp           Month      
#  Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00   Min.   :5.000  
#  1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00   1st Qu.:6.000  
#  Median : 31.50   Median :205.0   Median : 9.700   Median :79.00   Median :7.000  
#  Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88   Mean   :6.993  
#  3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00   3rd Qu.:8.000  
#  Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00   Max.   :9.000  
#  NA&#39;s   :37       NA&#39;s   :7                                                       
#       Day      
#  Min.   : 1.0  
#  1st Qu.: 8.0  
#  Median :16.0  
#  Mean   :15.8  
#  3rd Qu.:23.0  
#  Max.   :31.0  
# </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(carsDT)</code></pre></div>
<pre><code>#       rn                 mpg             cyl             disp             hp       
#  Length:32          Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  
#  Class :character   1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  
#  Mode  :character   Median :19.20   Median :6.000   Median :196.3   Median :123.0  
#                     Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  
#                     3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  
#                     Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  
#       drat             wt             qsec            gear            carb      
#  Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :3.000   Min.   :1.000  
#  1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:3.000   1st Qu.:2.000  
#  Median :3.695   Median :3.325   Median :17.71   Median :4.000   Median :2.000  
#  Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :3.688   Mean   :2.812  
#  3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:4.000   3rd Qu.:4.000  
#  Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :5.000   Max.   :8.000  
#       am                 vs           
#  Length:32          Length:32         
#  Class :character   Class :character  
#  Mode  :character   Mode  :character  
#                                       
#                                       
# </code></pre>
<p>To count missing values per column (analogous to Stata’s mdesc)…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[, .(
  <span class="dt">col =</span> <span class="kw">names</span>(.SD),
  <span class="dt">nna =</span> nna &lt;-<span class="st"> </span><span class="kw">colSums</span>(<span class="kw">is.na</span>(.SD)),
  <span class="dt">nok =</span> .N -<span class="st"> </span>nna,
  <span class="dt">tot =</span> .N
)]</code></pre></div>
<pre><code>#        col nna nok tot
# 1:   Ozone  37 116 153
# 2: Solar.R   7 146 153
# 3:    Wind   0 153 153
# 4:    Temp   0 153 153
# 5:   Month   0 153 153
# 6:     Day   0 153 153</code></pre>
<p>This can also be done by group, like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[, .(
  <span class="dt">col =</span> <span class="kw">names</span>(.SD),
  <span class="dt">nna =</span> nna &lt;-<span class="st"> </span><span class="kw">colSums</span>(<span class="kw">is.na</span>(.SD)),
  <span class="dt">nok =</span> .N -<span class="st"> </span>nna,
  <span class="dt">tot =</span> .N
), by=Month]</code></pre></div>
<p>Various function can be applied and have the usual names: <code>mean</code>, <code>median</code>, <code>range</code> (combining <code>min</code> and <code>max</code>), <code>var</code>, <code>skew</code>, <code>quantile</code>, etc. Most of these functions can be applied by group as well, with syntax like …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># single-valued functions</span>
carsDT[, <span class="kw">mean</span>(drat), by=am]</code></pre></div>
<pre><code>#        am       V1
# 1: manual 4.050000
# 2:   auto 3.286316</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># multi-valued functions</span>
carsDT[, <span class="kw">quantile</span>(drat, <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">25</span>, .<span class="dv">75</span>, .<span class="dv">9</span>)) %&gt;%<span class="st"> </span>as.list, by=am]</code></pre></div>
<pre><code>#        am   10%  25%   75%   90%
# 1: manual 3.650 3.85 4.220 4.388
# 2:   auto 2.896 3.07 3.695 3.920</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># multiple functions</span>
carsDT[, <span class="kw">c</span>(
  .(<span class="dt">mean =</span> <span class="kw">mean</span>(drat)), 
  <span class="kw">quantile</span>(drat, <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">25</span>, .<span class="dv">75</span>, .<span class="dv">9</span>)) %&gt;%<span class="st"> </span>as.list
), by=am]</code></pre></div>
<pre><code>#        am     mean   10%  25%   75%   90%
# 1: manual 4.050000 3.650 3.85 4.220 4.388
# 2:   auto 3.286316 2.896 3.07 3.695 3.920</code></pre>
<p>The <code>as.list</code> is necessary to split the results over multiple columns. It is inefficient, but that won’t matter much when exploring data, I imagine.</p>
</div>
<div id="tabulating" class="section level4">
<h4><span class="header-section-number">3.7.4.2</span> Tabulating</h4>
<p>For a better look at a character or factor column, we’d want to tabulate values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, <span class="kw">table</span>(am, <span class="dt">useNA =</span> <span class="st">&quot;always&quot;</span>)]</code></pre></div>
<pre><code># am
#   auto manual   &lt;NA&gt; 
#     19     13      0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, .N, by=am]</code></pre></div>
<pre><code>#        am  N
# 1: manual 13
# 2:   auto 19</code></pre>
<p>Each of the two options above has advantages in certain cases. We’ll see that <code>table()</code> is useful when browsing tabulations in more dimensions. And the <code>DT[...]</code> syntax is useful for chaining. For example, <code>carsDT[, .N, by=av][order(-N)][1:3]</code> will show counts for the three largest groups, sorted.</p>
<p>For a better look at continuous variables, we can use the same tools after using <code>cut</code> to put values into bins:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .N, by=.(<span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))]</code></pre></div>
<pre><code>#       drat_bin  N
# 1: (3.84,4.39] 11
# 2:  (2.76,3.3] 13
# 3:  (3.3,3.84]  6
# 4: (4.39,4.93]  2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span><span class="kw">cut</span>(<span class="dv">4</span>) %&gt;%<span class="st"> </span>table ]</code></pre></div>
<pre><code># .
#  (2.76,3.3]  (3.3,3.84] (3.84,4.39] (4.39,4.93] 
#          13           6          11           2</code></pre>
</div>
<div id="plotting" class="section level4">
<h4><span class="header-section-number">3.7.4.3</span> Plotting</h4>
<p>We can plot a binned version of the variable; or instead a histogram; or a kernel approximation to the density; or a box plot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, drat %&gt;%<span class="st"> </span><span class="kw">cut</span>(<span class="dv">4</span>) %&gt;%<span class="st"> </span>table %&gt;%<span class="st"> </span>plot ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-1.png" width="672" /></p>
<pre><code># [1] 1 2 3 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span><span class="kw">hist</span>(<span class="dv">4</span>) %&gt;%<span class="st"> </span>{<span class="ot">NULL</span>} ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-2.png" width="672" /></p>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span>density %&gt;%<span class="st"> </span>plot ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-3.png" width="672" /></p>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, drat %&gt;%<span class="st"> </span>boxplot  %&gt;%<span class="st"> </span>{<span class="ot">NULL</span>} ]</code></pre></div>
<p><img src="tutorial_files/figure-html/cut-table-plot-4.png" width="672" /></p>
<pre><code># NULL</code></pre>
<p>The first option is discouraged by a note in <code>?cut</code>:</p>
<blockquote>
<p>Instead of <code>table(cut(x, br))</code>, <code>hist(x, br, plot = FALSE)</code> is more efficient and less memory hungry.</p>
</blockquote>
<p>The <code>{NULL}</code> at the end is useful for fairly esoteric reasons. With <code>hist</code>, it is to avoid printing the histogram’s internal structure to the console. With <code>boxplot</code> the same reason applies, but in addition, it is to avoid an error caused by how data.table processes the <code>j</code> argument of <code>DT[i,j,by]</code>. Anyway, a trailing <code>NULL</code> can safely be tacked onto the end of any <code>j</code> operation where you don’t actually want to see the return value.</p>
<p>As seen here, using <code>%&gt;%</code> pipes with plotting functions has the unfortunate side effect of yielding blanks in titles and axes. Compare with <code>carsDT[, hist(drat, 4) ]</code>, for example. Nonetheless, piping is often convenient for this. The <code>cut</code>, <code>hist</code>, <code>density</code>, <code>boxplot</code> and <code>plot</code> functions all have many options that can be tweaked, documented in their help files, but with the default options they are a quick way to glance at a variable.</p>
</div>
<div id="other-analyses" class="section level4">
<h4><span class="header-section-number">3.7.4.4</span> Other analyses</h4>
<p>Of course, various statistical tests can be applied to a vector; but that is best left up to an internet search and careful reading of the documentation.</p>
</div>
</div>
<div id="explore-vars" class="section level3">
<h3><span class="header-section-number">3.7.5</span> Examining variables jointly</h3>
<div id="summary-functions-1" class="section level4">
<h4><span class="header-section-number">3.7.5.1</span> Summary functions</h4>
<p>The <code>var</code> function applied to a table will give its variance-covariance matrix. There’s also the correlation matrix with <code>corr</code>; and a plotter for the correlation matrix in <a href="https://CRAN.R-project.org/package=corrplot">the corrplot package</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, <span class="kw">var</span>(.SD), .SDcols =<span class="st"> </span><span class="kw">sapply</span>(carsDT, is.numeric)]</code></pre></div>
<pre><code>#              mpg         cyl        disp          hp         drat          wt
# mpg    36.324103  -9.1723790  -633.09721 -320.732056   2.19506351  -5.1166847
# cyl    -9.172379   3.1895161   199.66028  101.931452  -0.66836694   1.3673710
# disp -633.097208 199.6602823 15360.79983 6721.158669 -47.06401915 107.6842040
# hp   -320.732056 101.9314516  6721.15867 4700.866935 -16.45110887  44.1926613
# drat    2.195064  -0.6683669   -47.06402  -16.451109   0.28588135  -0.3727207
# wt     -5.116685   1.3673710   107.68420   44.192661  -0.37272073   0.9573790
# qsec    4.509149  -1.8868548   -96.05168  -86.770081   0.08714073  -0.3054816
# gear    2.135685  -0.6491935   -50.80262   -6.358871   0.27598790  -0.4210806
# carb   -5.363105   1.5201613    79.06875   83.036290  -0.07840726   0.6757903
#              qsec        gear        carb
# mpg    4.50914919   2.1356855 -5.36310484
# cyl   -1.88685484  -0.6491935  1.52016129
# disp -96.05168145 -50.8026210 79.06875000
# hp   -86.77008065  -6.3588710 83.03629032
# drat   0.08714073   0.2759879 -0.07840726
# wt    -0.30548161  -0.4210806  0.67579032
# qsec   3.19316613  -0.2804032 -1.89411290
# gear  -0.28040323   0.5443548  0.32661290
# carb  -1.89411290   0.3266129  2.60887097</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, <span class="kw">cor</span>(.SD), .SDcols =<span class="st"> </span><span class="kw">sapply</span>(carsDT, is.numeric)]</code></pre></div>
<pre><code>#             mpg        cyl       disp         hp        drat         wt        qsec
# mpg   1.0000000 -0.8521620 -0.8475514 -0.7761684  0.68117191 -0.8676594  0.41868403
# cyl  -0.8521620  1.0000000  0.9020329  0.8324475 -0.69993811  0.7824958 -0.59124207
# disp -0.8475514  0.9020329  1.0000000  0.7909486 -0.71021393  0.8879799 -0.43369788
# hp   -0.7761684  0.8324475  0.7909486  1.0000000 -0.44875912  0.6587479 -0.70822339
# drat  0.6811719 -0.6999381 -0.7102139 -0.4487591  1.00000000 -0.7124406  0.09120476
# wt   -0.8676594  0.7824958  0.8879799  0.6587479 -0.71244065  1.0000000 -0.17471588
# qsec  0.4186840 -0.5912421 -0.4336979 -0.7082234  0.09120476 -0.1747159  1.00000000
# gear  0.4802848 -0.4926866 -0.5555692 -0.1257043  0.69961013 -0.5832870 -0.21268223
# carb -0.5509251  0.5269883  0.3949769  0.7498125 -0.09078980  0.4276059 -0.65624923
#            gear       carb
# mpg   0.4802848 -0.5509251
# cyl  -0.4926866  0.5269883
# disp -0.5555692  0.3949769
# hp   -0.1257043  0.7498125
# drat  0.6996101 -0.0907898
# wt   -0.5832870  0.4276059
# qsec -0.2126822 -0.6562492
# gear  1.0000000  0.2740728
# carb  0.2740728  1.0000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, <span class="kw">cor</span>(.SD) %&gt;%<span class="st"> </span>corrplot::<span class="kw">corrplot</span>() %&gt;%<span class="st"> </span>{<span class="ot">NULL</span>}, .SDcols =<span class="st"> </span><span class="kw">sapply</span>(carsDT, is.numeric)]</code></pre></div>
<p><img src="tutorial_files/figure-html/vcv-1.png" width="672" /></p>
<pre><code># NULL</code></pre>
<p>The trailing <code>()</code> on <code>corrplot::corrplot()</code> is necessary thanks to <a href="https://github.com/tidyverse/magrittr/issues/12">a magrittr bug</a> not yet fixed on CRAN.</p>
</div>
<div id="tabulating-1" class="section level4">
<h4><span class="header-section-number">3.7.5.2</span> Tabulating</h4>
<p>Cross tabulation of discrete, or discretized, variables uses <code>table</code> or <code>.N</code> again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .N, by=.(am, <span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))]</code></pre></div>
<pre><code>#        am    drat_bin  N
# 1: manual (3.84,4.39]  8
# 2:   auto  (2.76,3.3] 13
# 3:   auto  (3.3,3.84]  3
# 4:   auto (3.84,4.39]  3
# 5: manual (4.39,4.93]  2
# 6: manual  (3.3,3.84]  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># or</span>
carsDT[, <span class="kw">table</span>(am, <span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))]</code></pre></div>
<pre><code>#         drat_bin
# am       (2.76,3.3] (3.3,3.84] (3.84,4.39] (4.39,4.93]
#   auto           13          3           3           0
#   manual          0          3           8           2</code></pre>
<p>Note that the <code>table</code> approach includes zeros, while they don’t show up in the aggregation using <code>.N</code>.</p>
</div>
<div id="plotting-1" class="section level4">
<h4><span class="header-section-number">3.7.5.3</span> Plotting</h4>
<p>For a pair of continuous variables, <code>qqplot</code> will give a QQ plot; and <code>plot</code>, a scatterplot. To deal with the fact that varying density isn’t always clear in a scatterplot (since dots end up on top of each other), one common recommendation is the <a href="https://cran.r-project.org/package=hexbin">hexbin package</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[, { 
  hexbin::<span class="kw">hexbin</span>(Wind, Temp) %&gt;%<span class="st"> </span>plot
  <span class="ot">NULL</span> 
}]</code></pre></div>
<p><img src="tutorial_files/figure-html/hexbin-1.png" width="672" /></p>
<pre><code># NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">airDT[,  <span class="kw">plot</span>(Wind, Temp)]</code></pre></div>
<p><img src="tutorial_files/figure-html/hexbin-2.png" width="672" /></p>
<pre><code># NULL</code></pre>
<p>To see how a particular curve relates to the data, it can be overlaid on compatible plots like <code>curve(100 - 3*x, add = TRUE)</code>. Without the <code>add=TRUE</code> option, the curve would be placed in a new plot.</p>

<div class="rmd-caution">
<p><strong>Plot windows.</strong> Working interactively in the R console, each plot takes the place of the last one, using the same window. To open new windows use <code>x11()</code> whatever command the plotting function says is necessary. Multiple plots can be fit in the same window using <code>par</code>.</p>
In R Studio, a history of plots is saved in the “Plots” area and can be browsed using the left and right arrow buttons there. The x and broom buttons can be used to remove plots from the history. If you want plots in separate windows (like seen in the R console), <code>x11()</code> or a similar call can be used.
</div>
<p></p>
</div>
<div id="other-analyses-1" class="section level4">
<h4><span class="header-section-number">3.7.5.4</span> Other analyses</h4>
<p>An internet search will reveal many tools for estimating a model and plotting its fitted curve and confidence bands on top of the cloud of points, so I won’t cover those here. Usually, after finding such a tool, a read of its documentation and running its examples will be sufficient to figure it out. And for more than two variables, the same is true – a search online will serve very well, assuming the desired task is clear.</p>
</div>
</div>
<div id="dcast" class="section level3">
<h3><span class="header-section-number">3.7.6</span> Reshaping to wide</h3>
<p>The <code>dcast</code> function is a flexible way of making a table of summary stats. Extending some examples above…</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">carsDT[, .(.N, <span class="dt">mean_hp =</span> <span class="kw">mean</span>(hp)), by=.(am, <span class="dt">drat_bin =</span> <span class="kw">cut</span>(drat, <span class="dv">4</span>))][,
  <span class="kw">dcast</span>(.SD, drat_bin ~<span class="st"> </span>am, <span class="dt">value.var =</span> <span class="kw">c</span>(<span class="st">&quot;N&quot;</span>, <span class="st">&quot;mean_hp&quot;</span>))
]</code></pre></div>
<pre><code>#       drat_bin N_auto N_manual mean_hp_auto mean_hp_manual
# 1:  (2.76,3.3]     13       NA     176.9231             NA
# 2:  (3.3,3.84]      3        3     134.6667       207.6667
# 3: (3.84,4.39]      3        8     113.6667       110.3750
# 4: (4.39,4.93]     NA        2           NA        71.5000</code></pre>
<p>So we get row counts and mean horsepower computed by auto/manual and bins of drat (rear-axle ration). Unfortunately, we get NA counts instead of zeros here, but if the goal is simply to explore data, that shouldn’t be a big deal.</p>

<div class="rmd-details">
<strong>Melting and casting.</strong> The terms melting and casting (for conversion of a table to and from long format) are taken from the reshape2 package. My guess regarding the lingo is that it comes from mettalurgy and the thinking is: there is only one long-form arrangement of data, its liquid or molten form. There are many possible wide-form arrangements, each of which is casting the raw molten data into a rigid form using a different mold.
</div>
<p></p>
<p>The <code>dcast</code> function and its counterpart, <code>melt</code>, are covered in <code>vignette(&quot;datatable-reshape&quot;)</code>. Also, <code>melt</code> comes up again in <a href="tables.html#structuring-data">3.8</a>.</p>
</div>
</div>
<div id="structuring-data" class="section level2">
<h2><span class="header-section-number">3.8</span> Organizing relational tables</h2>
<p>background: tidy data / database design</p>
<p>data.table(CO2) might be a good example, with its redundant cols</p>
<div id="melt" class="section level3">
<h3><span class="header-section-number">3.8.1</span> Reshaping to long format</h3>
<p>todo cite <code>vignette(&quot;datatable-reshape&quot;)</code> again</p>
</div>
<div id="choosing-tables-and-keys" class="section level3">
<h3><span class="header-section-number">3.8.2</span> Choosing tables and keys</h3>
</div>
<div id="listing-levels" class="section level3">
<h3><span class="header-section-number">3.8.3</span> Listing levels</h3>
<p>make a “skeleton” for the data</p>
<p>consider igraph if the order does not matter</p>
<p>use CJ(col1, col2), maybe seq</p>
<p>if it’s not cartesian, then DT[, col2, by=col1]</p>
</div>
<div id="exploring-levels" class="section level3">
<h3><span class="header-section-number">3.8.4</span> Exploring levels</h3>
<p>setdiff, union, intersect (works with data.table from 1.9.8+)</p>
<p>does the table have any dupes?</p>
<p>does the table have all levels?</p>
<p>stopifnot</p>
</div>
<div id="aggregate-join" class="section level3">
<h3><span class="header-section-number">3.8.5</span> Collapsing</h3>
<p>essentially an aggregate join – we join so that we can aggregate</p>
<p>maybe collapsing because we want a table aggregated at a higher level</p>
<p>maybe collapsing because we have “duplicates” hanging around for other reasons</p>
<p>unique, duplicated + fromLast</p>

<div class="rmd-caution">
<strong>Beware <code>DT[i,on=,j,by=bycols]</code>.</strong> Only <code>by=.EACHI</code> works in a join. Typing other <code>by=</code> values there will cause <code>i</code>’s columns to become unavailable. This <a href="https://github.com/Rdatatable/data.table/issues/733">may eventually change</a>.
</div>
<p></p>
<p>use CJ for missing levels</p>
</div>
<div id="expanding" class="section level3">
<h3><span class="header-section-number">3.8.6</span> Expanding</h3>
<p>CJ + unique</p>
<p>use CJ for missing levels</p>
<p>Suppose we have a table measuring wealth by person and year.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">psn_id =</span> <span class="kw">c</span>(1L, 1L, 2L), <span class="dt">year =</span> <span class="kw">c</span>(1998L, 2000L, 2000L), <span class="dt">wealth =</span> <span class="dv">24</span>:<span class="dv">22</span>)</code></pre></div>
<pre><code>#    psn_id year wealth
# 1:      1 1998     24
# 2:      1 2000     23
# 3:      2 2000     22</code></pre>
<p>Now we want a person-year row for every every person and for every year from the lowest to the highest. We can do this with <code>CJ</code> and a standard join:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">psn_id =</span> <span class="kw">c</span>(1L, 1L, 2L), <span class="dt">year =</span> <span class="kw">c</span>(1998L, 2000L, 2000L), <span class="dt">wealth =</span> <span class="dv">24</span>:<span class="dv">22</span>)</code></pre></div>
<pre><code>#    psn_id year wealth
# 1:      1 1998     24
# 2:      1 2000     23
# 3:      2 2000     22</code></pre>
</div>
<div id="update-joins" class="section level3">
<h3><span class="header-section-number">3.8.7</span> Update joins</h3>
<p>we join so that we can update the table on the left</p>
</div>
<div id="programming-data.table-calls" class="section level3">
<h3><span class="header-section-number">3.8.8</span> Programming data.table calls</h3>
<p>getting into the weeds</p>
<p>DT[, if (.GRP == 1) {}, by=.(x,y,z)] for testing, or alternately browser()</p>
<p>eval-quote for constructing efficient calls</p>
<p>mget / get</p>
<p>review related options</p>
<p>options() %&gt;% .[grep(“datatable”, names(.))]</p>
<div id="program-cols" class="section level4">
<h4><span class="header-section-number">3.8.8.1</span> Specifying columns</h4>
<p>shortcuts when entering j, by, .SDcols</p>
<p>a:b, .(a,b), !(whatever), -(whatever)</p>
<p>for .SDcols – logical or integer instead of character (though I can’t see any reason to use those)</p>
<p>shortcuts: .SDcols = V1:V10, .SDcols = grep(“^date_”, names(DT)), etc</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT[, 
   <span class="kw">lapply</span>(.SD, max)
, by=z, .SDcols =<span class="st"> </span>{ <span class="kw">sapply</span>(DT, is.numeric) }]</code></pre></div>
<p><code>.SDcols</code> is used to filter the columns that appear in <code>.SD</code>, the subset of data available in <code>j</code>.</p>
</div>
</div>
<div id="bad-aggregations" class="section level3">
<h3><span class="header-section-number">3.8.9</span> Bad aggregations</h3>
<p>todo – i prolly don’t need a section; there are countless ways to format data badly. but i do want to warn about by=1:nrow(DT) et al… for now, i’ll put a warning block in the agg section higher up</p>
<p>Suppose we have data like …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">badDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>), <span class="dt">A =</span> <span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">B =</span> -<span class="dv">1</span>:<span class="dv">1</span>)</code></pre></div>
<pre><code>#    col A  B
# 1:   A 1 -1
# 2:   A 2  0
# 3:   B 3  1</code></pre>
<p>Values in the <code>col</code> column refers to the other columns. We might want to do things like …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select the column using col</span>
badDT[, .SD[[col]], by=<span class="dv">1</span>:<span class="kw">nrow</span>(badDT)]
<span class="co"># take the larger column</span>
badDT[, <span class="kw">max</span>(<span class="kw">unlist</span>(.SD)), by=<span class="dv">1</span>:<span class="kw">nrow</span>(badDT), .SDcols=<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>)]</code></pre></div>
<p>Or we might have data like …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">badparDT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">parent =</span> <span class="kw">c</span>(<span class="st">&quot;A1&quot;</span>,<span class="st">&quot;A2&quot;</span>,<span class="st">&quot;B1&quot;</span>), <span class="dt">kid1 =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>), <span class="dt">kid2 =</span> <span class="kw">c</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="ot">NA</span>), <span class="dt">kid3 =</span> <span class="kw">c</span>(<span class="st">&quot;f&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="ot">NA</span>))</code></pre></div>
<pre><code>#    parent kid1 kid2 kid3
# 1:     A1    a    d    f
# 2:     A2    a    d    f
# 3:     B1    b   NA   NA</code></pre>
<p>Parent names consist of the family code plus a number; and kids are arrayed on columns, with as many such columns as are needed for the largest family. We might want to do things like …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># count kids per parent</span>
badDT[, .SD[[col]], by=<span class="dv">1</span>:<span class="kw">nrow</span>(badDT)]
<span class="co"># count parents per family</span>
badDT[, <span class="kw">max</span>(<span class="kw">unlist</span>(.SD)), by=<span class="dv">1</span>:<span class="kw">nrow</span>(badDT), .SDcols=<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>)]</code></pre></div>
<p>While such code might technically run,</p>
<p>… split this section into iterating over columns and iterating over groups. explain that by= will take any appropriate-length vector, warn about by=1:nrow(DT)</p>

</div>
</div>
</div>
<p style="text-align: center;">
<a href="basics.html"><button class="btn btn-default">Previous</button></a>
<a href="work.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
