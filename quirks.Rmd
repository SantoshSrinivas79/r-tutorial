# Quirks {#quirks}

This chapter is for when you know the right tool for the job, but don't know where it is in R; or for when you have a tool, but it behaves less like a hammer than a staple-gun shooting you in the foot. The major quirks covered so far have been:

- \@ref(classes) Vector classes may be "coerced" silently.
- \@ref(slicing) If a vector is too short, it may be "recycled" silently.
- \@ref(names) While objects can be made like `x <- 2`, function arguments should not be written like `f(x <- 2)`.
- \@ref(subassigning) Important functions have documentation at ``?`[<-` `` and similar.
- Integers are distinguished from floats by a trailing L in input, but are invisible in output.
- dimension dropping

The remaining quirks mostly have to do with the lack of a consistent naming pattern for functions, which really is for the best. ^[Should we use abbreviations? Acronyms? Dots? Underscores? Verbs? Adjectives describing output? Adjectives describing input? How about a jumble?]

You can safely skim this chapter, only reading the <span class="spnote" id="quirk-dummy"></span>s the first time through and returning when you need to solve a problem. 

## Matrix tools {#matrix-more}

- *Make identity matrix* `diag(n)`
- *Make matrix with vector on diagonal* `diag(v)`
- *Extract diagonal* `diag(X)`

standard basis?

## Reshaping

## Using data.tables efficiently

by=1:nrow(DT) is always an option, but probably means you're doing it wrong

## Randomization

To draw `n` random numbers from the unit interval, use `runif(n)`. All random-draw functions follow this naming convention -- `rnorm`, `rpoisson`, `rbinom` -- for a full list of the built-in ones, type `?distributions`. Many more are offered in packages that can be found by searching online.

To make your draw reproducible, use `set.seed` before it:

```{r set-seed, eval=FALSE}
set.seed(1)
rnorm(10)
```

To take `n` samples from `x` with replacement, where `p[i]` is the probability of drawing `x[i]`: 

```{r sample, eval=FALSE}
sample(x, prob = p, size = n, replace = TRUE)
```

The help page `?sample` covers many other use cases. There is one to be very wary of, however:

```{r sample-bad}
set.seed(1)
x = c(6.17, 5.16, 4.15, 3.14)
sample(x, 2, replace = TRUE)
y = c(6.17)
sample(y, size = 2, replace = TRUE)
```

Where did `4` and `6` come from? Those aren't elements of `y`!

<span class="spnote" id="sampling">
**Sampling from a numeric vector.** I should have sampled from `y`s indices like `y[sample.int(length(y), size = 2, replace = TRUE)]`. Vanilla `sample` cannot be trusted on numeric or integer vectors unless you are sure they have a length greater than 1. 
</span>

runif
sample(n)
sample(vec) -- very unsafe if length is dynamic
replicate

## Time series operators

`head(x, n)` will return the front of a vector up to the first `n` elements; while `tail(x,n)` works from the end of the vector.

```{r head-tail-pre}
x = c(1, 2, 3, 4)
```
```{r head-tail}
head(x, 2)
tail(x, 3)
tail(x, 111) # it selects up to n terms
```

`head(x, -n)` returns the front of the vector, chopping off the final `n` elements. This can be used to apply the lag operator to `x`:

```{r lag}
c(NA, head(x, -1))
```

Higher-order lags and leads can be be constructed similarly. In \@ref(data-table), we'll see data.table's `shift` function, which is more useful in practice.

## Functions' methods {#methods}

With a data.frame, `head` behaves very differently:

```{r head-tail-DF}
L = list(x = c(1,2,3), y = c("a", "b", "c"), z = c(3L, 2L, 1L))
head(L, 1)
DF = as.data.frame(L)
head(DF, 1)
```

<span class="spnote" id="methods">
**Methods.** `head(x, n)` looks at `class(x)` and may "dispatch" to a class-specific "method." In this case, it dispatches to `head.data.frame`, which has documentation at `?head.data.frame` like any other function. This help page overlaps with vanilla `?head`, but this is not always the case (e.g., for `?seq` versus `?seq.Date`, introduced in the next section).
</span>

To investigate whether a method is being used on `x`, use the `methods` function, which performs a search.

```{r methods}
methods("head")
methods(class = "data.frame")
```

<span class="spdetails" id="fancy-methods">
Methods are part of R's support for object-oriented programming. In other languages' OO systems, methods are attached to classes; while in R they are attached to functions. (R has countless OO systems, some added by packages, so this might not be strictly true.) To make your own methods, start by reading `?Methods`. I've never needed this functionality myself. 
</span>

## Sequences

The simplest syntax for integer sequences is `n:m`. To work with a different step size, use `seq`:

```{r seq2}
seq(from = 1, to = 9, by = 2)
seq(from = 101, to = 1, by = -10)
```

You can mix and match arguments as long as it makes sense: 

```{r seq-more}
seq(from = 0, by = 15, length.out = 10)
seq(to = 100, by = 10, length.out = 5)
```

<span class="spnote" id="badseq">
**Sequences starting from 1.** Resist the temptation to write a program with `1:length(x)` or `seq(from = 1, to = length(x))`. If `x` is zero-length, this vector will be `1:0`, which can lead to all sorts of weird results. Instead, use `seq_along(x)`. And more generally, use `seq_len(n)` instead of `1:n` or `seq(from = 1, to = n)` when programming. 
</span>

Following the "See Also" section of `?seq`, you will find `sequence` and `gl`, which are rather esoteric, and `seq.Date`, which is very useful:

```{r seq-date}
seq.Date(from = as.Date("2013-11-11"), to = as.Date("2015-01-01"), by = "month")
```

In \@ref(dates-times), we'll look more at working with dates and times.

## Tallying {#tallying}

To tabulate a variable, use `table`:

```{r table}
set.seed(1)
n  = 100
f  = factor(c("a", "b", "c"))
x  = f[ sample.int(length(f), size = n, replace = TRUE) ]
table(x)
```

For details, consider exploring: 

```{r table-more, eval=FALSE}
plot(x)
plot(table(x))
methods("plot")
methods(class="table")
```

We can also tabulate conditions:

```{r table-cond}
set.seed(1)
x = rpois(100, lambda = 10)
table(hix = x > 10)
```

And make cross-tabs:

```{r table-cross}
set.seed(1)
n = 100
x = rpois(n, lambda = 10)
y = x^2 + rpois(n, lambda = 10)
table(hix = x > 10, hiy = y > x + 50)
```


We will revisit tabulation with data.tables in \@ref(exploring-data).

## Finding bins for values

With a continuous variable `x`, it often doesn't make sense to tally values. However, we can specify bins and find where the values fall:

```{r cut}
set.seed(1)
n  = 1000
x  = rchisq(n, df = 10)
xc = cut(x, breaks = c(0, 5, 10, 15, 20, Inf)) # or max(x) in place of Inf
table(xc)
```

However, see the note in `?cut` for details on more efficient alternatives:

> Instead of `table(cut(x, br))`, `hist(x, br, plot = FALSE)` is more efficient and less memory hungry. Instead of `cut(*, labels = FALSE)`, `findInterval()` is more efficient.

We will revisit summarizing data in \@ref(exploring-data).

## Finding where a condition holds

To find where a condition holds:

```{r which}
cond = c("aleph", "baz", "boz") > "b"
which(cond)
```

So, it takes us from a logical index to one of positions. This can sometimes speed up computations; and is necessary when facing functions that don't take logical indices.

mention arr.ind

warn x = 1:5; x[-which(x==6)] per r.inf, so: subset by integers, but be careful of length zero

## Finding a value

To find exactly matching values:

```{r match}
match(x = c(23, 45, 15), c(11, 23, 34, 45, 23))
```

This tells us where `x[1]`, `x[2]` and `x[3]` found their matches in the second vector. If multiple matches exist, only the first is found and returned; and if no match is found, `NA` is returned (or a custom value). This is occasionally useful for merges, and is the workhorse behind all the set operators in \@ref(set-ops).

## String operations

In my opinion, very few string operations are necessary after proper data cleaning (discussed in \@ref(structuring-data)).

`nchar(x)` tells you how long a string is, and `substr(x, start, end)` extracts a contiguous substring. `paste`, `paste0` and `sprintf` are used to build strings, while `sub` and `gsub` rewrite strings.

`grep` and its family will match a string pattern, while `regmatches` can extract what matches. `strsplit(x, sep=",")` can split `"Butte, Montana"` into its constituent parts. Handier tools for these tasks are discussed in \@ref(structuring-data).

escaping in regex `\\`

## Built-in constants

R includes several handy constants, like `pi`, the alphabet (`?letters`), months (`?month.name`), days of the week (`?weekdays`) and US state names and abbreviations (`?state`). You don't need to worry about accidentally reusing any of these contants' names for your own variables (though redefining `pi` might not be a great idea).

On a related note, `?Reserved` lists all of R's important built-ins that cannot be overwritten.

## Set operators {#set-ops}

`unique(x)` returns the values appearing of `x`. That is, every element of `unique(x)` is unique .

`x %in% y` tests each element of `x` for membership in `y`, returning a TRUE/FALSE vector of the same length as `x`. 

As documented at `?sets`, we can write

- $x\cup y$ as `union(x,y)`,
- $x\cap y$ as `intersect(x,y)`,
- $x\ \backslash\ y$ as `setdiff(x,y)` and 
- $x = y$ as `setequal(x,y)`.

To extend to finite unions and intersections, we can write

- $\bigcup_{{s}_i=1}^n {s}_i$ as `Reduce(union, sList)` and 
- $\bigcap_{{s}_i=1}^n {s}_i$ as `Reduce(intersect, sList)`.

To test whether a condition holds anywhere, use `any(cond)`; and to test if it holds everywhere, `all(cond)`.

To investigate overlap between two sets, I suggest rolling a custom function:

```{r set-overlap}
xtab_set <- function(A, B){
  both    <-  c(A, B)     # or union(A, B) if there are no dupes in either set
  inA     <-  both %in% A
  inB     <-  both %in% B
  
  return(table(inA, inB))
}

set.seed(1)
A <- sample(letters[1:20], 10, replace = TRUE)
B <- sample(letters[1:20], 10, replace = TRUE)
xtab_set(A, B)
```

It is also possible to visualize set overlaps [using nice packages for Venn diagrams](http://stackoverflow.com/q/31681110).

`unique` works as one might expect on a data.frame (by "dropping duplicated rows" in Stata-speak), but none of the other functions carry over. In section \@ref(dt-set-ops), we'll look at set operations for data.tables.

### set operations {#dt-set-ops}


## Working with lists and data frames

If we want to compute a new column for a data frame, the syntax can get messy:

```{r with-needed}
DF = data.frame(x = 1:3, y = 4:6)
DF$x + DF$y
```

There are a few ways to get around this: `with`, `within`, `attach` and `transform`. Among these, only `with` is worth learning, in my opinion. Its syntax -- which works for both data frames and lists -- is like

```{r with, eval=FALSE}
with(L, {
  ... do stuff ...
  
  result
})
```


The next section shows a use-case. In \@ref(data-table), we will see data.table's solution to this problem. In \@ref(formula-interface), a 

<span class="spnote" id="dont-attach">
**`attach()`.** Don't use it.
</span>

> The possibilities for creating errors when using attach are numerous. Avoid it. -- [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml#attach)

## Combinatorics

outer -> combn section

maybe a nice combinatorics example http://stackoverflow.com/a/36942700

## Runs

In time series, it is common to have repeated values, called "runs" or "spells." To work with these, use `rle` ("run length encoding") and `inverse.rle`: 

```{r rle}
x = c(1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1)
rle(x)
```

Because the result is a list, we can use `with` on it (as discussed in the last section). For example, if we just want the final three runs:

```{r with-rle}
r = rle(x)
new_r = with(r, {
  new_lengths = tail(lengths, 3)
  new_values  = tail(values, 3)
  
  list(lengths = new_lengths, values = new_values)
})
inverse.rle(new_r)
```

In section  ... rleid

## Iterating over lists {#lapply}

lapply

lengths

rbind, cbind

pmin, pmax

do.call and lists of arguments

Map, Reduce

unlist

## Applying functions along a dimension of an array or matrix

only use apply with matrices/arrays and only when there's no better alternative (max.col, etc.)

## Using grouping variables

tapply, ave -- too many quirks in functionality, arguments, names, so don't bother. e.g., x = c("A","B","B"); ave(x, x, FUN = function(z) length(unique(z)) > 1L)  gives characters -- forget that

split

## Chains of functions

magrittr is great for interactive use

but it can slow your code down


## Asking questions online

if using random example data, use set.seed

test the example in a new session to make sure it runs on its own

built-in data sets

don't worry about making objects with the same names as built-ins (rivers, state.abb, etc)

use built-in data sets or simple hand-made examples

provide expected output

isolate the problem

if it's a performance question, write the example as a function of n and look at other good performance questions

try your code in a new R session to make sure it works as you described

if it's regex (it's usually regex), maybe don't post to SO, try chat


library(help="datasets") as here http://stackoverflow.com/a/8368263/

