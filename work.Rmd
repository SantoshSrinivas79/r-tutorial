# Getting work done {#work}

This chapter covers common analytical tasks (without any discussion of their statisical justification).

## Sets and combinations

todo -- bring this section back


## Randomization

To make your draw reproducible, use `set.seed` before it:

```{r set-seed, eval=FALSE}
set.seed(1)
rnorm(10)
```


### Distribution draws

To draw `n` random numbers from the unit interval, use `runif(n)`. All random-draw functions follow this naming convention -- `rnorm`, `rpoisson`, `rbinom` -- for a full list of the built-in ones, type `?distributions`. Many more are offered in packages that can be found by searching online.

details -- quickly glance at a function with curve()


### Urn draws

To take `n` samples from `x` with replacement, where `p[i]` is the probability of drawing `x[i]`: 

```{r sample, eval=FALSE}
sample(x, prob = p, size = n, replace = TRUE)
```

The help page `?sample` covers many other use cases. There is one to be very wary of, however:

```{r sample-bad}
set.seed(1)
x = c(6.17, 5.16, 4.15, 3.14)
sample(x, 2, replace = TRUE)
y = c(6.17)
sample(y, size = 2, replace = TRUE)
```

Where did `4` and `6` come from? Those aren't elements of `y`!

```{block2 sampling, type='rmd-caution'}
**Sampling from a numeric vector.** Vanilla `sample` cannot be trusted on numeric or integer vectors unless you are sure they have a length greater than 1. 
```

I should have instead sampled from `y`s indices like 

```{r sample-better, eval=FALSE}
y[sample.int(length(y), size = 2, replace = TRUE)]  
# or
y[sample(seq_along(y), size = 2, replace = TRUE)]  
```

To take draws without replacement, just use the option `replace = FALSE`.

### Permutations

Taking a random permutation of a vector is just a special case of drawing from an urn. We're drawing *all* balls from the urn without replacement:

```{r permute-danger, eval=FALSE}
y = c(1, 2, 3, 4)
sample(y) # using default replace = FALSE
```

The same warning for length-zero or length-one vectors applies here. The safer way is:

```{r permute-better, eval=FALSE}
y = c(1, 2, 3, 4)
y[sample.int(length(y))]
# or
y[sample(seq_along(y))]
```


### Simulations

If you have a random process to repeat `nsim` times, the `replicate` function is the answer. Suppose we want to take 10 standard normal draws and return the top three:

```{r replicate}
nsim = 2
n    = 10
set.seed(1)
replicate(nsim, rnorm(n) %>% sort %>% tail(3))
```

The `set.seed` line is added so that the results are reproducible.

#### Complicated output

By default, `replicate` simplifies the result to a matrix. For more complicated results, it is often better to have a list. Suppose we want to grab the top three values as well as the mean:

```{r replicate-list}
nsim = 2
n    = 10
set.seed(1)
replicate(nsim, rnorm(n) %>% { list(mu = mean(.), top3 = sort(.) %>% tail(3)) }, simplify = FALSE)
```

Thanks to use of the same seed (with `set.seed`), the simulated values here are the same as in the last section.

#### Speed and pipes

As a reminder, magrittr pipes -- `%>%` -- are slow. Here's a benchmark (with results measured in seconds):

```{r magrittr-perf, cache=TRUE}
nsim = 1e4
n    = 1e2
system.time(replicate(nsim, simplify = FALSE,
    rnorm(n) %>% { list(mu = mean(.), top3 = sort(.) %>% tail(3))}
))

system.time(replicate(nsim, simplify = FALSE, {
    x = rnorm(n)
    list(mu = mean(x), top3 = tail(sort(x),3))
}))
```

So while it may be convenient to write a quick simulation using pipes, it's better to switch to vanilla R when speed is important. 

```{block2 sim-speed, type='rmd-details'}
**Other options for speed.** Beyond writing in vanilla R instead of pipes, further improvements might be found by writing as much of the simulation as possible in matrix algebra (possibly even combining "separate" simulations into a single computation). Translating to C++ or parallelizing may also be worth considering. For more details, the [High Performance Computing Task View on CRAN](https://cran.r-project.org/view=HighPerformanceComputing).
```

#### Multiple parameters

If running multiple simulations with different parameters, I recommend starting with results in a data.table with one row per run:

```{r sim-fancy, echo=-5}
simparmDT = data.table(set_id = LETTERS[1:2], nsim = 3, n = 10, mu = c(0, 10), sd = c(1, 2))

set.seed(1)
simDT = simparmDT[, .(
    # assign a unique ID to each run
    run_id = sprintf("%s%03d", set_id, seq.int(nsim)),  
    # run simulations, storing results in a list column
    res = replicate(nsim, simplify = FALSE, {
        x = rnorm(n, mu, sd)
        list(mu = mean(x), top3 = tail(sort(x),3))
    })
), by=set_id]
simDT
```

For cleaner code and easier debugging, it's probably best to write the core simulation code as a separate function:

```{r sim-fn}
sim_fun = function(n, mu, sd){
    x = rnorm(n, mu, sd)
    list(mu = mean(x), top3 = tail(sort(x),3))
}
```

Then the code to call it can be agnostic regarding the details of the function:

```{r sim-fn-use}
set.seed(1)
simDT = simparmDT[, .(
    run_id = sprintf("%s%03d", set_id, seq.int(nsim)),  
    res = replicate(nsim, do.call(sim_fun, .SD), simplify = FALSE)
), by=set_id, .SDcols = intersect(names(simparmDT), names(formals(sim_fun)))]

```

We are setting `.SDcols` to be those names that are used as arguments to `sim_fun` and also appear as columns in `simparmDT`. That is, we are taking the intersection of these two vectors of names.

todo -- check where do.call and intersect are introduced and link to them

Next we can extract all components as new columns (still sticking with one row per simulation run):

```{r sim-fancy-fin}
simDT[, (names(simDT$res[[1]])) := res %>% 
    # put non-scalar components into lists
    lapply(function(run) lapply(run, function(x) 
        if (is.atomic(x) && length(x) == 1L) x
        else list(x)
    )) %>% 
    # combine rows into one table
    rbindlist
][]
```

## Working with sequences {#sequences}

Often we care not only about the value in the current row, but also in the previous `k` rows or all previous rows.

### Lag operators {#lag}

Data.table provides a convenient tool for the lag operator and its inverse, a "lead operator":

```{r shift}
x = c(1, 3, 7, 10)
shift(x)                # lag
shift(x, type = "lead") # lead
shift(x, 0:3)           # multiple lags
```

`shift` always returns vectors of the same length as `x`, which works well with data.tables:

```{r shift-dt, echo=-3}
# add to an existing table
DT = data.table(id = seq_along(x), x)
DT[, sprintf("V%02d", 0:3) := shift(x, 0:3)][]

# make a new table
shiftDT = setDT(c(list(x = x), shift(x, 0:3)))    
shiftDT
```


The `embed` function from base R may also be useful when handling lags. It extracts all sequences of a given size:

```{r embed}
embed(x, 3)
```

### Taking differences

A simple common use for `shift` is taking differences across rows by group:

```
DT = data.table(id = c(1L, 1L, 2L, 2L), v = c(1, 3, 7, 10))
DT[, dv := v - shift(v), by=id]
# fill in the missing lag for the first row
DT[, dv_fill := v - shift(v, fill = 0), by=id][]
```

There is also a `diff` function in base R, but it is less flexible than computing differences with `shift`; and it does not return a vector of the same length as its input.

### Rolling computations

general solution is a non-equi join

for computational reasons, this is best avoided

cummax, cummin, cumsum


zoo, RcppRoll also exist


### Run-length encoding

In time series, it is common to have repeated values, called "runs" or "spells." To work with these in a vector, use `rle` ("run length encoding") and `inverse.rle`: 

```{r rle}
x = c(1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1)
rle(x)
```

Because the result is a list, we can use `with` on it (as discussed in the last section). For example, if we just want the final three runs:

```{r with-rle}
r = rle(x)
new_r = with(r, {
  new_lengths = tail(lengths, 3)
  new_values  = tail(values, 3)
  
  list(lengths = new_lengths, values = new_values)
})
inverse.rle(new_r)
```

In section  ... rleid

show with(rle(x), ) refer to environments

### Grouping on runs

`cut` and `findInterval` are good ways to construct groups from intervals of a continuous variable.

To group by sequences, it is often useful to take advantage of...

- *Cumulative sums*: `cumsum`
- *Differencing*: `diff` or `x - shift(x)`, explained in \@ref(lag)
- *Runs*: `rleid` and `rle`

To label rows *within* a group, use data.table's `rowid`. To label groups, use data.table's `.GRP`, like `DT[, g_id := .GRP, by=g]`.

It's often tempting in R to run computations by row, like `DT[, ..., by=1:nrow(DT)]` but this is almost always a bad idea, both in terms of clarity and speed.


## Combining table columns

do.call
pmin, pmax
shift

ex, creating indices with Map, Reduce

ex, computing euclidean distance moved: shift lapply Reduce sqrt

ex, with pmin vs some capacity


details -- Passing a list of arguments to a function with do.call like python kwargs

caution -- never write a program with rowwise operations on a table, which is column-major -- super slow, weird side effects from combining classes

precomputing indices http://stackoverflow.com/q/19279075

## Regression {#reg}

(so far, we've just talked about data manipulation, now onto math/stats)

obvs, if your problem has a closed form solution, do the matrix algebra and don't get bogged down in syntax oddities of a particular language

seriously consider using a matrix or array if it fits the problem

show an example of reg by group

### Extracting results

zzz


## Optimization

of course, we end up with an approximation

## Integration

of course, we end up with an approximation

## String operations

In my opinion, very few string operations are necessary after proper data cleaning (discussed in \@ref(structuring-data)).

`nchar(x)` tells you how long a string is, and `substr(x, start, end)` extracts a contiguous substring. `paste`, `paste0` and `sprintf` are used to build strings, while `sub` and `gsub` rewrite strings.

nzchar

`grep` and its family will match a string pattern, while `regmatches` can extract what matches. `strsplit(x, sep=",")` can split `"Butte, Montana"` into its constituent parts. Handier tools for these tasks are discussed in \@ref(structuring-data).

escaping in regex `\\`




