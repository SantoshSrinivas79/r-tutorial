This is just a drop-off for SO.Docs materials that will be shunted to JSON shortly. 

* Header = "topic"
* H2 = "example", contents indented

It probably won't compile as a proper rmd.

See https://github.com/franknarf1/r-tutorial/issues/12

Some of them can be added as "exercises" maybe

## data.table Syntax and features

    # Basic syntax

    `DT[where, select|update|do, by]` syntax is used to work with columns of a data.table.
     - The "where" part is the `i` argument
     - The "select|update|do" part is the `j` argument

    These two arguments are usually passed by position instead of by name.

    A sequence of steps can be chained like `DT[...][...]`.

    # Shortcuts, special functions and special symbols inside `DT[...]`
    | Function or symbol | Notes |
    | ------  | ------ |
    | `.()`   | in several arguments, replaces `list()`
    | `J()`   | in `i`, replaces `list()`
    | `:=`    | in `j`, a function used to add or modify columns
    | `.N`    | in `i`, the total number of rows <br> in `j`, the number of rows in a group
    | `.I`    | in `j`, the vector of row numbers in the table (filtered by `i`)
    | `.SD`   | in `j`, the current subset of the data <br> selected by the `.SDcols` argument
    | `.GRP`  | in `j`, the current index of the subset of the data
    | `.BY`   | in `j`, the list of by values for the current subset of data
    | `V1, V2, ...`  | default names for unnamed columns created in `j`

    # Joins inside `DT[...]` 

    | Notation | Notes |
    | ------  | ------ |
    | `DT1[DT2, on, j]`  | join two tables
    | `i.*`  | special prefix on DT2's columns after the join
    | `by=.EACHI`  | special option available only with a join
    | `DT1[!DT2, on, j]`  | anti-join two tables
    | `DT1[DT2, on, roll, j]`  | join two tables, rolling on the last column in `on=`

    # Reshaping, stacking and splitting

    | Notation | Notes |
    | ------  | ------ |
    | `melt(DT, id.vars, measure.vars)`  | transform to long format  <br> for multiple columns, use `measure.vars = patterns(...)`
    | `dcast(DT, formula)`  | transform to wide format
    | `rbind(DT1, DT2, ...)`  | stack enumerated data.tables
    | `rbindlist(DT_list, idcol)`  | stack a list of data.tables 
    | `split(DT, by)`  | split a data.table into a list 

    # Some other functions specialized for data.tables

    | Function(s) | Notes |
    | ------  | ------ |
    | `foverlaps` | overlap joins
    | `merge` | another way of joining two tables
    | `set` | another way of adding or modifying columns
    | `fintersect`, `fsetdiff`, <br> `funion`, `fsetequal`, <br> `unique`, `duplicated`, `anyDuplicated` | set-theory operations with rows as elements  
    | `CJ`| the Cartesian product of vectors
    | `uniqueN`  | the number of distinct rows
    | `rowidv(DT, cols)`  | row ID (1 to .N) within each group determined by cols
    | `rleidv(DT, cols)`  | group ID (1 to .GRP) within each group determined by runs of cols
    | `shift(DT, n)` | apply a shift operator to every column
    | `setorder`, `setcolorder`, <br> `setnames`, `setkey`, `setindex`, <br> `setattr` | modify attributes and order by reference

    # Other features of the package

    | Features | Notes |
    | ------  | ------ |
    | `IDate` and `ITime` | integer dates and times
  [1]: http://r-datatable.com


      # Advantages to using separate tables

      The advantages of this structure are covered in the paper on tidy data, but in this context:

      1. *Tracing missing data.* Only rows that match up in the merge receive an assignment. We have no data for `geo_id == "MO"` above, so its variables are `NA` in our final table. If we see missing data like this unexpectedly, we can trace it back to the missing observation in the `geoDT` table and investigate from there whether we have a data problem that can be addressed.

      2. *Comprehensibility.* In building our statistical model, it might be important to keep in mind that `budget` is constant for each performer. In general, understanding the structure of the data pays dividends.

      3. *Memory size.* There might be a large number of performer and location attributes that don't end up in the statistical model. This way, we don't need to include them in the (possibly massive) table used for analysis.

      # Programmatically determining columns

      If there are many columns in `pDT`, but we only want to select a few, we can use

          p_cols = "budget"
          DT[pDT, on=.(p_id = id), (p_cols) := mget(sprintf("i.%s", p_cols))]

      The parentheses around `(p_cols) :=` are essential, as noted in [the doc on creating columns][2].


        [1]: https://www.jstatsoft.org/article/view/v059i10
        [2]: http://stackoverflow.com/documentation/data.table/3781/adding-and-modifying-columns#t=201608011727370681989

# Using keys and indices

The key and indices of a data.table allow certain computations to run faster, mostly related to joins and subsetting. The key describes the table's current sort order; while each index stores information about the order of the table with respect a sequence of columns. See the "Remarks" section below for links to the official vignettes on the topic.

## Remarks

      The official vignettes are the best introduction to this topic:

      - ["Keys and fast binary search based subset"][1]
      - ["Secondary indices and auto indexing"][2] 


      # Keys vs indices

      A data.table can be "keyed" by a sequence of columns, telling interested functions that the data is sorted by those columns. To get or set the key, use the functions documented at `?key`.

      Similarly, functions can take advantage of a data.table's "indices." Each index -- and a table can have more than one -- stores information about the order of the data with respect a sequence of columns. Like a key, an index can speed up certain tasks. To get or set indices, use the functions documented at `?indices`. 

      Indices may also be set automatically (currently only for a single column at a time). See `?datatable.optimize` for details on how this works and how to disable it if necessary.

      # Verification and updating

      Missing values are allowed in a key column.

      Keys and indices are stored as attributes and may, by accident, not correspond to the actual order of data in the table. Many functions check the validity of the key or index before using it, but it's worth keeping in mind.

      Keys and indices are removed after updates where it's not obvious that sort order is preserved. For example, starting from `DT = data.table(a=c(1,2,4), key="a")`, if we update like `DT[2, a := 3]`, the key is broken.


        [1]: https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-keys-fast-subset.html
        [2]: https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-secondary-indices-and-auto-indexing.html

## Improving performance for selecting subsets

          # example data
          set.seed(1)
          n  = 1e7
          ng = 1e4
          DT = data.table(
              g1  = sample(ng, n, replace=TRUE),
              g2  = sample(ng, n, replace=TRUE),
              v  = rnorm(n)
          )

      # Matching on one column

      After the first run of a subsetting operation with `==` or `%in%`...

          system.time(
              DT[ g1 %in% 1:100]
          )
          #    user  system elapsed 
          #    0.12    0.03    0.16 

      An index has been created automatically for `g1`. Subsequent subsetting operations run almost instantly:

          system.time(
              DT[ g1 %in% 1:100]
          )
          #    user  system elapsed 
          #       0       0       0

      To monitor when an index is created or used, add the `verbose=TRUE` option or change the global setting `options(datatable.verbose=TRUE)`.

      # Matching on multiple columns

      Currently, matching on two columns does not automatically create an index:

          system.time(
              DT[ g1 %in% 1:100 & g2 %in% 1:100]
          )
          #    user  system elapsed 
          #    0.57    0.00    0.57

      Re-run this and it will remain slow. Even if we manually add the index with `setindex(DT, g1, g2)`, it will remain slow because this query is not yet optimized by the package. 

      Fortunately, if we can enumerate the combinations of values we want to search for and an index is available, we can quickly equi-join:

          system.time(
              DT[ CJ(g1 = 1:100, g2 = 1:100, unique=TRUE), on=.(g1, g2), nomatch=0]
          )
          #    user  system elapsed 
          #    0.53    0.00    0.54 
          setindex(DT, g1, g2)
          system.time(
              DT[ CJ(g1 = 1:100, g2 = 1:100, unique=TRUE), on=.(g1, g2), nomatch=0]
          )
          #    user  system elapsed 
          #       0       0       0

      With `CJ`, it's important to watch out for the number of combinations becoming too large.







