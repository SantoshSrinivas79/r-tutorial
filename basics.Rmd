---
output: html_document
---
# Basics {#basics}

## Vectors

In R, all data come in vectors. If you type `x = 54.7`, then `x` will be a numeric vector of length 1. Similarly, `y = c("Abc", "xY_z")` is a character vector of length 2. After assigning a vector, you can type its name to see it and use `length` and `class` to see those attributes.

```{r length-pre}
x = c(TRUE, FALSE, TRUE)
```
```{r length}
x
length(x)
class(x)
```

The bracketed `[1]` indicates that we are seeing the first element of a vector. This printing pattern is handy with vectors too long for a single line. You can assign with `=` or `<-`. You can even assign like `c(2,3) -> z`, but this is rare and hard to read in my opinion.

### Documentation

Everything in the base installation of R is documented in convenient wikified html pages. These can be accessed with `?` or `help`. For example, `?TRUE` or `?length`. Backticks are sometimes required, as for ``?`(` `` and ``?`?` ``. Keep a close eye on the Description and Value sections, which concisely explain what to expect from a function.

### Classes {#classes}

All elements of a vanilla vector must have the same class, so

```{r coercion}
c(4, c("A", "B"))
```

<span class="spnote" id="coercion">
**Coercion.** The `4` is "coerced" to `character`, with no warning given. 
</span>

This behavior is explained in the Details section of `?c`, which also conveniently lists all of the vanilla ("atomic") classes. The key ones are `logical`, `integer`, `numeric` and `character`. A `list` is a special type of vector whose elements can be arbitrary objects. For example, we can have a list of vectors:

```{r lists}
L  = list("A", c(1,2))
L2 = list(FALSE)
c(L, L2)
```


<span class="spdetails" id="classes_detail">
Fancier classes are generally built on top of atomic classes or lists. Behind the scenes, date formats are numeric or integer; while complex objects like data sets and regression results are lists. For details on storage modes, see `?typeof` and the [R internals](https://cran.r-project.org/doc/manuals/r-release/R-ints.html) documentation. While some fancy data structures like linked lists and unordered sets are absent in base R, they can be used through packages like Rcpp. 
</span>

### Named elements

A vector's elements can be named:

```{r naming}
c(a = 1, b = 2)
list(A = c(1, 2), B = 4)
```

<span class="spnote" id="arguments">
**Passing arguments.** In `c(A = 1)`, the equals sign is not interchangeable with the `<-`, so you should not write `c(A <- 1)`. Think of `c` as a function with syntax like `c(argname = argvalue, argname2 = argvalue2, ...)`. The equals sign just plays the special role of giving names to the function's arguments.
</span>

Names are more useful for lists than vanilla vectors, where they are usually unnecessary and quickly get messy. For example, try `c(1, X = c(a = 2, b = 3, 4))` or `c(A = 1, A = 1)`.

### Missing values

R distinguishes itself from other programming languages by its careful treatment of missing values. See `?NA`. As explained there, the missing-data code `NA` is to be distinguished from a non-number, `NaN`, and from the absence of an object, `NULL`, for example in `list(A = 1, B = NULL)`.


### Slicing

We can select a subvector of `x` like `x[i]`:

```{r slicing-pre}
x = c("a", "b", "c", "d")
L = list(X = 1, Y = 2, Z = 3)
```
```{r slicing}
x[c(1, 3)]
x[-c(2, 3)]
L[c("Y","Z")]
x[c(FALSE, TRUE, TRUE, FALSE)]
```

So, the index `i` can be a vector of positions to include; a negated vector of positions to exclude; a vector of element names; or a TRUE/FALSE vector, with a selection rule for each position. 

`x[i]` notation can also be pushed beyond subsetting, by passing repeated values.

```{r repslicing}
x[c(1, 3, 3, 2)]
```

By the way, no one else calls this "slicing"; so sue me.

<span class="spnote" id="recycling">
**Recycling.** What would you expect `x[TRUE]` to do in the example above? Well, in R, it is treated like `x[c(TRUE, TRUE, TRUE, TRUE)]`. This is called recycling -- the argument `i` is repeated until it is long enough for the context. While this behavior is usually convenient, it is worthwhile to grok what, for example, what `x[c(TRUE, FALSE)]` is doing. 
</span>

Because recycling is so central to R, no warnings are given when it happens. Along with coercion \@ref(classes) -- like `c(4, c("A", "B"))` -- this is one of the most confusing features for a new R user.

### Extracting

<span class="spdetails" id="bracket-docs">
For documentation on slicing and extracting, you can type ``?`[[` ``. Brackets come in pairs but are just named after their opener. This naming pattern will come up again later in \@ref(lapply) when working with lists of lists. 
</span>

`$` is another way

### Initializing and subassigning

In R, it bad practice to dynamically grow objects, like `x = 1`, `x = c(x,2)`, ..., `x = c(x,n)`. Instead, preallocate with `vector` or a related function and assign:

```{r preallocate, eval=FALSE}
x = vector(5, mode = "list")
y = logical(5)
```

note -- MATLAB-style multiple assignment is not possible, but you can do

L[c(2,3)] <- list(y, z)

beware recycling here again

You can coerce `x` to a higher class through assignment, like `x[1] <- "a"`, but this is generally a bad idea. 

As with "slicing," no one calls this "subassigning," but they should.

generally, you don't want to get too fancy with subassignment. we'll see a nicer way to do it with \@ref(data.table), covering most practical applications.

### Sorting

factors, ordered factors


### Exercises

1. What is the class of `c(TRUE, 1L)`?


## Syntax

floating point issues are real. For example, .1 + .05 - .15 is not necessarily zero
[so post](http://stackoverflow.com/questions/9508518/why-are-these-numbers-not-equal)

note -- infix operators also need backticks to find their help pages

vectorization


## Writing and importing functions


custom infix operators


## Matrices and Arrays

Technical aside: The terminology is a bit weird here. In most programming languages, an *array* is a vector

```{block, type='rmdcaution'}
regarding drop
```

note -- because an array is just a trussed up vector, [[ extraction works, but is rarely useful

## Randomization



## Loops and Control Flow {#loops}


## Data frames

rules for extracting are a mess. we'll see data.table soon

note -- use the right tool for the job. if the work you're doing is in linear algebra, use a matrix. many simulations are also best handle with matrices and arrays, rather than data frames. data frames are only for mixed classes of data.



