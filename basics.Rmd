---
output: html_document
---
# Basics {#basics}

## Vectors

In R, all data come in vectors. If you type `x = 54.7`, then `x` will be a numeric vector of length 1. Similarly, `y = c("Yah", "Bada bing")` is a character vector of length 2. You can type a vector's name to see it, and use `length` and `class` to see those attributes.

```{r length-pre}
# example data
x = c(TRUE, FALSE, TRUE)
```
```{r length}
x
length(x)
class(x)
```

The bracketed `[1]` indicates that we are seeing the first element of a vector. This printing pattern is handy with vectors too long for a single line -- try looking at `x = 1:500`. 

You can assign with `=` or `<-`. You can even assign like `c(2,3) -> z`, but this is rare and hard to read in my opinion. If an existing vector is overwritten, no warning is given.

### Documentation

Everything is documented in convenient wikified html pages, accessible with `?` or `help`. For example, `?TRUE` or `?length`. Backticks are sometimes required, as for ``?`(` `` and ``?`?` ``. Keep a close eye on the Description and Value sections, which concisely explain what to expect from a function. Manuals and additional reference documents can be found by typing `help.start()`.

R doesn't do error codes, only error messages and warnings. If you don't understand a message you're seeing, a search online or a review of the relevant docs is usually sufficient.

### Classes {#classes}

Every vanilla vector has a class. That is, every element of the vector contains the same type of data:

```{r coercion}
c(4, c("A", "B"))
```

<span class="spnote" id="coercion">
**Coercion.** The `4` is "coerced" to `character` above, with no warning given. Since coercion is so central to R and confusing for new users, I strongly suggest reading its documentation, in the Details section of `?c`.
</span>

The doc at `?c` also conveniently lists all of the vanilla ("atomic") classes. The key ones are `logical`, `integer`, `numeric` and `character`. A `list` is a special type of vector whose elements can be arbitrary objects, for example, a list of vectors:

```{r lists-pre}
# example data
L  = list("A", c(1,2))
L2 = list(FALSE)
L3 = c(L, L2)
```
```{r lists}
L3
```

The `[[1]]` printed here indicates the first element of the list, similar to the `[1]` we see for atomic vectors.

<span class="spdetails" id="classes_detail">
**Fancier classes** are generally built on top of atomic classes or lists. Behind the scenes, date formats are numeric or integer; while complex objects like data sets and regression results are lists. For details on storage modes, see `?typeof` and the [R internals](https://cran.r-project.org/doc/manuals/r-release/R-ints.html) documentation. While some fancy data structures like linked lists and unordered sets are absent in base R, they can be used through packages like Rcpp. 
</span>

For lists, in addition to a `length` attribute, we also have `lengths` for each element:

```{r lengths}
L3
lengths(L3)
```

### Inspecting objects {#str}

For complicated objects, like `L3` above, `class(L3)` is not very informative. Examining the "structure" of the object is usually more useful:

```{r str}
str(L3)
```

To really get in the weeds, you can use `typeof`, which says how the object referred to is stored, but this is rarely useful.

We will see later (TODO) that we have better specialized tools for inspecting data.tables.

### Named elements {#names}

A vector's elements can be named:

```{r naming}
c(a = 1, b = 2)
list(A = c(1, 2), B = 4)
```

The names of an objects' elements can be accessed with the `names` function.

<span class="spnote" id="argument-names">
**Passing arguments.** Inside `c(A = 1)`, the equals sign is not interchangeable with the `<-`, so don't write `c(A <- 1)`. Think of `c` as a function with syntax like `c(argname = argvalue, argname2 = argvalue2, ...)`. The equals sign has the special role of giving names to the function's arguments.
</span>

### Missing values {#na}

R differs from other programming languages in its careful treatment of missing values in the reading and processing of data. The missing-data code `NA` is distinct from other special codes:

- a non-number, `NaN`; 
- positive and negative infinity, `Inf` and `-Inf`; and 
- the absence of an object, `NULL`. 

For details, read the "Missing values" section of the "An Introduction to R," a manual reachable by typing `help.start()` and clicking a link.

<span class="spnote" id="na-classes">
**Implementation of missing values.** The class of an `NA` is different depending on the vector it is in. Sometimes, it is important to ensure that a missing value belongs to a particular class. To ensure this, the safest approach is to "slice" an object of that class with `NA_integer_`. For example, to get a missing numeric value, you can use the number `10` like `10[NA_integer_]`; or for a date value, we can use the current date, `Sys.Date()`, like `Sys.Date()[NA_integer_]`. 
</span>


### Slicing to a subvector {#slicing}

Select a subvector of `x` like `x[i]`:

```{r slicing-pre}
# example data
x = c("a", "b", "c", "d")
L = list(X = 1, Y = 2, Z = 3)
```
```{r slicing}
x[c(1, 3)]
x[-c(2, 3)]
L[c("Y","Z")]
x[c(FALSE, TRUE, TRUE, FALSE)]
```

So, the index `i` can be...

- a vector of positions to include; 
- a negated vector of positions to exclude; 
- a vector of element names; or 
- a TRUE/FALSE vector, with a selection rule for each position. 

`i` can even contain repeated elements, like `x[c(1,1,2)]`, which is some more general "slice" of `x`, not really a subvector.

<span class="spnote" id="recycling">
**Recycling.** What would you expect `x[TRUE]` to do in the example above? Well, in R, it is treated like `x[c(TRUE, TRUE, TRUE, TRUE)]`, without giving any warning. This is called recycling -- the argument `i` is repeated until it is long enough for the context is used in. Can you guess what `x[c(TRUE, FALSE)]` does? The full rules for recycling can be found in the [R intro doc](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#The-recycling-rule).
</span>

There are a few edge cases worth noting. As mentioned in \@ref(na), it can be useful to set `i` as `NA_integer_` to find the "missing value version of `x`." Similarly, we can set `i` to `0L` to find the "empty version of `x`." Setting `i` to include positions or names outside of range will just yield missing values and is usually not useful.

### Extracting from a list

Grab a single element of a vector like `x[[i]]`, where `i` is a single name or number:

```{r extract-pre}
# example data
L = list(X = 1, Y = 2, Z = 3)
```
```{r extract}
L["Z"] # slicing
L[["Z"]] # extracting
```

In the example above, the slice `L["Z"]` is a list containing just one element; while `L[["Z"]]` *actually is the element*.

`L$Z` offers a handy alternative way of extracting by name from a list, but it is tougher to write a program around.

### Assigning to a subvector {#subassigning}

Assign to a subvector, or "subassign," like `x[i] = y` or `x[i] <- y`:

```{r subassign-pre}
# example data
x = c("a", "b", "c", "d")
L = list(X = 1, Y = 2, Z = 3)
```
```{r subassign}
x[c(2,4)] <- c("bada", "bing")
L[c("Y", "Z")] = list(21, 31)
```

The allowed values of `i` are the same as we saw for slicing a vector in \@ref(slicing). It is fairly unsafe on account of silent coercion, recycling and failure (when `i` is not a valid index of `x`). We will revisit how to modify vectors after introducing data.tables in \@ref(data-table).

<span class="spnote" id="hidden-docs">
**Hard-to-find documentation.** For documentation on slicing and extracting, you can type ``?`[` ``. Even though there is a `]` for every `[`, it is the opening bracket that is the function's actual name, which will come back in \@ref(lapply). For documentation on sub-assignment, type ``?`[<-` ``.
</span>

One can similarly assign to a single element of a list with `x[[i]] <- y`. If an existing element is overwritten, no warning is given.

### Initializing {#initializing}

In R, it bad practice to dynamically grow objects, like `x = 1`, `x = c(x,2)`, ..., `x = c(x,n)`. Instead, create the vector with its final length first:

```{r preallocate, eval=FALSE}
x = vector(length = 5, mode = "list")
x = character(length = 5)
x = logical(length = 5)
x = numeric(length = 5)
x = integer(length = 5)
```

From there, you can subassign iteratively if necessary.

It's also common to initialize a vector with a particular value using `rep`:

```{r rep}
rep(3, 10)
```

`rep(x, n)` extends nicely to the case where `x` is a vector. It does this in a few different configurations, as documented at `?rep`:

```{r rep-vec}
rep(c(3, 4), 5)
rep(c(3, 4), each = 5)
rep(c(3, 4), length.out = 5)
rep(c(3, 4), c(3, 4))
```

### Factors

As with missing values, a lot of thought was put into the treatment of categorical data in R, captured by the `factor` data type:

```{r factors}
factor(c("New York", "Tokyo", "Mumbai", "Tokyo"))
```

Here, the factor is being constructed from a character vector, but usually our data is already a factor when it is read into R (since that is the default interpretation assigned to strings found in raw input data). 

Factors usually have no sense of ordering (like "Tokyo" naturally coming before "Bombay"), but one can be added if appropriate:

```{r ordered-factors}
factor(c("Worst", "Best", "Not Bad", "Worst"), levels = c("Worst", "Not Bad", "Best"), ordered = TRUE)
```

To see whether a factor has an order, use `is.ordered`. Details on manipulating factors can be found at `?factor` and linked pages.

### Sorting, rank, order

There are three key functions here:

- `sort(x)` will sort the vector.
- `rank(x)` tells how far forward each element of `x` is in its pecking order.
- `order(x)` is rarely useful on its own, but `y[order(x)]` will sort `y` by `x`.

Be careful not to use these functions on an unordered factor, where they will make no sense but run without warning.

The `frank()` function (yes, really) from the data.table package is also useful, for its "dense" rank tie-breaking rule.

### Exercises

1. What is the class of `c(TRUE, 1)`?
2. What is the length of `list(1, c(2,3))`?
3. If I run `x = c("a","b")` and then `x[c(2,1)] = c("c","d")`, what is the value of `x[1]`?
4. Write the command to summon documenation for for the assignment procedure used in `L$X <- list(3)`?

## Matrices and Arrays

The `matrix` function is used for construction:

```{r matrix-build-pre}
# example data
v = c(1,2,3,4)
```
```{r matrix-build}
matrix(v, nrow = 2, ncol = 2)
matrix(v, nrow = 2, ncol = 2, byrow = TRUE)
```

All elements of a matrix must have the same class, just like a vector. So you can have a "character matrix", a "numeric matrix", etc. In fact, a matrix *is* a vector, just augmented by an attribute capturing its dimensions, accessible with the `dim` function.

Recycling applies here again. Try `matrix(v, nrow = 4, ncol = 4)`. If we just want `v` to fill out the matrix once, it is not necessary to give both `nrow` and `ncol`, like `matrix(v, nrow = 2)`. If the dimensions don't make sense for the input vector, `matrix(v, nrow = 3)`, R will mercifully throw a warning.

### Named rows and columns

Rows and columns can be named:

```{r matrix-naming}
matrix(c(1,2,3,4), nrow = 2, dimnames = list(c("a","b"), c("c","d")))
```

### Slicing to a submatrix

To take a matrix slice, selecting a submatrix, use `m[i,j]` as in math:

```{r matrix-slicing-pre}
# example data
m = matrix(c(1,2,3,4,5,6), nrow = 2)
```
```{r matrix-slicing}
m[1, c(1,2), drop = FALSE]
```

You can get fancy with indices, in all the ways described in \@ref(slicing). It is often covenient to leave one index blank, which means "select all rows/columns"; try `m[, 2, drop = FALSE]`. 

<span class="spcaution" id="drop">
**Dropped dimensions.** The `drop = FALSE` option is necessary to ensure that the result is a submatrix. R's default behavior is to "drop" dimensions when it can, which makes for unpredictable output.
</span>

### Extracting from matrices

Since matrices *are* vectors, we can extract a vector of values in the same way:

```{r matrix-vecsubset}
m[3]
m[c(2,3)]
```

Matrices also allow extraction like `X[Y]`, where `Y` is a two column "index matrix":

```{r matrix-matsubset}
im = matrix(c(1,1,2,2), 2, 2, byrow=TRUE)
m[im]
```

The first column corresponds to rows, and the second to columns.

### Subassigning to matrices

Assign to elements of a matrix in one of a few ways: 

- `x[i,j] = z` where `i` and `j` are rows and columns, respectively
- `x[i] = z` with `i` being an index vector
- `X[Y] = z` with `Y` being an index matrix

In all cases, `z` is a vector or matrix of values.

### Arrays

Arrays are the same as matrices, just in higher dimensions. For example, a three-dimensional array will have a `dim` attribute of length three and have slicing syntax like `a[i,j,k]`.

## Syntax

### Assigning to attributes

There are convenience functions for modifying object attributes, with syntax like `names(x) <- y` or `names(x) = y`. A few are for...

- vector element names, `` ?`names<-` `` 
- vector class, `` ?`class<-` ``
- vector length, `` ?`length<-` ``
- matrix or array dimensions, `` ?`dim<-` `` 
- matrix or array names, `` ?`dimnames<-` `` 

These are rarely needed and can be confusing for obvious reasons.

### Arithmetic

The full set of arithmetic operators is documented at `?Arithmetic`. The integer division and modulo operators look like `%/%` and `%%`, but otherwise, everything is standard.

Other basic functions include `round`, `floor`, `ceiling`, `min`, `max`, `log`, `exp`, `sqrt`.

As in [any other programming environment](http://floating-point-gui.de/), floating point arithmetic in R can trip up calculations. For example, try `.1 + .05 - .15 == 0`.

<span class="spnote" id="arithmetic-bools">
**Arithmetic with logical values.** Particularly when exploring data, we often want to tally observations meeting some condition. To do this in R, we can treat true/false like 1/0: `is_gt = c(1,5,2) > c(1,2,3); sum(is_gt)`. Fancier tallying methods are covered in \@ref(tallying) and \@ref(exploring-data).</span>

### Logical operators



<span class="spnote" id="logical-nums">
**Logical operations with numeric values.** Particularly when exploring data, we often want to tally observations meeting some condition. To do this in R, we can treat true/false like 1/0: `is_gt = c(1,5,2) > c(1,2,3); sum(is_gt)`.</span>

### Matrix algebra

note -- infix operators also need backticks to find their help pages, also can be written as prefix

matrix operators: %/%, t, %*%
recall that vanilla mult is elementwise, silently recycles

### Order of operations

The order of operations is listed in `?Syntax`. In addition to the operators listed, `**` is an alias for `^`. The `%any%` listed there refers to a broad class of "infix" or binary operators: `%/%` and `%%` for integer division and modulo; and `%*%` for matrix multiplication; and any custom infix operators defined by the user, covered more in .

### Elementwise operations and "code vectorization"

Most operations in R are performed elementwise:

```{r element}
x = c(1, 2)
y = c(2, 3)
x / y
x ^ y
```

We call functions with this behavior "vectorized." R is a lot faster when operations are performed elementwise rather than in a loop, so there's a common mantra to "vectorize your code," especially when doing arithmetic. The idea is similar to translating a statistical model into matrix algebra.

<span class="spnote" id="recycling-again">
**Recycling, again.** As we saw in \@ref(slicing), recycling kicks for any vectorized function. So we have `c(-2,2) ^ c(1,2,3,4)` working, with no warning given. Fortunately, there is a warning if the recycling is imperfect, like `c(-2,2) ^ c(1,2,3)`.</span>

A couple of notably non-vectorized functions are `&&` and `||`. These will (silently) only look at the first element on each side; and if the result can be determined using the left-hand side, for example in `FALSE && x`, then the right-hand side will not be evaluated. These are useful mostly for improving efficiency on the margins.

### Function arguments

Compare the documentation `?vector` against my usage in \@ref(initializing):

```{r preallocate-again, eval=FALSE}
x = vector(length = 5, mode = "list")
```

I passed the arguments out-of-order. This is safe so long as you name every argument. Passing arguments by the position, like `sort(x, TRUE)`, is a riskier proposition, since it is harder to get right initially and to interpret correctly later.

## Functions

### Structure and documentation

Functions in R all map input to output. In the documentation for a function, the input is covered in the "Arguments" section, while the output is in the "Value" section.

### Finding function source code


getAnywhere()

also point to "methods" sec and mention C



### Writing functions

Like any other object, functions can be given names:

```{r fn-def-pre}
f = function(x) x
```

#### Scoping

Some functions in base R are primarily useful for their "side effects," like `?rm` and `` ?`[<-` ``, and in \@ref(data-table), we will look at the data.table package, which is designed around modifying objects "in-place." As a normal user, however, there is almost never a good reason to write a function with side effects. So, I suggest ignoring ``?`<<-` `` and `?assign`.

#### Lazy evaluation

R is very lax about using globals 

### Custom operators



### Loading community-made functions

#### Exploring packages

R has a variety of packages specialized by task and area of research. The [Task Views](https://cran.r-project.org/web/views/) on the web are a good way to browse available packages on CRAN, the Comprehensive R Archive Network.

Besides adding additional functions, many packages add new classes, for example for time series data.

#### Installing packages

It is best to install packages from CRAN, rather than elsewhere. Packages submitted to CRAN (i) have to pass some vetting procedures defined by the developers of R and and (ii) are typically used much more broadly than those not on CRAN, improving exposure of bugs. 

To install a package from CRAN, use `install.packages('package_name')`. The first time this is run during an R session, a popup will prompt for which mirror to download from. For further options, read `?install.packages`.

#### Using functions from packages

?pkgname::fn


library(pkgname)



https://www.datacamp.com/community/tutorials/functions-in-r-a-tutorial

#### Finding where a function came from

??

findAnywhere


## Loops and Control Flow {#loops}

As in most programming languages, we have `for` loops, `if`/`else` blocks, and so on. Some quirks to note:

- Write `for (x in idx) ...` to iterate over the vector `idx`, even its duplicates.
- Write `if else`, since there is no `ifelse`.
- Use `next` to bust out of the current iteration of a loop.
- Use `break` to bust out of the loop entirely.

Newlines and `{}` are optional in some cases.

ex: create an empty matrix and fill it, row by row

but, if the steps don't really need to be sequential, don't loop

maybe you have a closed-form solution for each row

maybe each row is entirely independent

often, the answer is arithmetic or matrix algebra

for more complicated tasks, use replicate/lapply/sapply (all documented in the same place)

excruciating detail https://www.datacamp.com/community/tutorials/tutorial-on-loops-in-r

## Data frames

recall that in matrices, all elements are of the same class/type

with data sets, we have mixed types

in R, data frames are the container for general data sets

they are implemented as lists of vectors, where each vector has the same length

basic data exploration: View(), table + useNA, summary

rules for extracting are a mess. we'll see data.table soon

note -- use the right tool for the job. if the work you're doing is in linear algebra, use a matrix. many simulations are also best handle with matrices and arrays, rather than data frames. data frames are only for mixed classes of data.


