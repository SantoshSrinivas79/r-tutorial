# Basics {#basics}

This chapter covers R's core data structures and syntax.

## Vectors {#vectors}

In R, all data come in vectors. If we enter `x = 54.7`, then `x` will be a numeric vector of length 1. Similarly, `y = c("Yah", "Bada bing")` is a character vector of length 2. Type a vector's name to see it, and use `length` and `class` to see those attributes.

```{r length-pre}
# example data
x = c(TRUE, FALSE, TRUE)
```
```{r length}
x
length(x)
class(x)
```

The bracketed `[1]` indicates that we are seeing the first element of a vector. This printing pattern is handy with vectors too long for a single line, like `c(LETTERS, letters)`.

Assign with `=` or `<-`. Or even like `c(2,3) -> z`, though this is rare and hard to read in my opinion. If an existing vector is overwritten, no warning is given.

caution -- indexing starting from 1, for those coming from 0-indexed langs, treatment of negative indices in slicing will also be a surprise (ref it)

### Documentation

Everything is documented in convenient wikified html pages, accessible with `?` or `help`. For example, `?TRUE`, `?LETTERS` or `?length`. Backticks are sometimes required, as for ``?`for` `` and ``?`?` ``. Keep a close eye on the Description and Value sections, which concisely explain what to expect from a function. 

The Examples section always usefully illustrates functionality; it can be run in the console like `example("LETTERS")`. Additional illustrations are available using `demo`; type `demo()` for a listing.

Try typing `help.start()`. This will show a page of links to documents including "An Introduction to R", "The R language definition" and the "R FAQ" (under "Resources"). These are essential reference documents on R, also [available in pdf online](https://cran.r-project.org/manuals.html).

R doesn't do error codes, only error messages and warnings. If confused by a message, a search online or a review of the relevant docs is usually sufficient.

### Classes {#classes}

Every vanilla vector has a class. That is, every element of the vector contains the same type of data:

```{r coercion}
c(4, c("A", "B"))
```

```{block2 note-coercion, type='rmd-caution'}
**Coercion.** The `4` is "coerced" to `character` above, with no warning. Since coercion is so central to R and confusing for new users, I strongly suggest reading its documentation, in the Details section of `?c`.
```

The doc at `?c` also conveniently lists all of the vanilla ("atomic") classes. The key ones are

- *Logical*. Use `TRUE` or `FALSE`.
- *Integer*. Write `L` at the end: `1L`, `2L`, etc. The `L` will not be displayed in output.
- *Numeric*. Write it as usual or with `e` notation, `2`, `3.4`, `3e5`.
- *Character*. Use single or double quotes, `"bah"`, `'I say "gah"'`, etc.

A `list` is a special type of vector whose elements can be arbitrary objects, for example, a list of vectors:

```{r lists-pre}
# example data
L  = list("A", c(1,2))
L2 = list(FALSE)
L3 = c(L, L2)
```
```{r lists}
L3
```

The `[[1]]` printed here indicates the first element of the list, similar to the `[1]` we see for atomic vectors.

```{block2 det-classes, type='rmd-details'} 
**Fancier classes** are generally built on top of atomic classes or lists. Behind the scenes, date formats are numeric or integer; while complex objects like data sets and regression results are lists. For details on storage modes, see `?typeof` and the [R internals](https://cran.r-project.org/doc/manuals/r-release/R-ints.html) documentation. While some fancy data structures like linked lists and unordered sets are absent in base R, they can be used through packages like Rcpp. 
```

For lists, in addition to a `length`, we also have `lengths`, measuring each element:

```{r lengths}
lengths(L3)
```

The class of an object can be tested with `is.logical`, etc.

### Making comparisons

To compare two objects, use `==` and `!=`. R will silently coerce the objects' classes to match:

```{r compare-eq}
"4.11" == 4.11
```

In addition, there are the usual inequality operators (`>`, `<`, `>=`, `<=`), which also apply to strings, using lexicographic ordering:

```{r compare-ineq}
"A" >= "B"
```


### Inspecting objects {#str}

For complicated objects, like `L3` above, `class(L3)` is not very informative. Examining the "structure" of the object is usually more useful:

```{r str}
str(L3)
```

To explore the set of loaded objects, see the tools in \@ref(browse-env).

### Named elements {#names}

A vector's elements can be named:

```{r naming}
c(a = 1, b = 2)
list(A = c(1, 2), B = 4)
```

The names of an objects' elements can be accessed with the `names` function.

```{block2 argument-names, type='rmd-caution'}
**Passing arguments.** Inside `c(A = 1)`, the equals sign is not interchangeable with the `<-`, so don't write `c(A <- 1)`. Think of `c` as a function with syntax like `c(argname = argvalue, argname2 = argvalue2, ...)`. The equals sign has the special role of giving names to the function's arguments. See \@ref(passing-arguments) for details.
```

### Missing values {#na}

R differs from other programming languages in its careful treatment of missing values in the reading and processing of data. The missing-data code `NA` is distinct from other special codes:

- a non-number, `NaN`; 
- positive and negative infinity, `Inf` and `-Inf`; and 
- the absence of an object, `NULL`. 

A missing value means "there is a value here, but we don't know what it is." So a comparison against a missing value, like `2 == NA` or `2 != NA`, will always return `NA`, since we cannot determine whether the condition is true or false. To test whether a value is missing, use the `is.na` function.

```{block2 na-classes, type='rmd-details'}
**Implementation of missing values.** The class of an `NA` is different depending on the vector it is in. Sometimes, it is important to ensure that a missing value belongs to a particular class. To ensure this, the safest approach is to "slice" an object of that class with `NA_integer_`. For example, to get a missing numeric value, we can use the number `10` like `10[NA_integer_]`; or for a date value, we can use the current date, `Sys.Date()`, like `Sys.Date()[NA_integer_]`. 
```

### Slicing to a subvector {#slicing}

Select a subvector of `x` like `x[i]`:

```{r slicing-pre}
# example data
x = c("a", "b", "c", "d")
L = list(X = 1, Y = 2, Z = 3)
```
```{r slicing}
x[c(1, 3)]
x[-c(2, 3)]
L[c("Y","Z")]
x[c(FALSE, TRUE, TRUE, FALSE)]
```

So, the index `i` can be...

- a vector of positions to include; 
- a negated vector of positions to exclude; 
- a vector of element names; or 
- a true/false vector, with a selection rule for each position. 

`i` can even contain repeated elements, like `x[c(1,1,2)]`, which is some more general "slice" of `x`, not really a subvector.

```{block2 recycling, type='rmd-caution'}
**Recycling.** What would be the natural behavior of `x[TRUE]` in the example above? Well, in R, it acts like `x[c(TRUE, TRUE, TRUE, TRUE)]`, without giving any warning. This is called recycling -- the argument `i` is repeated until it is long enough for the context is used in. What about `x[c(TRUE, FALSE)]`? The full rules for recycling can be found in the [R intro doc](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#The-recycling-rule).
```

```{block2 fancy-splicing, type='rmd-details'} 
**Special slices.** 
There are a few edge cases worth noting. As mentioned in \@ref(na), it can be useful to set `i` as `NA_integer_` to find the "missing value version of `x`." Similarly, we can set `i` to `0L` to find the "empty version of `x`." Setting `i` to include positions or names outside of range will just yield missing values and is typically not useful.
```

Convenience functions `head` and `tail` enable easy slicing from the start or end of a vector.

... also mention blank slice

### Extracting from a list {#extract-list}

Grab a single element of a vector like `x[[i]]`, where `i` is a single name or number:

```{r extract-pre}
# example data
L = list(X = 1, Y = 2, Z = 3)
```
```{r extract}
L["Z"] # slicing
L[["Z"]] # extracting
```

The slice `L["Z"]` is a list containing just one element; while `L[["Z"]]` *actually is the element*.

`L$Z` offers a handy alternative way of extracting by name from a list, but it is tougher to write a program around.

### Assigning to a subvector {#subassigning}

Assign to a subvector, or "subassign," like `x[i] = y` or `x[i] <- y`:

```{r subassign-pre}
# example data
x = c("a", "b", "c", "d")
L = list(X = 1, Y = 2, Z = 3)
```
```{r subassign}
x[c(2,4)] <- c("bada", "bing")
L[c("Y", "Z")] = list(21, 31)
```

The allowed values of `i` are the same as we saw for slicing a vector in \@ref(slicing). This is fairly unsafe on account of silent coercion, recycling and failure (when `i` is not a valid index of `x`). We will revisit how to modify vectors in data.tables in \@ref(dt-subassign).

```{block2 hidden-docs, type='rmd-caution'}
**Hard-to-find documentation.** For documentation on slicing and extracting, type ``?`[` ``. Even though there is a `]` for every `[`, it is the opening bracket that is the function's actual name, which will come back in \@ref(lapply). For documentation on sub-assignment, type ``?`[<-` ``.
```

caution -- silent extension of vector when assigning at a new index

empty index means the whole thing

### Assigning to a list element

One can similarly assign to a single element of a list with `x[[i]] <- y`. If an existing element is overwritten, no warning is given.

### Initializing {#initializing}

In R, it bad practice to dynamically grow objects, like `x = 1`, `x = c(x,2)`, ..., `x = c(x,n)`. Instead, create the vector with its final length first:

```{r preallocate, eval=FALSE}
x = vector(length = 5, mode = "list")
x = character(length = 5)
x = logical(length = 5)
x = numeric(length = 5)
x = integer(length = 5)
```

From there, we can subassign iteratively if necessary: `x[1] <- "A"`, `x[2] <- "B"`, and so on.

#### Repeating values {#rep}

It's also common to initialize a vector with a particular value using `rep`:

```{r rep}
rep(3, 10)
```

`rep(x, n)` extends nicely to the case where `x` is a vector. It does this in a few different configurations, as documented at `?rep`:

```{r rep-vec}
rep(c(3, 4), 5)
rep(c(3, 4), each = 5)
rep(c(3, 4), length.out = 5)
rep(c(3, 4), c(3, 4))
```

#### Integer sequences

Use a single colon to build a sequence of integers:

```{r seq-colon}
3:5
```

```{block2, type='rmd-caution'} 
**Use parentheses liberally.**

- `n:n+10` does *not* run from `n` to `n+10`. Parentheses are needed: `n:(n+10)`. 
- `-1:3+10` and `10-1:3` do not give the same results. Again, parentheses are needed to clarify which result is wanted. 

See \@ref(order-ops) for more details.
```

If we are running `1..n` where `n` is a nonnegative integer variable, it is safer and more efficient to use `seq_len` than `1:n`. It is safer in the sense that, if `n` is zero, `seq_len(n)` gives the correct result of a zero-length vector, while `1:0` gives `c(1L, 0L)`.

If we are running `1...length(x)` alongside some vector `x`, then `seq_along` is the right tool:

```{r seq-along}
x = c(3, 3, 4)
seq_along(x)
```

```{block2, type='rmd-details'} 
**R function names.** It is not worth trying to make sense of R's naming conventions. Presumably thanks to historical accidents (some involving R's ancestor, S), we have names like `seq.int`, `seq_along`, `setNames`, `Sys.time`, `Sys.Date`, `sys.status` and `system.time`. All names are case-sensitive.
```

#### Fancy sequences {#seq-fancy}

From here, the variety of options starts to resemble what we saw for the `rep` function in \@ref(rep).

The function `seq.int` extends the colon operator:

```{r seq-int}
seq.int(5, 10)
seq.int(5, 10, by = 2)
seq.int(5, by = 3, length.out = 3)
seq.int(to = 100, by = -11, length.out = 3)
```

The `seq` function extends further by allowing for non-integer values:

```{r seq}
seq(5, 10, by=.5)
```

Other vector classes have their own `seq` methods. For example, `seq.Date` will allow for a sequence of dates.

### Factors {#factors}

As with missing values, a lot of thought was put into the treatment of categorical data in R, captured by the `factor` data type:

```{r factors}
factor(c("New York", "Tokyo", "Mumbai", "Tokyo"))
```

Factors often have no sense of ordering (like "Tokyo" naturally coming before "Bombay"), but one can be added if appropriate:

```{r ordered-factors}
factor(c("Worst", "Best", "Not Bad", "Worst"), levels = c("Worst", "Not Bad", "Best"), ordered = TRUE)
```

To see whether a factor has an order, use `is.ordered`. Details on manipulating factors can be found at `?factor` and linked pages.

### Sorting, rank, order

There are three key functions here:

- `sort(x)` will sort the vector.
- `rank(x)` tells where each element of `x` is in the pecking order.
- `order(x)` is rarely useful on its own, but `y[order(x, z)]` will sort `y` by `x` and `z`.

Be careful not to use these functions on an unordered factor, where they will make no sense but run without warning.

The `frank()` function (yes, really) from the data.table package is also useful, for its "dense" rank tie-breaking rule.

### Testing membership

-- move this to Syntax -- too early for the reader to learn elementwise stuff

Besides comparisons, `x == y`, we can test membership like `x %in% y`:

```{r in}
c(1, 3, NA) %in% c(1, 2)
"A" %in% c("A", "A", "B")
```

We get one true/false value for each element on the left-hand side. Duplicate values on the right-hand side are ignored. That is, the right-hand side is treated like a *set*. 

```{r todo-ref-setops, echo=FALSE, eval=FALSE}
We will look at other set operations in @ref(set-ops).
# setops has been removed; maybe migrate to work.rmd
```

Unlike `==`, here we always get a true/false result, even when missing values are present.


### Exercises

1. What is the class of `c(TRUE, 1)`?
2. What is the length of `list(1, c(2,3))`?
3. If I run `x = c("a","b")` and then `x[c(2,1)] = c("c","d")`, what is the value of `x[1]`?
4. Write the command to summon documenation for for the assignment procedure used in `L$X <- list(3)`.

## Matrices and arrays {#matrix-array}

The `matrix` function is used for construction:

```{r matrix-build-pre}
# example data
v = c(1,2,3,4)
```
```{r matrix-build}
matrix(v, nrow = 2, ncol = 2)
matrix(v, nrow = 2, ncol = 2, byrow = TRUE)
```

By default, the matrix is built with column-major order; but `byrow = TRUE` will read as row-major.

The dimensions of a matrix can be extracted with the `dim` function or `nrow` and `ncol`.

All elements of a matrix must have the same class, just like a vector. So we can have a "character matrix", a "numeric matrix", etc. 

```{block2 det-matrices, type='rmd-details'}
**Vectors with attributes.** In fact, a matrix *is* a vector, just augmented by the `dim` attribute. As mentioned at the top, all data in R is stored in vectors; and as mentioned in \@ref(classes), most classes are built on top of vectors. One wrinkle is that `is.vector` is false for matrices. However, this makes sense in light of the doc, `?is.vector`.
```

caution -- column-major, not sure if this needs a box

### Building matrices

Matrices can also be built from vectors with `cbind` and `rbind` (for "binding" columns or rows):

```{r matrix-bind}
rbind(c(1,1), c(2,2))
cbind(c(1,1), c(2,2), c(3,3))
```

These functions can also build matrices from other matrices.

`diag(n)` will make an identity matrix of size `n`; and `diag(v)` will make a diagonal matrix with `v` on the diagonal.

### Named rows and columns

Rows and columns can be named:

```{r matrix-naming}
matrix(c(1,2,3,4), nrow = 2, dimnames = list(c("a","b"), c("x","y")))
```

### Slicing to a submatrix {#slicing-matrix}

To take a matrix slice, selecting a submatrix, use `m[i,j]` as in math:

```{r matrix-slicing-pre, echo=1:2}
# example data
m = matrix(c(1,2,3,4,5,6), nrow = 2, dimnames = list(c("a", "b"), c("x", "y", "z")))
m
```
```{r matrix-slicing}
m[1, c(1,2), drop = FALSE]
m["a", c("x","y"), drop = FALSE]
```

We can get fancy with indices, in all the ways described in \@ref(slicing). It is often covenient to leave one index blank, which means "select all"; try `m[, 2, drop = FALSE]`. 

```{block2 drop, type='rmd-caution'}
**Dropped dimensions.** The `drop = FALSE` option is necessary to ensure that the result is a submatrix. R's default behavior is to "drop" dimensions when it can, which makes for unpredictable output.
```

Implicitly, matrices are regarded as having observations as rows and variables as columns. As a result, `head` and `tail` will return rows from the top and bottom of a matrix, respectively.

### Extracting from matrices {#matrix-extract}

Since matrices *are* vectors, we can extract a vector of values in the same way:

```{r matrix-subset-pre, echo=1:2}
# example data
m = matrix(c(1,2,3,4,5,6), nrow = 2, dimnames = list(c("a", "b"), c("x", "y", "z")))
m
```

```{r matrix-vecsubset}
m[3]
m[c(2,3)]
```

Matrices also allow extraction like `X[Y]`, where `Y` is a two column "index matrix":

```{r matrix-matsubset}
im = matrix(c(1,1,2,2), 2, 2, byrow=TRUE)
m[im]
```

The first column of `im` corresponds to rows, and the second to columns. Elements are extracted in the order they are listed in `im`.

`drop = TRUE` can be used to select a column or row, like `m[, 2]` (where `drop = TRUE` is the default) or a single element, like `m[1, 2]` or `m["a", "y"]`. 

Finally, `diag(m)` will extract the diagonal from a matrix; while `upper.tri` and `lower.tri` extract those parts (in column-major order).

### Subassigning to matrices

Assign to elements of a matrix in one of a few ways: 

- `X[i,j] = z` where `i` and `j` are rows and columns, respectively
- `X[i] = z` with `i` being an index vector
- `X[im] = z` with `im` being an index matrix

In all cases, `z` is a vector or matrix of values.

### Arrays

Arrays are the same as matrices, just in higher dimensions. For example, a three-dimensional array will have a `dim` attribute of length three and have slicing syntax like `a[i,j,k]`. They can be constructed like `a = array(v, dim = c(1,2,2))`.

## Syntax

### Assigning to attributes

There are convenience functions for modifying object attributes, with syntax like `names(x) <- y` or `names(x) = y`. A few are for...

- vector element names, `` ?`names<-` `` 
- vector class, `` ?`class<-` ``
- vector length, `` ?`length<-` ``
- matrix or array dimensions, `` ?`dim<-` `` 
- matrix or array names, `` ?`dimnames<-` `` 

These are rarely needed and can be confusing for obvious reasons.

... also, link to data.table mod by ref

... insert a section on vectorization / elementwise operators, mention interaction with recycling
oh, that section already exists, well, move it up here or carefully avoid elementwise stuff until after that section...

### Arithmetic {#arithmetic}

The full set of arithmetic operators is documented at `?Arithmetic`. The integer division and modulo operators look like `%/%` and `%%`, but otherwise, everything is standard. Other basic functions include `round`, `floor`, `ceiling`, `min`, `max`, `log`, `exp`, `sqrt`.

Essentially all computations involving missing values will return a missing value. One exception is `NA^0` since no matter what number the true value is, this expression will evaluate to `1`. (Recall that a missing value means "there is some true value, but we don't know what it is.") The `min` and `max` functions can ignore missing values, as noted in their docs. \@ref(dt-summary-stats) covers other summarizing functions, all of which similarly offer to ignore `NA`s.

As in [any other programming environment](http://floating-point-gui.de/), floating point arithmetic in R can trip up calculations. For example, try `.1 + .05 - .15 == 0`.

```{block2 arithmetic-bools, type='rmd-caution'}
**Arithmetic with logical values.** Particularly when exploring data, we often want to tally observations meeting some condition. To do this in R, we can treat true/false like 1/0: `is_gt = c(1,5,2) > c(1,2,3); sum(is_gt)`. 
```

```{r todo-ref-tallying, echo=FALSE, eval=FALSE}
Tallying will be revisited in @ref(tallying). 
#tallying was removed, maybe move elsewhere
```



### Logical operators

The self-explanatory symbols `!`, `&` and `|` are used to construct compound logical tests. The treatment of missing values is intuitive:

- `NA | TRUE` is true, since no matter what the missing value is (`TRUE` or `FALSE`), the compound statement must be true.
- `NA & TRUE` is `NA`, since we need to know the missing value to determine the truth or falsehood of the compound statement.
- And so on.

```{block2 logical-nums, type='rmd-caution'}
**Logic with numeric values.** Numbers are treated as `FALSE` when zero and `TRUE` otherwise. This allows us to use `length(x)` as a test instead of `length(x) > 0`.
```

A couple additional symbols, `||` and `&&`, do short circuiting and will be explained in \@ref(vectorization).

### Matrix algebra

- *Transpose* `t(X)` 
- *Multiply* `X %*% Y`

These functions treat a vanilla vector as a column vector.

Remember that the undecorated `*` will always work elementwise (ref above) and silently recycle values.

```{r todo-ref-matrix-more, echo=FALSE, eval=FALSE}
Additional convenience functions for matrix algebra are covered in @ref(matrix-more). 
# figure out where this @matrix-more should go
```




### Order of operations {#order-ops}

The order of operations is listed in `?Syntax`. In addition to the operators listed, `**` is an alias for `^`. The `%any%` listed there refers to a broad class of "infix" binary operators: 

- `%/%` and `%%` for integer division and modulo; 
- `%in%` to test membership; 
- `%*%` for matrix multiplication; and 
- any custom infix operators defined by the user or in loaded packages.

Even knowing the order of operations, I recommend using parentheses liberally, particularly in `!(...)` statements.

### Elementwise operations {#vectorization}

Most operations in R are performed elementwise:

```{r elementwise}
x = c(1, 2)
y = c(2, 3)
x / y
x ^ y
```

We call functions with this behavior "vectorized." R is a lot faster when operations are performed elementwise rather than in a loop, so there's a common mantra to "vectorize your code," especially when doing arithmetic. The idea is similar to translating a statistical model into matrix algebra.

```{block2 recycling-again, type='rmd-caution'}
**Recycling, again.** As we saw in \@ref(slicing), recycling kicks for any vectorized function. So we have `c(-2,2) ^ c(1,2,3,4)` working, with no warning given. Fortunately, there is a warning if the recycling is imperfect, like `c(-2,2) ^ c(1,2,3)`.
```

A couple of notably non-vectorized functions are `&&` and `||`. These will (silently) only look at the first element on each side; and if the result can be determined using the left-hand side, for example in `FALSE && x`, then the right-hand side will not be evaluated. These are useful mostly for improving efficiency on the margins.

## Functions

Functions in R all map input to output. In the documentation for a function, the input is covered in the Arguments section, while the output is in the Value section.

### Community-made functions

#### Exploring packages

R has a variety of packages specialized by task and area of research. The [Task Views](https://cran.r-project.org/web/views/) on the web are a good way to browse available packages on CRAN, the Comprehensive R Archive Network.

Besides adding additional functions, many packages add new classes, for example for time series data.

#### Installing packages

It is best to install packages from CRAN, rather than elsewhere. Packages submitted to CRAN (i) have to pass some vetting procedures defined by the developers of R and and (ii) are typically used much more broadly than those not on CRAN, improving exposure of bugs. 

To install a package from CRAN, use `install.packages`: 

```{r install-fortunes, eval=FALSE}
install.packages("fortunes")
```

The first time this is run during an R session, a prompt will pop up, asking which mirror to download from.

#### Using functions from packages {#namespaces}

After installing a package, a direct attempt at using its functions will fail:

```{r try-fortunes, error=TRUE}
fortune(111)
```

Instead:

```{r use-fortunes}
fortunes::fortune(111)
```
```{r use-fortunes-alt, echo=FALSE, eval=FALSE}
fortunes::fortune(370)
```

This code works because it indicates the "namespace" that the function comes from. See ``?`::` ``.

Another way to use functions from a package is to attach it with `library`: 

```{r use-fortunes-load, warning=FALSE}
library(fortunes)
fortune(347)
```

This adds all of the package's functions and other objects to the search path, so we can write `fortune(111)` instead of the more verbose `fortunes::fortune(111)`. The downside to attaching a package is the risk of "namespace conflicts": 

- If the attached package has an object with the same name as something defined by the user, that object won't enter the global namespace.
- If two attached packages contain objects with the same name, the last-attached object gets precedence for entry into the global namespace.
- Some packages will elbow their way past built-in base functions when attached, with a warning. When this happens, it should probably be taken as a red flag.

Fortunately, in all these cases, R will print a message about the conflicting names.

To remove a package from the namespace, there's `detach`, but I always just restart my R session instead.

#### Reading package docs

To read the doc for a function in a package, just write the full path, like `?fortunes::fortune`. To see a listing of functions provided by a package, use `help(package="fortunes")` or click "Index" at the bottom of the help page for any function in the package.

#### Updating packages

To update a package, just install it again:

```{r update-fortunes, eval=FALSE}
install.packages("fortunes")
```

If a package is loaded (or attached), it cannot be updated, so close all R sessions where the package is loaded before updating it.

type sessionInfo() to view packages and other details about the r session

```{block2, type='rmd-details'} 
**Managing packages.** Use `installed.packages` to view dependencies and version numbers. Some other tools, [rocker](https://github.com/rocker-org/rocker) and [drat](https://github.com/eddelbuettel/drat), look promising.
```

```{block2 pkg-docs, type='rmd-caution'}
**My opinion on trusting packages.** If you don't understand a package's docs, don't use it for anything serious. If the version number of the package is below 1.0, be ready to keep track of its development (since most package developers follow a pattern like [Hadley Wickham's](http://r-pkgs.had.co.nz/release.html)). Packages for input, output or graphing are fragile in any language, so isolate the code that depends on them as much as possible.
```

### Passing arguments {#passing-arguments}

Compare the documentation `?vector` against usage in \@ref(initializing):

```{r preallocate-again, eval=FALSE}
x = vector(length = 5, mode = "list")
```

The arguments are being passed out-of-order, but this still works since the arguments are being passed by name. Passing arguments by the position, like `sort(x, TRUE)`, is a riskier proposition, since it is harder to get right initially and to interpret correctly later. Some data.table idioms for merging (\@ref(dt-joins)) involve passing arguments out-of-order.

### Iterating over a list {#lapply}

To apply the same function to every element of a list, use `lapply`. 

```{r lapply}
lapply(list(c(3,1,4), c(2,7,9), 0), min)
```

`lapply` is a very important tool in R and will come up again and again.

### Writing functions {#function-writing}

```{r todo-explain-funs, echo=FALSE, eval=FALSE}
explain the syntax, starting with function() ending with (possibly implicit) return()
```

Like any other object, functions can be assigned with `<-` or `=`:

```{r fn-def, eval=FALSE}
f = function(x) x^2 + 3
f(4)
```

Or steal a function from elsewhere:

```{r fn-def-steal}
f = fortunes::fortune
```

For more complicated functions, use `{}`:

```{r fn-def-long}
f = function(x){
  x[1] = 999
  return(x)
}
```

`return` provides the return value. If a `return` command is reached before the end of a function, the rest of the code is not run. If no `return` command is given, the last value is used. To return multiple objects, combine them in a list and return it instead.

As with most other objects, R allows function names to be reused without warning, like

```{r fn-def-bad}
min = max
```

Of course, this is usually a bad idea. To eliminate the custom function and revert to the base value, use `rm`:

```{r fn-def-fixup}
rm(min)
```

### Scoping

Consider a function that modifies its input:

```{r scoping-noalter-pre}
# example function
f = function(x){
  x[1] = 999
  return(x)
}
```

Does modification inside the function alter the object passed to it?

```{r-scoping-noalter}
z = c(1,2,3)
f(z)
z
```

We see that the modification does not carry over to the input itself. Usually, nothing created or altered inside a function does, meaning there are no [side effects](http://programmers.stackexchange.com/q/40297/104607). There are ways to write functions with side effects in base R (`<<-` and `assign`), but these are discouraged:

```{r warn-assign}
fortunes::fortune("the assign function")
```

The data.table package, introduced in \@ref(data-table), has a different design philosophy regarding the mutability of objects by functions. *Its core functions almost all hinge on side effects*.

### Lazy evaluation {#lazy}

Now let's see how global variables called inside a function are handled.

```{r lazy-outside}
y = 1
g = function(x) x + y
y = 2
g(1)
y = 3
g(1)
```

So R only looks for `y` when it needs it and no sooner. This is called "lazy evaluation." It has advantages, but can lead to mistakes. The next two sections (\@ref(function-environment) and \@ref(default-args)) cover ways of managing lazy evaluation.

### Environment {#function-environment}

One can use `with` to bind a value to the function:

```{r lazy-with}
g2 = with(list(y = 4), function(x) x + y)
y = 1
g2(1)
```

Now, `y` is defined in the "environment" of the function. Environments are essentially lists, so the value can be extracted following syntax from \@ref(extract-list):

```{r env-extract}
environment(g2)[["y"]]
```

### Default arguments {#default-args}

The documentation shows default values for arguments. After reading `?vector`, we know that `vector()` will return the same thing as `vector(mode = "logical", length = 0)`.

When writing our own functions, we can also use default values. This offers another way of getting around the the issue in \@ref(lazy):

```{r arg-def}
g3 = function(x, y = 4) x + y
g3(1)
g3(1, y = 10)
```

Here, if we don't pass `y` as an argument, the default value prevails. Thanks to lazy evaluation, we can even define default values *in terms of other arguments*:

```{r arg-def-lazy}
g4 = function(x, y = x) x + y
g4(2)
```

### Finding a function by name

When I run into a function and don't know what package it is from, besides searching online, I also sometimes use `help.search` or its `??` shortcut, like `??fortunes`. This will search all installed packages.


### Inspecting function source code {#inspect-fns}

To inspect the R code behind a function, as with any other R object, just type its name:

```{r inspect-obj}
nrow
replace
```

The last two rows of these functions show (i) that they are compiled and (ii) the environment they were defined in.

Many functions are not "exported" for direct use. Nonetheless, their code may be found using `getAnywhere` or accessed directly using `:::` syntax:

```{r inspect-hidden, eval=FALSE}
getAnywhere(head.default)
utils:::head.default
```

Many such hidden functions are "methods"; see `?Methods`. There are also several functions that *should* be hidden, documented at `?.subset`, `?.getNamespace` and elsewhere. These docs always have prominent notes like:

> Not intended to be called directly, and only visible because of the special nature of the base namespace.

Heed the docs and don't use any hidden or should-be-hidden functions directly.

Other functions indicate that their core functionality is written elsewhere:

```{r inspect-c}
max
```

Often, the source code for base R functions is in C and is fairly readable even for the C-illiterate. Following [Joshua Ulrich's instructions](http://stackoverflow.com/a/19226817):

1. Navigate to a copy of the source code.
1. Browse to `/src/main/names.c`
1. Read the `c-entry` column for the function of interest.
1. Search the text of `/src/main/*.c` for it.

## Loops and control flow {#loops}

As in most programming languages, we have `for` loops, `if`/`else` blocks, and so on. Some quirks to note:

- Write `for (i in idx) ...` to iterate over the vector `idx`, even its duplicates.
- Write `else if`, since there is no `elseif`, `elsif` or `elif`.
- Use `next` to bust out of the current iteration of a loop.
- Use `break` to bust out of the loop entirely.

### Thinking about `for` loops {#for-loops}

Suppose we have this loop:

```{r for-loop}
idx = c(1, 2, 3, 4, 5)

x   = numeric(length(idx))
for (i in idx){
  i2    = i^2
  x[i]  = 2*i2 - 1
}
```

There are a couple problems here:

- We have to refer to `x` multiple times, requiring extra coding if we want to reuse this code elsewhere.
- The global environment is polluted by `i` and `i2` in the end.
- There is no need for an iterative approach, since each `x[i]` can be computed independently.

A sibling to `lapply`, our tool for iterating over lists from \@ref(lapply), can help:

```{r sapply}
idx = c(1, 2, 3, 4, 5)
x = sapply(idx, function(i){
  i2    = i^2
  return(2*i2 - 1)
})
```

Of course, there is still one further problem:

- This task can be done with vectorized code!

```{r vectorize}
idx = c(1, 2, 3, 4, 5)
i2  = idx^2
x   = 2*i2 - 1
```

Vectorized code and matrix algebra are much faster than a loop. Loops should be reserved for tasks that really must be performed iteratively. When speed becomes an issue for such tasks, it is time to learn [the Rcpp family of packages](http://www.rcpp.org/), which allow for coding in C++.

```{block2, type='rmd-caution'}
**Breaking an operation.** When running a malfeasant loop (eating up too much memory or taking too long) in the R console, the operation can be broken by pressing `ESC`. This applies elsewhere in R as well, but I usually run into it with loops or one of the several functions documented at `?lapply`.
```

### `if`/`else` elementwise {#ifelse}

```{block2, type='rmd-caution'}
**Dummy variables.** First, if tempted to do `x = if (cond) 1 else 0`, don't. As mentioned in \@ref(arithmetic), the logical variable `cond` itself is perfect for storing this dummy variable.
```

The base R tool for handling elementwise `if`/`else` rules is the function `ifelse`. However, it has some serious shortcomings. A better way, similar to the `gen`/`replace` pattern in Stata, is covered in \@ref(dt-ifelse).

## Data frames {#data-frames}

*My recommendation is always to use a data.table (introduced in \@ref(dt-class)) instead of a data frame, so I've kept this section short.*

Vectors and matrices are fine once we're estimating a statistical model. However, we typically start with data consisting of many observations of multiple variables of varying types. To store data of different types, a vector of matrix won't work; we need a list. R offers a special list structure, the data frame, for this common situation:

```{r df}
# example data
DF = data.frame(
  x = letters[c(1, 2, 3, 4, 5)], 
  y = c(1, 2, 3, 4, 5), 
  z = c(1, 2, 3, 4, 5) > 3
)
DF
```

Data frames are printed with observations on rows and variables on columns. In many ways, they behave like matrices: working with functions like `dim`, `ncol`, `nrow`, `head` and `tail`; using `DF[i, j]` syntax for slices; and even using `DF[im]` syntax for matrix indexing.

```{r df-subset}
DF[3, ]
DF[, "z", drop=FALSE]
im = matrix(c(1,1,2,2), 2, 2, byrow=TRUE) 
DF[im] # DON'T DO THIS
```

The last item above, `DF[im]` is nonsensical in two ways:

- First, all elements in the result are coerced to a single type.
- Second, we are referring to variables by column number instead of name.

Naturally, if the data already is entirely numeric and the remaining analytical tasks are all linear algebra, a matrix will be simpler and almost always computationally faster than a data frame.

### Iterating over columns {#lapply-df}

It is useful to keep in mind that data frames are really lists of columns, not matrices. Because they are lists, we can iterate over columns:

```{r lapply-df}
lapply(DF, function(x) x[3])
```

```{block2, type='rmd-caution'}
**Manual coercion.** We can also get the result of that `lapply` call by coercion to a list: `as.list(DF[3, ])`. The names of similar functions can be guessed: `as.matrix`, `as.data.frame`, `as.vector`, `as.logical`, `as.integer`, `as.numeric`, `as.character`, `as.factor`, and so on. There is `as(x, "class_name")`, but I have found the latter to be finicky.
```

### Inspection {#view}

To browse a data frame in a separate window, use `View(DF)`.

## Built-in constants

R includes several handy constants, like `pi`, the alphabet (`?letters`), months (`?month.name`), days of the week (`?weekdays`) and US state names and abbreviations (`?state`). There is no need to worry about accidentally reusing any of these contants' names for variables (though redefining `pi` might not be a great idea).

```{block2 masking, type='rmd-caution'}
**Masking.** Besides built-in constants, it is also possible to reuse names of variables and functions from base R. In general, this is harmless unless its going to make things confusing, like a `matrix` named "matrix."
```

On a related note, `?Reserved` lists all of R's important built-ins that cannot be overwritten.
